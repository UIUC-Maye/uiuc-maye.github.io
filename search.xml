<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【2021秋招日记】2021.06.18-2021.06.20</title>
      <link href="2021/06/19/%E3%80%902021%E7%A7%8B%E6%8B%9B%E6%97%A5%E8%AE%B0%E3%80%912021-06-18-2021-06-20/"/>
      <url>2021/06/19/%E3%80%902021%E7%A7%8B%E6%8B%9B%E6%97%A5%E8%AE%B0%E3%80%912021-06-18-2021-06-20/</url>
      
        <content type="html"><![CDATA[<h1 id="秋招日记-2021-06-18-2021-06-20（第一周）"><a href="#秋招日记-2021-06-18-2021-06-20（第一周）" class="headerlink" title="秋招日记 2021.06.18-2021.06.20（第一周）"></a>秋招日记 2021.06.18-2021.06.20（第一周）</h1><h2 id="每日目标"><a href="#每日目标" class="headerlink" title="每日目标"></a>每日目标</h2><ol><li><strong>一道easy积1分，一道medium积2分，一道hard积3分；一篇blog积2分，每日目标25分。</strong></li><li><strong>每两天一节acwing的算法课（先以刷题为主，若遇到需要学习的知识点随时调整）</strong></li></ol><h2 id="本周总结"><a href="#本周总结" class="headerlink" title="本周总结"></a>本周总结</h2>]]></content>
      
      
      <categories>
          
          <category> 校招日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021秋招日记】2021.06.18-2021.06.20</title>
      <link href="2021/06/18/%E3%80%902021%E7%A7%8B%E6%8B%9B%E6%97%A5%E8%AE%B0%E3%80%912021-06-18/"/>
      <url>2021/06/18/%E3%80%902021%E7%A7%8B%E6%8B%9B%E6%97%A5%E8%AE%B0%E3%80%912021-06-18/</url>
      
        <content type="html"><![CDATA[<h1 id="秋招日记-2021-06-18-2021-06-20"><a href="#秋招日记-2021-06-18-2021-06-20" class="headerlink" title="秋招日记 2021.06.18-2021.06.20"></a>秋招日记 2021.06.18-2021.06.20</h1><h2 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h2><ol><li><strong>一道easy积1分，一道medium积2分，一道hard积3分；一篇blog积2分，每日目标25分。</strong></li><li><strong>每两天一节acwing的算法课（先以刷题为主，若遇到需要学习的知识点随时调整）</strong></li></ol><h2 id="今日记录"><a href="#今日记录" class="headerlink" title="今日记录"></a>今日记录</h2>]]></content>
      
      
      <categories>
          
          <category> 校招日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021秋招日记】2021.06.19</title>
      <link href="2021/06/18/%E3%80%902021%E7%A7%8B%E6%8B%9B%E6%97%A5%E8%AE%B0%E3%80%912021-06-19/"/>
      <url>2021/06/18/%E3%80%902021%E7%A7%8B%E6%8B%9B%E6%97%A5%E8%AE%B0%E3%80%912021-06-19/</url>
      
        <content type="html"><![CDATA[<h1 id="秋招日记-2021-06-19"><a href="#秋招日记-2021-06-19" class="headerlink" title="秋招日记 2021.06.19"></a>秋招日记 2021.06.19</h1><h2 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h2><ol><li><strong>一道easy积1分，一道medium积2分，一道hard积3分；一篇blog积2分，每日目标25分。</strong></li><li><strong>每两天一节acwing的算法课（先以刷题为主，若遇到需要学习的知识点随时调整）</strong></li></ol><h2 id="今日记录"><a href="#今日记录" class="headerlink" title="今日记录"></a>今日记录</h2>]]></content>
      
      
      <categories>
          
          <category> 校招日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 560. Subarray Sum Equals K</title>
      <link href="2021/05/29/LeetCode-560-Subarray-Sum-Equals-K/"/>
      <url>2021/05/29/LeetCode-560-Subarray-Sum-Equals-K/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1074. Number of Submatrices That Sum to Target</title>
      <link href="2021/05/29/LeetCode-1074-Number-of-Submatrices-That-Sum-to-Target/"/>
      <url>2021/05/29/LeetCode-1074-Number-of-Submatrices-That-Sum-to-Target/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 52. N-Queens II</title>
      <link href="2021/05/29/LeetCode-52-N-Queens-II/"/>
      <url>2021/05/29/LeetCode-52-N-Queens-II/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 664. Strange Printer</title>
      <link href="2021/05/25/LeetCode-664-Strange-Printer/"/>
      <url>2021/05/25/LeetCode-664-Strange-Printer/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode-cn.com/problems/strange-printer/">LeetCode 664. Strange Printer</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>有台奇怪的打印机有以下两个特殊要求：</p><p>打印机每次只能打印由 同一个字符 组成的序列。<br>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。<br>给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。</p><p>示例1:<br>    Input: s = “aaabbb”<br>    Output: 2<br>    Explanation: Print “aaa” first and then print “bbb”.</p><p>要求：</p><pre><code>1 &lt;= s.length &lt;= 100s只有小写字母</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>这道题目个人认为比较特殊，它是一个求最小值的问题，有点像dp，但是好像又和dp没什么关系，难以找出表达式。因此需要多复习，想想其状态转移方程的表示方法。</p><p>我们可以注意一下，对于任意一个子字符串s[i, j]，它的最差的打印方式不外乎就是一个个字符去打印，那么，次数最多就是 j - i + 1 次。如何进行优化呢？</p><p>我们发现，如果s[i] == s[j]，那么在最优解的时候，打印i的时候一定可以把j也附带着打印出来，反正中间的部分可以再被覆盖嘛，无所谓的。所以我们令dp[i][j]表示s[i, j]的打印最优解，此时dp[i][j] = dp[i][j - 1]。</p><p>如果s[i] ≠ s[j]，那么也就是说s[i]和s[j]的打印一定是两次独立的打印，那么具体是什么时候，在哪打印呢？我们不清楚。所以对于s[i, j]这个字符串来说，遍历i到j之间所有的位置k作为“分割线”，通过dp[i][k] + dp[k + 1][j]的最小值，也就是整个s[i, j]的最小值（最优打印方法），至于具体怎么打印的，谁在前，谁在后，没有影响的。</p><p>注意：在我们找到了某个s[i, j]的最优打印次数后，s[i][j]的最优打印方法已经确定了，但对于任意一个包含s[i, j]的字符串来说，并不表示s[i, j]的最优打印解，也是它们最优打印解的子集！！！还是要去进行dp计算的！！！</p><p>首先，对于这种求最值的问题，第一反应就应该是DP，确实这道题是一个经典的斜着DP的题目。</p><p>我们定义dp[i][j]表示从index为i到j的子字符串是否是回文序列。</p><p>base case是当i == j时，dp[i][j] = true；对于其他的任意一对i和j，如果s[i]和s[j]相同，则只要dp[i + 1][j - 1]为true，dp[i][j]就为true，或者 j - i &lt;= 2 也可满足要求，若 j-i == 1，则是两个相邻的字符，类似于“aa”；如果j - i == 2，则有可能是“aba”这种类型的字符串，也是回文字符串。故有如下递推式</p><p>\begin{equation}<br>dp[i][j] = dp[i + 1][j - 1] || j - i \leq 2 \text{  if } s[i] = s[j]<br>\end{equation}</p><p>\begin{equation}<br>dp[i][j] = false \text{  if } s[i] \neq s[j]<br>\end{equation}</p><p>遍历顺序根据自身喜好来，注意j是要大于i的，所以整张dp表只有一半会被遍历到。而且要注意，当计算dp[i][j]的时候，dp[i + 1][j - 1]必须是已经计算完毕的了，因此建议i从后向前计算，也就是从n - 1开始，到0。然后每次j从i + 1到n - 1.</p><p>时间复杂度为O(n ^ 2)，空间复杂度也是O(n ^ 2)</p><h3 id="中心扩散法"><a href="#中心扩散法" class="headerlink" title="中心扩散法"></a>中心扩散法</h3><p>对于每个回文序列来说，它的特性是镜像对称的，也就是说它存在一个中心点（长度为奇数）或者中轴（长度为偶数）。</p><p>对于0到n - 1中任意一个字符i，它可能是中心点，也可能是在某中轴的左右侧。如果他是中心点，那么从i分别向左右扩散，会找到以i为中心的回文子串，直到两端或者不匹配；如果中轴刚好在它的右侧，那么从i向左和i+1向右出发（包括i和i+1），逐渐找到回文字符串。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><h3 id="Dynamic-Programming-bottom-up"><a href="#Dynamic-Programming-bottom-up" class="headerlink" title="Dynamic Programming bottom-up"></a><strong>Dynamic Programming bottom-up</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strangePrinter</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 84. Largest Rectangle in Histogram</title>
      <link href="2021/05/14/LeetCode-84-Largest-Rectangle-in-Histogram/"/>
      <url>2021/05/14/LeetCode-84-Largest-Rectangle-in-Histogram/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 174. Dungeon Game</title>
      <link href="2021/04/27/LeetCode-174-Dungeon-Game/"/>
      <url>2021/04/27/LeetCode-174-Dungeon-Game/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/dungeon-game/">LeetCode 174. Dungeon Game</a></p><p><a href="https://leetcode-cn.com/problems/dungeon-game/">力扣174. 地下城游戏</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>有一个m * n的矩阵，每个格子内有数字（有正有负）。勇士从矩阵的左上角出发，每次只能向右或者向下行动一步，目的地是矩阵右下角。如果要保证到达右下角时，勇士的血量大于0，那么勇士的初始血量最低为多少。</p><p>注:</p><ol><li>骑士的健康点数没有上限。</li><li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li></ol><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>-2(起点)</td><td>-3</td><td>3</td></tr><tr><td>-5</td><td>-10</td><td>1</td></tr><tr><td>-10</td><td>30</td><td>-5(终点)</td></tr></tbody></table><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><p>这道题目也属于二分搜索的经典题目，与之一起的还有<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">LeetCode 154. Find Minimum in Rotated Sorted Array II</a>。</p><p>其实这里就是普通的二分法查找，但是难点是在于check的条件，究竟是大于还是大于等于！！！</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[nums.length - <span class="number">1</span>] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> split = nums[<span class="number">0</span>], l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里需要注意的点在于是大于还是大于等于，乍一看数字是unique的，但是实际上，有等于的可能性。比如[2,1]这个反例，nums[mid] == split。这里要注意。</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= split) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用语言泛型学习总结</title>
      <link href="2021/04/10/%E5%B8%B8%E7%94%A8%E8%AF%AD%E8%A8%80%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>2021/04/10/%E5%B8%B8%E7%94%A8%E8%AF%AD%E8%A8%80%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2021校招</title>
      <link href="2021/03/30/2021%E6%A0%A1%E6%8B%9B/"/>
      <url>2021/03/30/2021%E6%A0%A1%E6%8B%9B/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="国内实习"><a href="#国内实习" class="headerlink" title="国内实习"></a>国内实习</h1><p>由于个人原因，导致暑期可能无法在国内实习，所以就找了少数几个日常实习，暑期实习只面了一个微软。由于我是有全职经验再回学校读书的，所以可能面试内容倾向于项目经验多一点。</p><h2 id="微软"><a href="#微软" class="headerlink" title="微软"></a>微软</h2><p>岗位：C+AI Summer Intern</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>面试官小哥人很好，基本上都在交流项目，全程45分钟，聊了37分钟的项目和经历，算法题是比较常规的，而且只描述了思路，并没有实际coding。</p><p>聊项目经验的事情就先pass了，算法题目是<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">力扣84. 柱状图中最大的矩形</a>，这道题我还没有写题解，写完后会更新上来，这里先简要描述一下思路。</p><p>解法1： 以每个柱形为高，向左向右分别延伸，直到找到第一个比它矮的indexL和indexR，indexR-indexL即为“以当前柱形为高的最大矩形面积”，遍历所有柱形。时间复杂度为O(n^2)。</p><p>解法2：“左侧第一个更矮”和“右侧第一个更矮”，这个算法看起来很熟悉，这里我们可以使用单调栈来进行处理，从左到右过滤一次，从右到左过滤一次，找出每个位置左右第一个更矮的位置。这一步是O(n)的，然后从前至后再扫描一遍数组即可。整体复杂度O(n)。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面的面试官出了两道很有意思的题目，我都没有回答上来，这里记录一下。</p><ol><li>从一个数组中找出最大和最小两个数字，要求<strong>尽可能少的比较次数（不考虑空间问题）</strong>。提示：$\frac{3}{2}n$次。（加减常数也不要考虑了）</li></ol><p>解法：维持两个变量max 和min ，min 标记最小，max标记最大，每次比较相邻两个数，较大者与max比较，较小者与min比较，找出最大最小值，每2个元素比较了3次，总计比较次数为1.5N次。</p><ol start="2"><li>从一个数组中找出最小的两个数字，要求<strong>尽可能少的比较次数（不考虑空间问题）</strong>。提示：$n+log_2^n$次。（加减常数就不要考虑了）</li></ol><p>解法：将数字两两为一组进行比较，每一组筛选出较大的数字和较小的数字，然后将较小的那一组数字进行下一轮的比较，然后进行同样的操作，最终可以选出最小的那个数字，此时，我们总计比较了($1 + 2 + 4 + ….. + \frac{n}{2}$)次，也就是n次。然后第二小的数字，一定是和最小的那个数字比较过，<strong>从和最小的数字比较过的数字中找到最小的数字</strong>，即为第二小的数字。</p><p>算法题：传统的LCS。dp解法，这里就不展开讲了。</p><h3 id="Lead面"><a href="#Lead面" class="headerlink" title="Lead面"></a>Lead面</h3><p>目测是凉了，因为本人是Java选手，C++面经确实一点也没复习，痛了痛了。</p><ol><li>基础题：</li></ol><p>以下代码中二者有什么区别？ a[10]是从栈上分配内存，new是从堆上分配内存。大致明白想考的依图，这样可以聊到C++的内存结构，还有一系列的内容。但是奈何没复习，就直接pass了，不给自己挖坑了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ol start="2"><li>算法题：</li></ol><p>题目：给出一棵二叉树，给出其中的两个节点，计算两个节点之间的距离。</p><p>思路：先按照传统的LCA来找到p和q的Lowest Ancestor，再从LCA出发，找到p和q的depth，进行相加。special case就是p和q可能是LCA本身，这里做个判断即可。实现语言为Java。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;<span class="keyword">this</span>.val = val;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.righr = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode lowestAncestor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distance</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Find the LCA of p and q.</span></span><br><span class="line">        LCA(root, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Return the distance of these two nodes.</span></span><br><span class="line">        <span class="keyword">if</span> (lowestAncestor == p) &#123;</span><br><span class="line">            <span class="keyword">return</span> findDepth(p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lowestAncestor == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> findDepth(q, p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findDepth(lowestAncestor, p) + findDepth(lowestAncestor, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">LCA</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lowestAncestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = LCA(root.left, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = LCA(root.right, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = root == p || root == q ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left + mid + right &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            lowestAncestor = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (left + mid + right) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findDepth</span><span class="params">(TreeNode root, TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = findDepth(root.left, node), r = findDepth(root.right, node);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问：进一步，是否可以将TreeNode优化一下，变成支持子节点可以指向父节点的，可以有什么优化么？</p><p>答：可以用一个hashset记录p的所有ancestors，然后q依次向上去查找ancestor，直到找到第一个ancestor在p所记录的hashset中。</p><p>（算法题结束）</p><ol start="3"><li>设计题：</li></ol><p>这题是真没见过，记录一下给大家提个醒吧。</p><p>题目：给出a，b，c三个大小的水桶，给出一个正整数n，两个问题：（1）写程序判断是否能倒出n升水？（2）如果能倒出，怎么倒？</p><p>答：这是真没见过，见过一次就好了。这题应该用state machine来进行思考，每个水桶的初始状态是一个tuple(a,b,c)，目的是倒出n升水，每一个state都会有一些合法的transition，把这些transition依次遍历，然后递归进行遍历。这里需要用一个set来记录当前路径上的所有state，如果出现了state“回溯”，则也放弃这条分支。直到找到n升水的解决办法。</p><p>注意，这里的n升水，n一定是小于（a,b,c）三者中的最大值的，因为多余的那部分可以用最大的那个桶给直接倒出来，倒$/frac{n}{c}$次。</p><h2 id="字节（offer）"><a href="#字节（offer）" class="headerlink" title="字节（offer）"></a>字节（offer）</h2><h2 id="腾讯（offer）"><a href="#腾讯（offer）" class="headerlink" title="腾讯（offer）"></a>腾讯（offer）</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人blog及使用指南</title>
      <link href="2021/03/05/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>2021/03/05/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo使用过程踩坑记录"><a href="#Hexo使用过程踩坑记录" class="headerlink" title="Hexo使用过程踩坑记录"></a>Hexo使用过程踩坑记录</h2><h3 id="hexo-new-title-时title含有特殊字符无法识别"><a href="#hexo-new-title-时title含有特殊字符无法识别" class="headerlink" title="hexo new title 时title含有特殊字符无法识别"></a>hexo new title 时title含有特殊字符无法识别</h3><p>举个例子，我们想写一篇新的blog叫做”C++指南”的文章，”hexo new C++指南”会出现什么呢？如下：</p><p><img src="/images/hexo%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3pic/hexo-1.jpg" alt="hexo example 1" title="hexo example 1"></p><p>那么如何解决这个问题呢？使用另一种new blog的方式：</p><pre><code>hexo new post &quot;C++指南&quot; -p &quot;C++指南.md&quot;</code></pre><p>完美解决。参考issue： <a href="https://github.com/hexojs/hexo/issues/4104">issue传送门</a></p><h3 id="记录markdown时插入HTML使文字变色"><a href="#记录markdown时插入HTML使文字变色" class="headerlink" title="记录markdown时插入HTML使文字变色"></a>记录markdown时插入HTML使文字变色</h3><pre><code>&lt;font color=12DBF1&gt;Note:&lt;br&gt;1 &lt;= piles.length &lt;= 10^4&lt;br&gt;piles.length &lt;= H &lt;= 10^9&lt;br&gt;1 &lt;= piles[i] &lt;= 10^9&lt;/font&gt;</code></pre><p>效果如下：</p><p><font color=12DBF1>Note:<br><br>1 &lt;= piles.length &lt;= 10^4<br><br>piles.length &lt;= H &lt;= 10^9<br><br>1 &lt;= piles[i] &lt;= 10^9<br></font></p><p>相关HTML颜色代码链接：<a href="https://htmlcolorcodes.com/zh/">颜色代码链接</a></p><p>相关HTML语法链接：<a href="https://www.w3school.com.cn/html/html_tables.asp">W3School HTML</a></p><h3 id="记录markdown时候的一些小语法"><a href="#记录markdown时候的一些小语法" class="headerlink" title="记录markdown时候的一些小语法"></a>记录markdown时候的一些小语法</h3><h4 id="插入另外一篇blog的link"><a href="#插入另外一篇blog的link" class="headerlink" title="插入另外一篇blog的link"></a>插入另外一篇blog的link</h4><p>语法：</p><pre><code>&#123;% post_link markdown的名称(不带.md后缀) 'link显示的名称'%&#125;i.e.: &#123;% post_link LeetCode-46-Permutations '力扣46题'%&#125;</code></pre><p>效果：</p><a href="/2020/06/05/LeetCode-46-Permutations/" title="力扣46题">力扣46题</a><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>语法：</p><pre><code>![Soduku Solution](/images/leetcode37-2.png  &quot;Soduku Solution&quot;)</code></pre><p>效果：</p><p><img src="/images/leetcode37-2.png" alt="Soduku Solution" title="Soduku Solution"></p><h4 id="使用latex公式"><a href="#使用latex公式" class="headerlink" title="使用latex公式"></a>使用latex公式</h4><p>在markdown的最前面加上以下代码：</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;</code></pre><p>效果：$a_x + b = 3$</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常用api汇总</title>
      <link href="2021/03/05/C++%E5%B8%B8%E7%94%A8api%E6%B1%87%E6%80%BB/"/>
      <url>2021/03/05/C++%E5%B8%B8%E7%94%A8api%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊算法题</title>
      <link href="2021/02/26/%E7%89%B9%E6%AE%8A%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>2021/02/26/%E7%89%B9%E6%AE%8A%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络面试知识点</title>
      <link href="2021/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2021/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络面试知识点"><a href="#计算机网络面试知识点" class="headerlink" title="计算机网络面试知识点"></a>计算机网络面试知识点</h1><p>备注：应该把CS438的手写笔记重新整理一遍的。。。拖延症啊拖延症。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>五层：应用层，传输层，网络层，链接层，物理层</p><p>问TCP/IP协议族就是问</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTPS的CA证书认证过程"><a href="#HTTPS的CA证书认证过程" class="headerlink" title="HTTPS的CA证书认证过程"></a>HTTPS的CA证书认证过程</h3><p>大致过程：</p><ol><li>浏览器从服务器拿到证书。证书上有服务器的公钥和CA机构打上的数字签名。</li><li>拿到证书后验证其数字签名。具体就是，根据证书上写的CA签发机构，在浏览器内置的根证书里找到对应的公钥，用此公钥解开数字签名，得到摘要（digest,证书内容的hash值），据此验证证书的合法性。</li></ol><p>多说两句https接下来的加密过程：</p><ol><li>验证完合法性后，在证书里取出服务器的公钥。浏览器生成对称密钥。</li><li>使用服务器公钥对该对称密钥加密，发回给服务器。服务器使用私钥解密，得到对称密钥。</li><li>服务器使用该对称密钥加密后续http数据。使用对称密钥加密是因为比非对称加密高效。</li></ol><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ol><li><p>端口 :HTTP默认使用端口80，而HTTPS默认使用端口443。</p></li><li><p>安全性和资源消耗: HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都 无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有 传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称 加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p><p> 对称加密:密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密 算法有DES、AES等; </p><p> 非对称加密:密钥成对出现(且根据公钥无法推知私钥，根据私钥也无法推知公钥)， 加密解密使用不同密钥(公钥加密需要私钥解密，私钥加密需要公钥解密)，相对对称 加密速度􏰃慢，典型的非对称加密算法有RSA、DSA等。</p></li></ol><h3 id="在浏览器中输入url地址-gt-gt-显示主⻚的过程"><a href="#在浏览器中输入url地址-gt-gt-显示主⻚的过程" class="headerlink" title="在浏览器中输入url地址 -&gt;&gt; 显示主⻚的过程"></a>在浏览器中输入url地址 -&gt;&gt; 显示主⻚的过程</h3><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染⻚面</li><li>连接结束</li></ol><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol><li>基于连接和无连接；</li><li>TCP是可靠，保证数据正确；UDP不可靠，不保证数据正确；</li><li>TCP保证数据顺序到达；UDP不保证数据顺序到达；</li><li>TCP速度慢，因为TCP必须创建连接；UDP速度较快，不需要建立连接；</li><li>因为上述开销，TCP是一个重量级协议；UDP是一个轻量级的协议；</li><li>一个TCP数据包报头的大小是20字节；一个UDP数据报报头是8个字节；</li><li>TCP有流量控制和拥塞控制；UDP不能进行流量控制；</li><li>TCP面向字节流；UDP面向报文；</li><li>应用场景不同，TCP适合对效率要求相对低，但对准确性要求相对高或者是有连接的场景，TCP一般用于文件传输（HTTP，HTTPS，FTP等协议），邮件（POP，SMTP等协议），远程登录等场景；UDP更适合对效率要求相对高，对准确性要求相对低的场景，UDP一般用于即时通信（QQ聊天），在线视频（rtsp流速度一定要快，偶尔丢包没关系），网络语音电话等场景；</li></ol><h3 id="TCP为什么不能有两次握手"><a href="#TCP为什么不能有两次握手" class="headerlink" title="TCP为什么不能有两次握手"></a>TCP为什么不能有两次握手</h3><p>因为需要同步好起始的seq number。注意这里关于序列号的问题，抽空自己总结一下。详见<a href="https://blog.csdn.net/lengxiao1993/article/details/82771768">传送门</a>。</p><h3 id="TCP为什么不能只有三次挥手"><a href="#TCP为什么不能只有三次挥手" class="headerlink" title="TCP为什么不能只有三次挥手"></a>TCP为什么不能只有三次挥手</h3><p>因TCP是全双工的，当FIN接收方收到时，还有可能继续发送信息，所以，中间的那两次不能合并。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层内容看这篇Blog就够了。<a href="https://manistein.github.io/blog/post/network/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B8%AD%E7%9A%84%E4%BC%A0%E8%BE%93/">传送门</a></p><p>网络层呢，干的事情主要是有两个，一个是Routing，一个是Forwarding。相关协议有NAT协议，ICMP协议，BGP协议，RIP协议，OSPF协议。</p><h2 id="链接层（待完善，这里先写点大概）"><a href="#链接层（待完善，这里先写点大概）" class="headerlink" title="链接层（待完善，这里先写点大概）"></a>链接层（待完善，这里先写点大概）</h2><p>链接层主要做的事情就是把network层规划好的内容，具体实际应该是如何传输的。我们如何把一个packet传到下一站？</p><h3 id="IP层包的格式（datagram）"><a href="#IP层包的格式（datagram）" class="headerlink" title="IP层包的格式（datagram）"></a>IP层包的格式（datagram）</h3><h3 id="ARP协议（Address-Resolution-Protocol）"><a href="#ARP协议（Address-Resolution-Protocol）" class="headerlink" title="ARP协议（Address Resolution Protocol）"></a>ARP协议（Address Resolution Protocol）</h3><p>这个协议主要是把IP地址转化为MAC address，A维护一个ARP table，然后broadcast一个ARP query包，这个包包含了B的IP，如果把Dest MAC address设为FF-FF-FF-FF-FF-FF，那么所有的人都收到这个ARP包，如果B收到了ARP包以后，发现自己符合要求，就返回一个包含了自己MAC address的内容回去。（具体如何防止攻击这个没考虑过）</p><h3 id="MAC-Protocol"><a href="#MAC-Protocol" class="headerlink" title="MAC Protocol"></a>MAC Protocol</h3><p>这个就分为很多种了。</p><h4 id="Channel-Partitioning"><a href="#Channel-Partitioning" class="headerlink" title="Channel Partitioning"></a>Channel Partitioning</h4><p>FDMA，TDMA。分时复用或者分频复用。以及其他。</p><h4 id="Random-Partitioning"><a href="#Random-Partitioning" class="headerlink" title="Random Partitioning"></a>Random Partitioning</h4><p>比如ALOHA，slotted ALOHA，CSMA/CD算法，目的是找到碰撞，然后把包发出去。更加难的是wireless的情况下是如何发包的。CSMA/CD的那个状态转换图。</p><h4 id="Taking-Turns"><a href="#Taking-Turns" class="headerlink" title="Taking Turns"></a>Taking Turns</h4><p>大家用一个key去轮流发。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库面试知识点</title>
      <link href="2021/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2021/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库面试知识点（未完待续）"><a href="#数据库面试知识点（未完待续）" class="headerlink" title="数据库面试知识点（未完待续）"></a>数据库面试知识点（未完待续）</h1><h2 id="通用基础"><a href="#通用基础" class="headerlink" title="通用基础"></a>通用基础</h2><h3 id="事务与隔离级别"><a href="#事务与隔离级别" class="headerlink" title="事务与隔离级别"></a>事务与隔离级别</h3><h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p>ACID：原子性（要么做了，要么没做），一致性（多个事务对同一数据读出结果相同），隔离性（事务之间不会相互影响），持久性（事务被提交后，修改是永久的）。</p><h4 id="并发事务导致问题"><a href="#并发事务导致问题" class="headerlink" title="并发事务导致问题"></a>并发事务导致问题</h4><p><strong>脏读(Dirty read):</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交 到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没 有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是 不正确的。</p><p><strong>丢失修改(Lost to modify):</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据， 那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修 改结果就被丢失，因此称为丢失修改。 例如:事务1读取某表中的数据A=20，事务2也读取 A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 </p><p><strong>不可重复读(Unrepeatableread):</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束 时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修 改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不 一样的情况，因此称为不可重复读。</p><p><strong>幻读(Phantom read):</strong> 幻读与不可重复读类似。它发生在一个事务(T1)读取了几行数据，接 着另一个并发事务(T2)插入了一些数据时。在随后的查询中，第一个事务(T1)就会发现多了 一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p><strong>注意不可重复读和幻读区别:</strong> 不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者 删除比如多次读取一条记录发现记录增多或减少了</p><h4 id="SQL事务四大隔离级别"><a href="#SQL事务四大隔离级别" class="headerlink" title="SQL事务四大隔离级别"></a>SQL事务四大隔离级别</h4><ol><li>READ-UNCOMMITTED(读取未提交): 最低的隔离级别，允许读取尚未提交的数据变更，可能会导 致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读取已提交): 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读 或不可重复读仍有可能发生。</li><li>REPEATABLE-READ(可重复读): <strong>对同一字段的多次读取结果都是一致的</strong>，除非数据是被本身事务 自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li>SERIALIZABLE(可串行化): 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个 执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及 幻读。</li></ol><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>关于锁的内容，可以参见这篇Blog：<a href="https://blog.csdn.net/qq_34337272/article/details/80611486">传送门</a></p><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><p>表级锁，行级锁，页级锁。</p><p>页级锁： MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级进行了折衷，一次锁定相邻的一组记录。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</p><p>MyISAM采用表级锁(table-level locking)。 InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>InnoDB实现行级锁的的三种方式：</p><ol><li>Record Lock: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；</li><li>Gap Lock: 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行（<strong>但不能阻止减少</strong>）。</li><li>Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</li></ol><p>备注：InnoDB的行级锁是基于索引实现的，如果查询语句为命中任何索引，那么InnoDB会使用表级锁. 此外，InnoDB的行级锁是针对索引加的锁，不针对数据记录，因此即使访问不同行的记录，如果使用了相同的索引键仍然会出现锁冲突，</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>其实关于索引的内容有很多，包括二级索引，辅助索引等，这篇文章洗的十分全面，有时间详细研读一下。关于索引的详解：<a href="https://blog.csdn.net/universsky2015/article/details/102712058">索引详解</a></p><ol><li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>非聚簇索引：数据存储和索引分开放，索引结构的叶子节点指向了数据的对应行，myisam通过 key_buffer 把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢的原因（磁盘 IO）。</li></ol><h4 id="InnoDB的索引"><a href="#InnoDB的索引" class="headerlink" title="InnoDB的索引"></a>InnoDB的索引</h4><p>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。</p><p>若对Name列进行条件搜索，则需要两个步骤：<strong>第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）</strong>。</p><p>聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。</p><h4 id="MyISM的索引"><a href="#MyISM的索引" class="headerlink" title="MyISM的索引"></a>MyISM的索引</h4><p>MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p><h4 id="索引采用B-树的原因"><a href="#索引采用B-树的原因" class="headerlink" title="索引采用B+树的原因"></a>索引采用B+树的原因</h4><p>B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。所以从Mysql（Inoodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。</p><p>那么Mysql如何衡量查询效率呢？– 磁盘IO次数。 B-树/B+树 的特点就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。</p><p>另一个优点是： B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。</p><p>AVL 树和红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。</p><h4 id="补充面试题"><a href="#补充面试题" class="headerlink" title="补充面试题"></a>补充面试题</h4><ol><li>怎么样确定使用到了索引？通过Explain语句查看是否使用到了索引。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统面试知识点</title>
      <link href="2021/02/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2021/02/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统知识点总结"><a href="#操作系统知识点总结" class="headerlink" title="操作系统知识点总结"></a>操作系统知识点总结</h1><h2 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试知识点</title>
      <link href="2021/02/26/Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2021/02/26/Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试知识点总结"><a href="#Java面试知识点总结" class="headerlink" title="Java面试知识点总结"></a>Java面试知识点总结</h1><p>参考：<a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a></p><h2 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h2><h3 id="JVM的内存分布"><a href="#JVM的内存分布" class="headerlink" title="JVM的内存分布"></a>JVM的内存分布</h3><p>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。</p><h3 id="JVM-GC相关"><a href="#JVM-GC相关" class="headerlink" title="JVM GC相关"></a>JVM GC相关</h3><h3 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h3><h4 id="Java类加载过程"><a href="#Java类加载过程" class="headerlink" title="Java类加载过程"></a>Java类加载过程</h4><h4 id="Java类加载模型——双亲委派模型"><a href="#Java类加载模型——双亲委派模型" class="headerlink" title="Java类加载模型——双亲委派模型"></a>Java类加载模型——双亲委派模型</h4><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需加载的Class)，子类加载器才会尝试自己去加载。</p><p>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</p><h2 id="关键字相关"><a href="#关键字相关" class="headerlink" title="关键字相关"></a>关键字相关</h2><h3 id="关于-final-关键字的一些总结"><a href="#关于-final-关键字的一些总结" class="headerlink" title="关于 final 关键字的一些总结"></a>关于 final 关键字的一些总结</h3><p>final 关键字主要用在三个地方:变量、方法、类。</p><ol><li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改; 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地 指定为 final 方法。</li><li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义;第 二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法 过于庞大，可能看不到内嵌调用带来的任何性能提升(现在的 Java 版本已经不需要使用 final 方法进行这些优化了)。类中所有的 private 方法都隐式地指定为 final。</li></ol><h3 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals"></a>== 与 equals</h3><p>==: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型比较的是值，引用数据类型比较的是内存地址)。</p><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况:</p><ol><li>情况 1:类没有覆盖 equals() 方法。则通过 equals() 比􏰃该类的两个对象时，等价于通过 “WX”比􏰃这两个对象。</li><li>情况 2:类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比􏰃两个对象的内容是 否相等;若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ol><h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h3><p>hashCode() 的作用是获取哈希码，也称为散列码;它实际上是返回一个 int 整数。这个哈希码的作用 是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p><p>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode: 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如 果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h3 id="synchronized和ReentrantLock-的区别"><a href="#synchronized和ReentrantLock-的区别" class="headerlink" title="synchronized和ReentrantLock 的区别"></a>synchronized和ReentrantLock 的区别</h3><p><strong>相同点：</strong>两者都是可重入锁，“可重入锁”概念是:自己可以再次获取自己的内部锁。比如一个线程获得了某个对 象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不 可锁重入的话，就会造成死锁。同一个线程每次获取可重入锁，锁的计数器都自增1，所以要等到锁的计数器 下降为0时才能释放锁。</p><p><strong>不同点</strong>：</p><ol><li><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。</strong> 准确来说，synchronized是一个关键字，是从JVM层面来支持的；但是ReentrantLock是一个类，是一个API，通过lock和unlock来实现的。</li><li><strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong> 。<br> ReentrantLock提供了一种能够中断等待锁的线程的机制。通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。<br> ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平 锁就是先等待的线程先获得锁。<br> 选择性通知。自己没写过，不再详细赘述。</li></ol><h3 id="CAS（Compare-and-Swap）和synchronize有什么区别-都用synchronize不行么"><a href="#CAS（Compare-and-Swap）和synchronize有什么区别-都用synchronize不行么" class="headerlink" title="CAS（Compare and Swap）和synchronize有什么区别?都用synchronize不行么?"></a>CAS（Compare and Swap）和synchronize有什么区别?都用synchronize不行么?</h3><p>CAS是乐观锁，不需要阻塞，硬件级 别实现的原子性;synchronize会阻塞，JVM级别实现的原子性。使用场景不同，线程冲突严重时 CAS会造成CPU压力过大，导致吞吐量下降，synchronize的原理是先自旋然后阻塞，线程冲突严 重仍然有􏰃高的吞吐量，因为线程都被阻塞了，不会占用CPU。</p><h2 id="Java类相关"><a href="#Java类相关" class="headerlink" title="Java类相关"></a>Java类相关</h2><h3 id="String-StringBuffer-和-StringBuilder-的区别是什么"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么" class="headerlink" title="String StringBuffer 和 StringBuilder 的区别是什么?"></a>String StringBuffer 和 StringBuilder 的区别是什么?</h3><p><strong>线程安全性：</strong><br>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、 append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能：</strong><br>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象 引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升， 但却要冒多线程不安全的⻛险。</p><h3 id="（重点）HashMap，HashTable和ConcurrentHashMap"><a href="#（重点）HashMap，HashTable和ConcurrentHashMap" class="headerlink" title="（重点）HashMap，HashTable和ConcurrentHashMap"></a>（重点）HashMap，HashTable和ConcurrentHashMap</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><strong>特性:</strong> 非线程安全，支持NULL为key，扩容每次都是double（和hash算法有关），负载因子是0.75.</p><ol><li>Java 7实现方式： 数组+链表</li><li>Java 8实现方式： 最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</li></ol><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>涉及知识点：可重入锁，自旋锁……(To be continued)</p><p><strong>特性</strong>：线程安全，ConcurrentHashMap是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每 个 Segment 是线程安全的，也就实现了全局的线程安全。Segment默认为16.</p><ol><li>Java 7实现方式： 数组+链表</li><li>Java 8实现方式： 与HashMap类似引入红黑树。且是使用synchronized+CAS，取消了ReentrantLock。</li></ol><p>补充：</p><pre><code>1. get需要加锁么，为什么? (不用，volatile关键字)</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><p>相关知识点：select， poll， epoll</p><ol><li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式。最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用 户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为:data = socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。</li><li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型。当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备 好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。</li><li><strong>多路复用 IO 模型：</strong>是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真 正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通 过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这 种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当 socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。<strong>另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效 率要比用户线程要高的多。</strong></li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就 可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后， 它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内 核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程 发送一个信号，告诉它 read 操作完成了。<strong>也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] dx = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] m, String[] ws)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String word : ws) &#123;</span><br><span class="line">        find(m, word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>[][] m, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1 = m.length, l2 = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[l1][l2];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l2; j++) &#123;</span><br><span class="line">            dfs(m, isVisited, i, j, word, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (res.contains(word)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isVisited记录是否dfs到，i为当前横坐标，j为纵坐标，word为待查找单词，length为当前查找的word里的index，</span></span><br><span class="line"><span class="comment">// 终止条件为length和word.length()相等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] m, <span class="keyword">boolean</span>[][] isVisited, <span class="keyword">int</span> i, <span class="keyword">int</span> j, String word, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == word.length()) &#123;</span><br><span class="line">        res.add(word);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// i和j的坐标越界</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m.length || j &lt; <span class="number">0</span> || j &gt;= m[<span class="number">0</span>].length || isVisited[i][j]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前位置符合下一个元素要求</span></span><br><span class="line">    <span class="keyword">if</span> (m[i][j] == word.charAt(length)) &#123;</span><br><span class="line">        isVisited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">            dfs(m, isVisited, i + dx[x], j + dy[x], word, length+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        isVisited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前位置不符合条件，直接return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 81. Search in Rotated Sorted Array II</title>
      <link href="2021/02/19/LeetCode-81-Search-in-Rotated-Sorted-Array-II/"/>
      <url>2021/02/19/LeetCode-81-Search-in-Rotated-Sorted-Array-II/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 61. 旋转链表</title>
      <link href="2021/02/19/LeetCode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>2021/02/19/LeetCode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode-cn.com/problems/rotate-list/">LeetCode 61. 旋转链表</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><pre><code>Example 1:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExample 2：输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>链表的经典题目之一。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 50. Pow(x, n)</title>
      <link href="2021/02/19/LeetCode-50-Pow-x-n/"/>
      <url>2021/02/19/LeetCode-50-Pow-x-n/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 343. Integer Break</title>
      <link href="2021/02/19/LeetCode-343-Integer-Break/"/>
      <url>2021/02/19/LeetCode-343-Integer-Break/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子 I</a><br><a href="https://leetcode.com/problems/integer-break/">LeetCode 343. Integer Break</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个正整数数字n。将其分割为至少两个正整数，使其加和为n。要求分割后的数字乘积最大。返回乘积。</p><pre><code>Example 1:输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</code></pre><p>2 &lt;= n &lt;= 58</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>dp[n]表示对于组正整数n，其切分后的最大乘积。我们可以得到递推式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span> [<span class="number">1</span>, n/<span class="number">2</span>]:</span><br><span class="line">    dp[n] = <span class="built_in">max</span>(dp[n], <span class="built_in">max</span>(j, dp[j]) * <span class="built_in">max</span>(n - j, dp[n - j]));</span><br></pre></td></tr></table></figure><p>其含义为我们依次取可能的最后一段切分j，那么最大值就等于前后两段分别的最大值乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j, dp[j]) * Math.max(i - j, dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学方法（贪心法）"><a href="#数学方法（贪心法）" class="headerlink" title="数学方法（贪心法）"></a>数学方法（贪心法）</h3><p>证明参考: <a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/">Krahets的题解</a></p><p>通过数学证明，我们可以算出，如果想找最大值，当长度大于4时，每次至以3为大小进行切分，直到长度小于等于4，然后相乘。这道题的进阶版是需要对结果取模。这里要用到取余的性质，同见数学证明，以下的解法是包含了取余，对应题目: <a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">            res = <span class="number">3</span> * res;</span><br><span class="line">            res = res  % <span class="number">1000000007</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(res * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 20. 表示数值的字符串</title>
      <link href="2021/02/19/%E5%89%91%E6%8C%87-Offer-20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/02/19/%E5%89%91%E6%8C%87-Offer-20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题是最经典的那种大烂题，基本上可以归类于if else类型，根据没通过的test case编程。不过这种逻辑也和工程中的业务代码很相似，比较繁琐。从算法题的角度来说，这道题是比较辣鸡的。此题的逻辑卸载注释中，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记是否遇到相应情况</span></span><br><span class="line">        <span class="keyword">boolean</span> numSeen = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> dotSeen = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> eSeen = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span>[] str = s.trim().toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                numSeen = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//.之前不能出现.或者e</span></span><br><span class="line">                <span class="keyword">if</span>(dotSeen || eSeen)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dotSeen = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;e&#x27;</span> || str[i] == <span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//e之前不能出现e，必须出现数</span></span><br><span class="line">                <span class="keyword">if</span>(eSeen || !numSeen)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                eSeen = <span class="keyword">true</span>;</span><br><span class="line">                numSeen = <span class="keyword">false</span>;<span class="comment">//重置numSeen，排除123e或者123e+的情况,确保e之后也出现数</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//+-出现在0位置或者e/E的后面第一个位置才是合法的</span></span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">&#x27;e&#x27;</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//其他不合法字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numSeen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 295. Find Median from Data Stream</title>
      <link href="2021/02/19/LeetCode-295-Find-Median-from-Data-Stream/"/>
      <url>2021/02/19/LeetCode-295-Find-Median-from-Data-Stream/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>两道题是基本一致的，只不过一个是nums[i] &gt; nums[j]，另一个是nums[i] &gt; 2 * nums[j]，这里以剑指offer为例。</p><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p><pre><code>Example 1：输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[1],[2],[],[3],[]]输出：[null,null,null,1.50000,null,2.00000]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题也算是经典题目之一了，其设计思路基本上背过就行了。核心思想是维护两个栈，一个大顶堆，一个小顶堆。<strong>这里要注意的是小顶堆存的是比较大的那一半的数字，大顶堆存的是比较小的那一半数字</strong>。另外，每次当我们插入的时候，我们要<strong>保证小顶堆的大小是大于等于大顶堆的大小的（反之也OK），且相差不能超过1</strong>。如果两个堆的大小相同，则各取堆顶求均值，否则返回小顶堆的堆顶（我们前面保证了小顶堆大小更大）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个heap，一个大顶堆一个小顶堆。</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap, maxHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() == <span class="number">0</span> || num &gt;= minHeap.peek()) &#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() - maxHeap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() - minHeap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() == maxHeap.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (minHeap.peek() + maxHeap.peek()) / <span class="number">2.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 493. Reverse Pairs</title>
      <link href="2021/02/18/LeetCode-493-Reverse-Pairs/"/>
      <url>2021/02/18/LeetCode-493-Reverse-Pairs/</url>
      
        <content type="html"><![CDATA[<p> Problem</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><pre><code>Example 1: 输入: [7,5,6,4]输出: 5限制：0 &lt;= 数组长度 &lt;= 50000</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题有两种做法，一种是分治法，或者说归并排序；另一种是树状数组。这里只写第一种做法，第二种工作法待更新。</p><h3 id="分治法（归并排序）"><a href="#分治法（归并排序）" class="headerlink" title="分治法（归并排序）"></a>分治法（归并排序）</h3><p>对于一个数组，我们先将其分为两段，也就是两个数组，l和r，然后分别进行排序。排好序后，我们进行遍历，两个指针和j，一开始指向l[0]和r[0]，然后r指针不断向后移动，直到r[j] &gt;= r[i]，此时，从mid+1到j之间的所有数字和l[0]构成逆序对！然后i也向后移，直到mid。这样一层层分下去，和归并算法的思路一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        res += mergeSort(nums, l, mid) + mergeSort(nums, mid+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时，左右两侧数组已经有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>; i &lt;= mid; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= r &amp;&amp; nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += j - mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始归并排序</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j  = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                temp[k++] = nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>, n = l; m &lt; temp.length; m++, n++) &#123;</span><br><span class="line">            nums[n] = temp[m];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> divide and conquer </tag>
            
            <tag> binary indexed tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java各种类型转换</title>
      <link href="2021/02/16/Java%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>2021/02/16/Java%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h2><h3 id="各种类型转String"><a href="#各种类型转String" class="headerlink" title="各种类型转String"></a>各种类型转String</h3><ol><li><p>valueOf(boolean b): 返回 boolean 参数的字符串表示形式。.</p></li><li><p>valueOf(char c): 返回 char 参数的字符串表示形式。</p></li><li><p>valueOf(char[] data): 返回 char 数组参数的字符串表示形式。</p></li><li><p>valueOf(char[] data, int offset, int count): 返回 char 数组参数的特定子数组的字符串表示形式。</p></li><li><p>valueOf(double d): 返回 double 参数的字符串表示形式。</p></li><li><p>valueOf(float f): 返回 float 参数的字符串表示形式。</p></li><li><p>valueOf(int i): 返回 int 参数的字符串表示形式。</p></li><li><p>valueOf(long l): 返回 long 参数的字符串表示形式。</p></li><li><p>valueOf(Object obj): 返回 Object 参数的字符串表示形式。</p></li></ol><h2 id="List相关"><a href="#List相关" class="headerlink" title="List相关"></a>List相关</h2><h3 id="List转array"><a href="#List转array" class="headerlink" title="List转array"></a>List转array</h3><p>注意，Integer的List只能一个个添加转为int数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] array = list.toArray(<span class="keyword">new</span> String[list.size()])</span><br></pre></td></tr></table></figure><p>其次，对于list.toArray方法来说，如果传入的数组的大小足够，则使用该数组，否则另外创建一个数组。这里举一个特殊的例子，题目见<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a>。这里的list存的是int[]，然后将其转为二维数组，这里是这么写的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">... </span><br><span class="line"><span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h3 id="array转list"><a href="#array转list" class="headerlink" title="array转list"></a>array转list</h3><p>注意，这里对于int类型，除非使用Java8的stream方式，否则也没有shortcut，只能一个个加到List&lt;Integer&gt;里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(array));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 22. Generate Parentheses</title>
      <link href="2021/02/13/LeetCode-22-Generate-Parentheses/"/>
      <url>2021/02/13/LeetCode-22-Generate-Parentheses/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/generate-parentheses/">LeetCode 22. Generate Parentheses</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个数字n，找出所有可能的括号排列形式。</p><pre><code>Example 1:Input: n = 3Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]Example 2:Input: n = 1Output: [&quot;()&quot;]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/26/2020-06-26/" title="LeetCode 52. N-Queens II">LeetCode 52. N-Queens II</a></li></ol><p>极其经典的”八皇后问题“，用回溯法。跟数独问题基本上是一样的，但是要稍微简单些。</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>典型的回溯法，终结条件为<strong>左括号少于右括号或者括号数量多余给定数字n</strong>。代码如下，这里需要注意的是删除最后一个字符的写法。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        backtrack(sb, res, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(StringBuilder sb, List&lt;String&gt; res, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; left || left &gt; n || right &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (right == n &amp;&amp; left == n) &#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// add a left parenthesis</span></span><br><span class="line">        sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        backtrack(sb, res, left + <span class="number">1</span>, right, n);</span><br><span class="line">        sb.setLength(sb.length() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// add a right parenthesis</span></span><br><span class="line">        sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        backtrack(sb, res, left, right + <span class="number">1</span>, n);</span><br><span class="line">        sb.setLength(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
          <category> medium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 475. Heaters</title>
      <link href="2021/02/12/LeetCode-475-Heaters/"/>
      <url>2021/02/12/LeetCode-475-Heaters/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/heaters/">LeetCode 475. Heaters</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个数组houses和heaters，houses是房子摆放的位置，heaters是加热器摆放的位置，注意，heaters的值不一定是houses里的值！！！求一个最小的加热半径radius，使得所有的房子都可以得到供暖。</p><pre><code>Example 1:Input: houses = [1,2,3], heaters = [2]Output: 1Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.Example 2:Input: houses = [1,2,3,4], heaters = [1,4]Output: 1Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题属于二分搜索的普通应用，确定好，我们的目的是找到一个满足要求的<strong>最小</strong>的radius，因此，是求左边界。</p><p>这里需要注意的是check函数里面，判断是否能够heat的逻辑比较麻烦一点点，这里是一个个house进行判断的，由于两个数组的单调性，我们可以保证二者的关系是单调的，后面house能够被heat的heater绝不会小于前一个house的。</p><p>代码如下：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span>[] heaters)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(houses);</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里使用二分法，l = 0, r = 取heater和house的最大值</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = Math.max(houses[houses.length - <span class="number">1</span>], heaters[heaters.length - <span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (canHeatAll(houses, heaters, mid)) &#123;</span><br><span class="line">                <span class="comment">// 这里是找左边界</span></span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHeatAll</span> <span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span>[] heaters, <span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的逻辑是保证了heaters和houses都是单调的，从前向后遍历的时候可以保证heater的下标永远&lt;=house的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; houses.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; heaters.length &amp;&amp; Math.abs(houses[i] - heaters[j]) &gt; radius) &#123;</span><br><span class="line">                <span class="comment">// 说明当前的heater无法覆盖当前的house，这个写法思路很巧妙！！！</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (j == heaters.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> medium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 653. Two Sum IV - Input is a BST</title>
      <link href="2021/02/09/LeetCode-653-Two-Sum-IV-Input-is-a-BST/"/>
      <url>2021/02/09/LeetCode-653-Two-Sum-IV-Input-is-a-BST/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/">LeetCode 653. Two Sum IV - Input is a BST</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵BST树，以及一个目标数k，判断bst树里是否存在两个node使得其value和为k。</p><p><img src="/images/leetcode653.jpeg" alt="Example" title="Example 1"></p><pre><code>Example: Input: root = [5,3,6,2,4,null,7], k = 9Output: true</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这题和two sum其实是基本一致的，而且可以利用bst树的性质，中序遍历是有序的。但是其实没必要用，直接DFS或者BFS都行，依然利用hashset来查找。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode left;</span></span><br><span class="line"><span class="comment">*     TreeNode right;</span></span><br><span class="line"><span class="comment">*     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment">*     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment">*     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment">*         this.val = val;</span></span><br><span class="line"><span class="comment">*         this.left = left;</span></span><br><span class="line"><span class="comment">*         this.right = right;</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其实这题的核心点在于“two numbers”，也就是说，无论是BFS还是DFS遍历，假设存在a和b两个数字符合要求，那么无论先遍历到a还是b都无所谓，通过hashset来完成查找。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Set &lt; Integer &gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">return</span> find(root, k, set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(TreeNode root, <span class="keyword">int</span> k, Set &lt; Integer &gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(k - root.val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> find(root.left, k, set) || find(root.right, k, set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> easy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> hashset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 102. Binary Tree Level Order Traversal</title>
      <link href="2021/02/09/LeetCode-102-Binary-Tree-Level-Order-Traversal/"/>
      <url>2021/02/09/LeetCode-102-Binary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">LeetCode 102. Binary Tree Level Order Traversal</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵树，返回BFS（广度优先遍历）的结果。</p><pre><code>Example :Given binary tree [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7return its level order traversal as:[[3],[9,20],[15,7]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>没啥好说的，最经典的BFS遍历，5分钟以内应该能默写。</p><p>代码如下：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode left;</span></span><br><span class="line"><span class="comment">*     TreeNode right;</span></span><br><span class="line"><span class="comment">*     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment">*     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment">*     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment">*         this.val = val;</span></span><br><span class="line"><span class="comment">*         this.left = left;</span></span><br><span class="line"><span class="comment">*         this.right = right;</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// 二叉树的BFS</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> levelSize = queue.size();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (levelSize-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 331. Verify Preorder Serialization of a Binary Tree</title>
      <link href="2021/02/08/LeetCode-331-Verify-Preorder-Serialization-of-a-Binary-Tree/"/>
      <url>2021/02/08/LeetCode-331-Verify-Preorder-Serialization-of-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/">LeetCode 331. Verify Preorder Serialization of a Binary Tree</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。</p><pre><code>     _9_    /   \   3     2  / \   / \ 4   1  #  6/ \ / \   / \# # # #   # #例如，上面的二叉树可以被序列化为字符串 &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;，其中 # 代表一个空节点。给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &#39;#&#39; 。你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 &quot;1,,3&quot; 。示例 1:输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;输出: true示例 2:输入: &quot;1,#&quot;输出: false示例 3:输入: &quot;9,#,#,1&quot;输出: false</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考：<a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/discuss/78551/7-lines-Easy-Java-Solution">大神的解法</a></p><p>这道题个人感觉是很奇怪的一道题，有点摸不着头脑，直接看的solution。有一种解法真的十分巧妙。它是将整棵树看成一个图，且null也是一个节点。对于任意一个非root且非null的节点，它都有1个入度和两个出度。如果是一个合法的tree，那么它最终的入度和出度是相等的，如果遍历的时候发现degree数小于0，那么说明这棵树是不合法的。而且，感觉也只能用preorder来这么考，如果是其他的遍历方式，后序遍历或者中序遍历，则不行。想象一下后序遍历，“左右中”的顺序，我们无法知道什么时候到了“中”，它只是一列字符串，很难以判断。因此其实从直觉上讲，只能选择preorder来考。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 主要是要找到前序遍历的特性“中左右”，这题不会，看solution。</span></span><br><span class="line">        <span class="keyword">int</span> degree = <span class="number">1</span>;</span><br><span class="line">        String[] nodes = preorder.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--degree &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node.equals(<span class="string">&quot;#&quot;</span>)) degree += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> degree == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> medium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 153. Find Minimum in Rotated Sorted Array</title>
      <link href="2021/02/04/LeetCode-153-Find-Minimum-in-Rotated-Sorted-Array/"/>
      <url>2021/02/04/LeetCode-153-Find-Minimum-in-Rotated-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">LeetCode 153. Find Minimum in Rotated Sorted Array</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>有一个单调递增的数组，它从中间某个地方被rotate了，找到数组中的最小数字，保证所有数字不重复。例如：</p><ul><li><p>[4,5,6,7,0,1,2] if it was rotated 4 times.</p></li><li><p>[0,1,2,4,5,6,7] if it was rotated 7 times.</p><p>  Example：<br>  Input: nums = [3,4,5,1,2]<br>  Output: 1<br>  Explanation: The original array was [1,2,3,4,5] rotated 3 times.</p></li></ul><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><p>这道题目也属于二分搜索的经典题目，与之一起的还有<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">LeetCode 154. Find Minimum in Rotated Sorted Array II</a>。</p><p>其实这里就是普通的二分法查找，但是难点是在于check的条件，究竟是大于还是大于等于！！！</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[nums.length - <span class="number">1</span>] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> split = nums[<span class="number">0</span>], l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里需要注意的点在于是大于还是大于等于，乍一看数字是unique的，但是实际上，有等于的可能性。比如[2,1]这个反例，nums[mid] == split。这里要注意。</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= split) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 162. Find Peak Element</title>
      <link href="2021/02/04/LeetCode-162-Find-Peak-Element/"/>
      <url>2021/02/04/LeetCode-162-Find-Peak-Element/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/find-peak-element/">LeetCode 162. Find Peak Element</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个数组，找到其中一个peak element的index。peak element指的是严格大于其相邻两个数的元素。保证相邻的两个数字不相同，且假设 nums[-1] = nums[n] = -∞。</p><pre><code>Example: Input: nums = [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2.Constraints:1 &lt;= nums.length &lt;= 1000-231 &lt;= nums[i] &lt;= 231 - 1nums[i] != nums[i + 1] for all valid i.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><p>y总解析传送门，想法真的很巧妙：<a href="https://www.acwing.com/solution/content/258/">链接</a></p><p>当我们比较a[i]和a[i + 1]时，如果a[i] &lt; a[i + 1]，那么假设a[i…n]是单调递增的，那么a[n]就是一个peak；如果a[i…n]不是单调递增的，那么一定存在一个拐点下降，拐点下降的地方就是peak。其中一定存在peak，因为nums[-1] = nums[n] = -∞。如果a[i] &gt; a[i + 1]，同理，a[1…i + 1]一定存在一个拐点。那么对于等于的情况呢？题中保证了nums[i] != nums[i + 1]。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 这里仔细想想，mid可能是峰值么？不可能的，因为nums[mid] &lt; nums[mid + 1]，因此l = mid + 1。</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 456. 132 Pattern</title>
      <link href="2021/02/03/LeetCode-456-132-Pattern/"/>
      <url>2021/02/03/LeetCode-456-132-Pattern/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/132-pattern/">LeetCode 456. 132 Pattern</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false.</p><pre><code>Example 1:Input: nums = [1,2,3,4]Output: falseExplanation: There is no 132 pattern in the sequence.Example2:Input: nums = [-1,3,2,0]Output: trueExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题属于单调栈的高阶玩法。注意，单调栈的模板归模板，实际应用会大于“下一个更大/更小元素”。会有变种，这道题就是一个例子。</p><p>首先，我们需要遍历所有数字，假设所有数字都是”3”，然后找到它左侧的最小值，然后找到它右侧比它小的最大值。但是“找到右侧比它小的最大值”这个问题不能用单调栈模板直接解，我们需要将其做一个转化。假设有a[i]，a[i]右侧有一个数a[j]，a[j]是第一个大于a[i]的数，那么我们需要找的就是[i+1, j-1]之间小于a[i]的最大值。为什么？因为我们知道，a[i]左侧的最小值a1一定是&lt;=a[j]左侧的最小值的，且a[i] &lt; a[j]，如果a[j]的右侧有一个数字a[k]，使得a1,a[i]，a[k]满足“132”条件，那么a1，a[j]，a[k]也一定满足“132”条件，所以当我们遍历到a[j]的时候就会包含这种情况。所以我们只需要考虑a[i]与a[j]之间的比a[i]小的数字。</p><p>根据以上分析，我们知道a[j]就是a[i]的“下一个更大的数字”。因此可以转化为单调栈问题。那么问题来了，我们是要从左到右遍历，还是从右到左遍历呢？记得next greater element是从左到右，这题也是么？不是的，如果我们从左到右遍历，我们怎么知道它右侧数字的情况呢？因此我们需要从右向左遍历。</p><p>代码如下：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到每个数字右侧的比它小的最大数字（在右侧第一个比它大的数字之前）。如果没有的话则为Integer.MIN_VALUE。</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] right_min = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(right_min, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i] &gt; stack.peek()) &#123;</span><br><span class="line">                right_min[i] = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到每个位置左侧的最小值</span></span><br><span class="line">        <span class="keyword">int</span> temp_min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp_min != nums[i] &amp;&amp; temp_min &lt; right_min[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp_min = Math.min(temp_min, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> monotonous stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 239. Sliding Window Maximum</title>
      <link href="2021/01/28/LeetCode-239-Sliding-Window-Maximum/"/>
      <url>2021/01/28/LeetCode-239-Sliding-Window-Maximum/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/sliding-window-maximum">LeetCode 239. Sliding Window Maximum</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个数组arr和数字k，找出以k为大小的sliding window。例如：</p><pre><code>Input: nums = [1,3,-1,-3,5,3,6,7], k = 3Output: [3,3,5,5,6,7]Explanation: Window position                Max---------------               -----[1  3  -1] -3  5  3  6  7       31 [3  -1  -3] 5  3  6  7       31  3 [-1  -3  5] 3  6  7       51  3  -1 [-3  5  3] 6  7       51  3  -1  -3 [5  3  6] 7       61  3  -1  -3  5 [3  6  7]      7</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="monotonous-queue（单调队列）"><a href="#monotonous-queue（单调队列）" class="headerlink" title="monotonous queue（单调队列）"></a>monotonous queue（单调队列）</h3><p>这是单调队列，经典的数据结构之一，算法模板及思路参考：<a href="/2020/07/20/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="算法模板">算法模板</a></p><pre><code class="java">// 解法一：使用Dequeclass Solution &#123;    public int[] maxSlidingWindow(int[] nums, int k) &#123;        // 其实就是单调队列的思想，要用到deque。其核心思想在于，当一个较大的数存在于当前的窗口的时候，在它前面的数字如果比它小，那么都不可能是结果。详情见yxc大佬的课程及笔记。        Deque&lt;Integer&gt; deque = new LinkedList();        int n = nums.length;        int[] res = new int[n - k + 1];                for (int i = 0; i &lt; n; i++) &#123;            // 如果当前队列里面存的数字过多，则将最前面的数字弹出，其实就是边界情况，当window里面数字全部都是降序的时候。            if (!deque.isEmpty() &amp;&amp; i - k + 1 &gt; deque.peekFirst()) &#123;                deque.pollFirst();            &#125;            // 将队尾的所有比当前元素小的全部pop出去，因为它们不可能为解。注意，是队尾！！！不是队首！！！而且要注意有等于的情况！！！            while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i]) &#123;                deque.pollLast();            &#125;             deque.offerLast(i);            if (i &gt;= k - 1) &#123;                res[i - k + 1] = nums[deque.peekFirst()];            &#125;        &#125;                return res;    &#125;&#125;class Solution &#123;    // 这里用数组来模拟双端队列，q就是这个队列，里面存的也是index    int N = 100010, hh = 0, tt = -1;    int[] q = new int[N];        public int[] maxSlidingWindow(int[] nums, int k) &#123;        int[] res = new int[nums.length - k + 1];                for (int i = 0; i &lt; nums.length; i++) &#123;            //             if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;            while (hh &lt;= tt &amp;&amp; nums[q[tt]] &lt;= nums[i]) tt--;                        q[++tt] = i;                        if (i &gt;= k - 1) &#123;                res[i - k + 1] = nums[q[hh]];            &#125;        &#125;                return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> monotonous queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1539. Kth Missing Positive Number</title>
      <link href="2021/01/27/LeetCode-1539-Kth-Missing-Positive-Number/"/>
      <url>2021/01/27/LeetCode-1539-Kth-Missing-Positive-Number/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/kth-missing-positive-number/">LeetCode 1539. Kth Missing Positive Number</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个有序数组和一个正整数k，找到第k个缺失的正整数。例如：</p><pre><code>Example:Input: arr = [2,3,4,7,11], k = 5Output: 9Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>二分查找最重要的是确认好check函数，到底是求上边界还是下边界。搞清楚！！！而且具体题目具体分析。</p><p>这道题里，需要注意的点是check函数中，这里的判断条件是小于还是小于等于。</p><pre><code class="java">class Solution &#123;    public int findKthPositive(int[] arr, int k) &#123;        if (arr[0] &gt; k) &#123;            return k;        &#125;                // arr[index]-index-1就是到当前为止一共缺失的数字。        // 这里的目的是要找到一个位置i，使得到i为止缺失的数字是小于k的最大的。因此是求右边界        // 注意，这里不能是小于等于k，如果是等于的话，比如[1,2,5,6,7,8]，找第2个miss的数字，这里二分出来的数字是8。如果刚刚好是等于k的话，我们不知道前面连续的数字有多少个，往前算起来比较麻烦，因此要注意check条件。        int l = 0, r = arr.length - 1;        while (l &lt; r) &#123;            int mid = l + r + 1 &gt;&gt; 1;            if (arr[mid] - mid - 1 &lt; k) &#123;                l = mid;            &#125; else &#123;                r = mid - 1;            &#125;        &#125;                return arr[l] + k - (arr[l] - l - 1);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 69. Sqrt(x)</title>
      <link href="2021/01/27/LeetCode-69-Sqrt-x/"/>
      <url>2021/01/27/LeetCode-69-Sqrt-x/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/sqrtx/">LeetCode 69. Sqrt(x)</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个数字x，计算其开方，向下取整。</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>最经典的几道题目之一，有很多坑。</p><p>第一，注意不要用 mid * mid，很容易越界，不好办。其次，注意问题的本质，究竟是要求左边界还是右边界！！！也就是check成立时，我们希望继续去找左侧还是右侧。</p><p>这里，我们希望找的是右边界，也就是要找到一个“最大”的y，使得y^2&lt;=x。</p><pre><code class="java">class Solution &#123;    public int mySqrt(int x) &#123;        int l = 0, r = x;                while (l &lt; r) &#123;            // 这里应该是求右边界！！！找到一个数y，使得y^2 &lt;= x            int mid = (l + r + 1) / 2;            if (mid &lt;= x / mid) &#123;                l = mid;            &#125; else &#123;                r = mid - 1;            &#125;        &#125;                return r;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 702. Search in a Sorted Array of Unknown Size</title>
      <link href="2021/01/27/LeetCode-702-Search-in-a-Sorted-Array-of-Unknown-Size/"/>
      <url>2021/01/27/LeetCode-702-Search-in-a-Sorted-Array-of-Unknown-Size/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/">LeetCode 702. Search in a Sorted Array of Unknown Size</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>题目不赘述了，具体点击链接查看。</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题很有意思，数组的大小是未知的，因此，我们需要将其分解成两个子问题。第一，确定二分查找的子区间；第二，二分查找哦啊该区间。</p><p>首先，我们定义l = 0， r = 1，直到reader.get(l) &lt;= target &lt;= reader.get(r)。然后二分查找该区间。算法复杂度为O(logN)</p><pre><code class="java">/** * // This is ArrayReader&#39;s API interface. * // You should not implement it, or speculate about its implementation * interface ArrayReader &#123; *     public int get(int index) &#123;&#125; * &#125; */class Solution &#123;    public int search(ArrayReader reader, int target) &#123;        if (reader.get(0) == target) &#123;            return 0;        &#125;                // 两个子问题，第一个是确认左右边界。这里left初始化为0，right初始化为1，然后每次get右边界。如果右边界&lt;target，那么left=right + 1,right = right * 2。找到合适的区间后再想办法做二分。        int l = 0, r = 1;        while (reader.get(r) &lt; target) &#123;            l = r + 1;            r = r * 2;        &#125;                // 此时，target一定是在[l,r]之间        while (l &lt; r) &#123;            int mid = l + r &gt;&gt; 1;            if (reader.get(mid) == target) &#123;                return mid;            &#125; else if (reader.get(mid) &gt; target) &#123;                r = mid - 1;            &#125; else &#123;                l = mid + 1;            &#125;        &#125;                if (reader.get(l) == target) &#123;            return l;        &#125;                return -1;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 34. Find First and Last Position of Element in Sorted Array</title>
      <link href="2021/01/27/LeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/"/>
      <url>2021/01/27/LeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode 34. Find First and Last Position of Element in Sorted Array</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个有序数组和一个target，找到其上下边界。例如：</p><pre><code>Example:Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>二分查找的模板题目，背背背！！！！</p><pre><code class="java">class Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;        int l = 0, r = nums.length - 1;        int[] res = new int[2];                while (l &lt; r) &#123;            int mid = l + r &gt;&gt; 1;            // 希望取左边界            if (nums[mid] &gt;= target) &#123;                r = mid;            &#125; else &#123;                l = mid + 1;            &#125;        &#125;                if (nums.length == 0 || nums[l] != target) &#123;            res[0] = -1;            res[1] = -1;            return res;        &#125;                res[0] = l;                l = 0;        r = nums.length - 1;        while (l &lt; r) &#123;            int mid = (l + r + 1) &gt;&gt; 1;            if (nums[mid] &lt;= target) &#123;                l = mid;            &#125; else &#123;                r = mid - 1;            &#125;        &#125;        res[1] = l;                return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程上好用的小tips</title>
      <link href="2020/09/02/%E5%B7%A5%E7%A8%8B%E4%B8%8A%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B0%8Ftips/"/>
      <url>2020/09/02/%E5%B7%A5%E7%A8%8B%E4%B8%8A%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B0%8Ftips/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="git配置多个git源"><a href="#git配置多个git源" class="headerlink" title="git配置多个git源"></a>git配置多个git源</h2><p><a href="https://www.jianshu.com/p/698f82e72415">git配置多个ssh key</a></p><h2 id="git将本地项目push到远端"><a href="#git将本地项目push到远端" class="headerlink" title="git将本地项目push到远端"></a>git将本地项目push到远端</h2><p><a href="https://www.jianshu.com/p/c907fa80ab6b">git初始化项目push到远端</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> engineering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板</title>
      <link href="2020/07/20/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
      <url>2020/07/20/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/828/">826. 单链表</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>quick sort的一道题目，关于字符串排序的，剑指offer上的。<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pivot = arr[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(arr[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(arr[j] &gt; pivot);</span><br><span class="line">        <span class="comment">// 注意：重点在这里，要i &lt; j的时候才需要swap，否则不需要！！！</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，这里我们要用j来写下面的递归，不能用i，具体原因y总在第二堂课开头里有讲。主要是边界问题。反之，如果我们前面的pivot用得是arr[r]，那么这里就不能用j，只能用i.</span></span><br><span class="line">    quickSort(arr, l, j);</span><br><span class="line">    quickSort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种写法应该更加亲民一点，只是while循环多了一点内容。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i, l);</span><br><span class="line">    quickSort(arr, l, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>二分查找的边界问题一直很困扰人额，有两种二分查找，一种是求左边界，另一种是求右边界。最直接的题目就是<a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Leetcode 34</a>。既要求左边界，也要求右边界。</p><p>注意，这里左边界和右边界只是一种象征，实际的题目不会这么直白。例如<a href="https://leetcode.com/problems/koko-eating-bananas/">LeetCode 875</a>.</p><p>回到正题，网上有很多二分查找的模板，这里只写我自己的模板，以下所有的区间全都都是闭区间，思路参考acwing的yxc。</p><p>这里有两种情况</p><h3 id="区间被分为-l-mid-和-mid-1-r"><a href="#区间被分为-l-mid-和-mid-1-r" class="headerlink" title="区间被分为[l, mid]和[mid + 1, r]"></a>区间被分为[l, mid]和[mid + 1, r]</h3><p>这种情况的意思就是，当我们做check(mid)的时候，mid是否在我们希望的区间内。换句话说，当mid满足条件时，我们是把它放到左区间还是右区间。比如{1,2,2,2,3,4,5,5}，我们要找到2的左边界，那么当我们找到1个“2”的时候，这个2有可能就是我们要找的值，对吧？那么我们就应该让r = mid，把右边不要的部分去掉，再去遍历左边。反之亦然。</p><p>这里的终止条件都是l==r！！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找左边界</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(mid))&#123;</span><br><span class="line">        r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="区间被分为-l-mid-1-和-mid-r"><a href="#区间被分为-l-mid-1-和-mid-r" class="headerlink" title="区间被分为[l, mid - 1]和[mid, r]"></a>区间被分为[l, mid - 1]和[mid, r]</h3><p>道理和上面类似，只是此时需要mid = (l + r + 1)/2。原因在于除法是向下取整，存在精读缺失，有可能无限死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找右边界，注意l=mid的时候，要+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">        l = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>首先，从名字上来看，单调栈的意思就是，我们通过某些操作，使得栈里的元素都是单调的。</p><p>单调栈解决的问题是“给出一个无序数组，找到每个数字左（右）侧离他最近比它大（小）的数字”。如果一个问题能够抽象成这种类型，那么毫无疑问，马上用单调栈。或者说其他变种，类似于<a href="https://leetcode.com/problems/min-stack/">LeetCode 155. Min Stack</a>，blog解析见<a href="/2021/02/03/LeetCode-456-132-Pattern/" title="LeetCode 456. 132 Pattern">LeetCode 456. 132 Pattern</a>。</p><p>举例：给出一个数组a[]，若要找到 a[7]左侧比它大的数字，假设有a[3]和a[5]，那么我们应该选择a[5]而不是a[3]。那么，换句话说，<strong>对于任意两个数a[i]和a[j]，如果”a[i] &lt;= a[j] &amp;&amp; i &lt; j，那么a[i]可以被抛弃掉，因为对于j后面的数字，a[j]一定是更优的解。”</strong></p><p>这种做法的思想可以理解成<strong>保守式单调栈</strong>，要哪侧的“第一个最大/最小”，就从哪侧开始遍历，保证遍历到每个数的时候，其结果都能确定。</p><p>例题：<a href="https://leetcode.com/problems/next-greater-element-i/">LeetCode 496. Next Greater Element I</a>，该题目的解析link<a href="https://maye.dev/2020/06/18/LeetCode-496-Next-Greater-Element-I/">传送门</a></p><p>这里我们写一个模板，是找到每个数字左侧第一个比它大的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">montonousStack</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= num) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 左侧没有数字比它更大</span></span><br><span class="line">            System.out.print(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>, stack.peek());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color=red>注意：单调栈并不一定是从左向右，或者从右向左！！！</font><p>如上面的左侧第一个更大数字，是从左向右遍历的。那么换种思想，我们从右向左遍历：如果当前数字比栈顶或者等于，则压入；若比栈顶大，则不断弹出，直到栈为空或者小于等于栈顶，然后压栈。<strong>最后栈底剩下的元素，是没有左侧更大元素的！</strong></p><p>这种做法的思想可以理解成<strong>探索式单调栈</strong>，对于未知的情况，我们先保留，最后再一起处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">montonousStack</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length； i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums[i]) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;index %d left greater element is %d\n&quot;</span>, stack.pop(), nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;index %d left greater element is %d\n&quot;</span>, stack.pop(), -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>从单调队列这个名称来看，就是解决某些问题的时候，我们维护一个队列，使得队列里面的的数字呈现单调的情况。</p><p>单调队列解决的问题可以抽象为“求滑动窗口里的最大值和最小值”，最直接的题目就是<a href="/2021/01/28/LeetCode-239-Sliding-Window-Maximum/" title="LeetCode 239. Sliding Window Maximum">LeetCode 239. Sliding Window Maximum</a>。</p><p>对于这种问题，我们举个例子，[1, 3, -1, -3, 5, 3, 6, 7]，窗口大小为3，输出每个窗口里面的最小值（和239基本一致，只是有小区别）。 第一个窗口为[1, 3, -1]，我们可以发现，<strong>当-1只要还在我们的窗口里的时候，在-1左侧的1和3就绝不可能为最小值</strong>。也就是说这两个数对于我们找窗口内最小值完全是冗余的！！！因此，我们需要一种数据结构，保证窗口的正常运转，要能够一边进，一边出，因此我们选择Java里的Deque，双端队列，逻辑如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] minSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 这里用res数组来存储结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前队列里面存的数字过多，则将最前面的数字弹出，其实就是边界情况，当window里面数字全部都是升序的时候。注意判断是否为空！</span></span><br><span class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; i - k + <span class="number">1</span> &gt; deque.peekFirst()) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将队尾的所有比当前元素大的全部pop出去，因为它们不可能为解。注意，是队尾！！！不是队首！！！而且要注意有等于的情况！！！</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里pollLast以后，队列里要么为空，要么是一列升序的数字！！！！！！至于这里为什么要存index，是因为前面需要判断长度的时候需要用index判断窗口大小。</span></span><br><span class="line"></span><br><span class="line">            deque.offerLast(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时，队首的数字就是当前队列里的最小值！！！</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                res[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以使用数组来模拟双端队列。注意写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这里用数组来模拟双端队列，q就是这个队列，里面存的也是index</span></span><br><span class="line"><span class="keyword">int</span> N = <span class="number">100010</span>, hh = <span class="number">0</span>, tt = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] minSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; nums[q[tt]] &gt;= nums[i]) tt--;</span><br><span class="line">        </span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            res[i - k + <span class="number">1</span>] = nums[q[hh]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>递归的写法没啥好说的，这里强调迭代的写法。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>题目链接：<a href="/2020/05/17/LeetCode-144-Binary-Tree-Preorder-Traversal/" title="前序遍历">前序遍历</a></p><p>这里提供两种遍历思路：</p><ol><li>遍历时先压右子树，再压左子树。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        stack.push(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>压栈的目的只是为了回溯找右节点，不是压左右子树，而是访问过的节点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (！stack.isEmpty() || node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop().right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>题目链接：<a href="/2020/05/17/LeetCode-94-Binary-Tree-Inorder-Traversal/" title="中序遍历">中序遍历</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123; <span class="comment">// 下面的循环里保证了node在遍历未结束时不为null</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">while</span> (node.right == <span class="keyword">null</span> &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>判断节点是否为空</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>题目链接：<a href="/2020/05/17/LeetCode-145-Binary-Tree-Postorder-Traversal/" title="后序遍历">后序遍历</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode node = root, lastNode = root;</span><br><span class="line">        stack.push(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> ((node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) || node.left == lastNode || node.right == lastNode) &#123;</span><br><span class="line">                <span class="comment">// node为叶子节点或者访问返回到当前节点</span></span><br><span class="line">                list.add(node.val);</span><br><span class="line">                lastNode = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 栈还没压到叶子节点</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集建议观看<a href="https://www.youtube.com/watch?v=VJnUwsE4fWA&t=733s">花花酱的并查集视频讲解</a></p><p>这里使用size来代替rank，也是可以的，复杂度上没有区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="keyword">int</span>[] sizes;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        sizes = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">            sizes[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == parents[u]) &#123;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line">        parents[u] = find(parents[u]);</span><br><span class="line">        <span class="keyword">return</span> parents[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pu = find(u), pv = find(v);</span><br><span class="line">        <span class="keyword">if</span> (pu == pv) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sizes[pu] &lt; sizes[pv]) &#123;</span><br><span class="line">            parents[pu] = pv;</span><br><span class="line">            sizes[pv] += sizes[pu];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[pv] = pu;</span><br><span class="line">            sizes[pu] += sizes[pv];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 总结 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 57. Insert Interval</title>
      <link href="2020/07/03/LeetCode-57-Insert-Interval/"/>
      <url>2020/07/03/LeetCode-57-Insert-Interval/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/insert-interval/">LeetCode 57. Insert Interval</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一系列区间，合并它们，给出合并后的结果。例如：</p><pre><code>Example 1:Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/07/03/LeetCode-57-Insert-Interval/" title="LeetCode 57. Insert Interval">LeetCode 57. Insert Interval</a></li><li><a href="https://leetcode.com/problems/meeting-rooms-ii/">LeetCode 253. Meeting Rooms II（待做，会议室问题的一系列，很重要）</a></li></ol><p>也算是老经典的区间相关的问题了，可以单独整理一个小专题。慢慢添加，其实和57题基本上是一致的，都是先按照左边界进行排序，然后对右边界进行处理。</p><h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><p>其实最大的问题就是如何合并两个相邻区间，每次先取一个区间，然后和后面的进行合并，直到不能够再合并为止。不能再合并的条件就是后一个的start大于前一个的end，然后先用一个List存着，然后再转为Array，注意List转为Array的方法！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先对区间进行排序</span></span><br><span class="line">        Arrays.sort(intervals, (<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = intervals[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 依次合并后面的可以合并的interval，经过排序后保证了后面的start一定是不小于当前的start的，因此只要判断后者的start和当前的end的大小</span></span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; intervals.length &amp;&amp; intervals[i + <span class="number">1</span>][<span class="number">0</span>] &lt;= temp[<span class="number">1</span>]) &#123;</span><br><span class="line">                temp[<span class="number">1</span>] = Math.max(intervals[i + <span class="number">1</span>][<span class="number">1</span>], temp[<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            merged.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[merged.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
          <category> hard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 77. Combinations</title>
      <link href="2020/07/02/LeetCode-77-Combinations/"/>
      <url>2020/07/02/LeetCode-77-Combinations/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 30. Substring with Concatenation of All Words</title>
      <link href="2020/07/02/LeetCode-30-Substring-with-Concatenation-of-All-Words/"/>
      <url>2020/07/02/LeetCode-30-Substring-with-Concatenation-of-All-Words/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/">30. Substring with Concatenation of All Words</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p><pre><code>示例 1：输入：s = &quot;barfoothefoobarman&quot;,words = [&quot;foo&quot;,&quot;bar&quot;]输出：[0,9]解释：从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。输出的顺序不重要, [9,0] 也是有效答案。示例 2：输入：s = &quot;wordgoodgoodgoodbestword&quot;,words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/07/02/LeetCode-76-Minimum-Window-Substring/" title="力扣76题">力扣76题</a></li></ol><p>这道题有两种解法，暴力解法和优化版暴力解法（双指针）。跟76题有点像。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>第一种就是暴力求解，遍历所有可能的长度为 n * w 的子串(n是单词个数，w为每个单词的长度)，使用hashmap来记录里面每个单词出现的次数，如果和words数组里的单词及出现次数刚好相同，则为一个解，否则继续遍历。这样的话时间复杂度为 o((l - n * w) * (n * w))，共计l - n * w个起始位置，每次遍历长度为 n * w。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> wordLength = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> targetLength = wordLength * words.length;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; targetLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Integer&gt; dict = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">// 初始化一个dict，记录一下各个word出现的频率</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dict.containsKey(word)) &#123;</span><br><span class="line">                dict.put(word, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dict.put(word, dict.get(word) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = targetLength;</span><br><span class="line">        <span class="keyword">while</span> (end &lt;= s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check(dict, s.substring(start, end), wordLength)) &#123;</span><br><span class="line">                res.add(start);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Map&lt;String, Integer&gt; dict, String target, <span class="keyword">int</span> wordLength)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; copy = <span class="keyword">new</span> HashMap();</span><br><span class="line">        copy.putAll(dict);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; target.length()) &#123;</span><br><span class="line">            String word = target.substring(start, start + wordLength);</span><br><span class="line">            <span class="keyword">if</span> (copy.containsKey(word) &amp;&amp; copy.get(word) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                copy.put(word, copy.get(word) - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start += wordLength;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针（滑动窗口）"><a href="#双指针（滑动窗口）" class="headerlink" title="双指针（滑动窗口）"></a>双指针（滑动窗口）</h3><p>我们需要注意一点，就是每个单词的长度是一致的，也就是说我们可以利用单词长度为w的特性。我们可以将s字符串分为w组，起始位置从0到w-1，以w长度为间隔。以下图为例：</p><p><img src="/images/leetcode30-1.jpg" alt="LC37-1" title="LC37-1"></p><p>不同颜色就表示不同的分组情况，两个不同颜色之间表示一个单词。然后我们遍历每种颜色的单词的词组，从前到后，使用一个count值来巧妙表示当前有多少合法的单词，如果count值和words里单词数相等，则为一种解。双指针，或者说滑动窗口也可以，判断每个窗口是否符合要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> w = words[<span class="number">0</span>].length(), n = words.length, l = s.length(), count = <span class="number">0</span>;</span><br><span class="line">        Map&lt;String, Integer&gt; total = <span class="keyword">new</span> HashMap&lt;&gt;(), wd = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            total.put(word, total.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共计w中开始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i++) &#123;</span><br><span class="line">            wd.clear();</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 每次开始进行遍历，步长为w</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j + w &lt;= l; j += w) &#123;</span><br><span class="line">                <span class="comment">// 注意这里有等于，例如单词长度为5，一个单词的情况，我们第一个单词位置是[0, 4]，大小为5的时候已经是下一个单词了，因此是j &gt;=</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i + n * w) &#123;</span><br><span class="line">                    <span class="comment">// 此时，从wd里去掉第一个单词</span></span><br><span class="line">                    String temp = s.substring(j - n * w, j - (n - <span class="number">1</span>) * w);</span><br><span class="line">                    wd.put(temp, wd.get(temp) - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (wd.get(temp) &lt; total.getOrDefault(temp, <span class="number">0</span>)) &#123;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将当前单词插入wd中，如果满足要求，则count++，然后判断。</span></span><br><span class="line">                String temp = s.substring(j, j + w);</span><br><span class="line">                wd.put(temp, wd.getOrDefault(temp, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (wd.get(temp) &lt;= total.getOrDefault(temp, <span class="number">0</span>)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">                    res.add(j - (n - <span class="number">1</span>) * w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointers </tag>
            
            <tag> hashmap </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 76. Minimum Window Substring</title>
      <link href="2020/07/02/LeetCode-76-Minimum-Window-Substring/"/>
      <url>2020/07/02/LeetCode-76-Minimum-Window-Substring/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/minimum-window-substring/">LeetCode 76. Minimum Window Substring</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><font color=12DBF1>Note:<p>1 &lt;= s.length, t.length &lt;= 105</p><p>s 和 t 由英文字母组成<br></font></p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/07/02/LeetCode-30-Substring-with-Concatenation-of-All-Words/" title="力扣30题">力扣30题</a></li></ol><p>所有的思路都在code的注释里了，参考30题。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化目标词典表</span></span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = t.length();</span><br><span class="line">        Map&lt;Character, Integer&gt; total = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            total.put(t.charAt(i), total.getOrDefault(t.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 和30题的思路是一致的，滑动窗口，每次向右滑动一位，判断当前window里的所有字符是否满足要求，关于这个满足要求，可以用一个count值来表示，每次移动的时候做判断。</span></span><br><span class="line">        <span class="comment">// 那么什么时候移动start，什么时候移动end呢？先移动end，直到start到end满足要求后，start向后移动，如果移动一位发现当前的start到end又不满足要求了，则再次移动end，直至终结。</span></span><br><span class="line">        <span class="comment">// 这里能用双指针是因为单调性！！！</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 关于为什么这里for循环只去考虑j呢？也就是比较靠后的指针，因为每次更新j的时候，i都会向后移动尽可能多的位数，如果移动i以后发现满足要求（比当前更小），那就更新。</span></span><br><span class="line">            window.put(arr[j], window.getOrDefault(arr[j], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(arr[j]) &lt;= total.getOrDefault(arr[j], <span class="number">0</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果count == t.length()并且window里面的第i个字符是多余的，那就一直将i右移。</span></span><br><span class="line">            <span class="keyword">while</span> (count == n &amp;&amp; window.getOrDefault(arr[i], <span class="number">0</span>) &gt; total.getOrDefault(arr[i], <span class="number">0</span>)) &#123;</span><br><span class="line">                window.put(arr[i], window.get(arr[i]) - <span class="number">1</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 此时的i到j，如果依然是count == n，说明是符合要求的一种可能性，判断是否需要更新。这里是j - i + 1，不是j - i，因为i到j是双闭区间，不是左闭右开区间。</span></span><br><span class="line">            <span class="keyword">if</span> (count == n &amp;&amp; (j - i + <span class="number">1</span> &lt; res.length() || res.equals(<span class="string">&quot;&quot;</span>))) &#123;</span><br><span class="line">                res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointers </tag>
            
            <tag> sliding window </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 75. Sort Colors</title>
      <link href="2020/07/02/LeetCode-75-Sort-Colors/"/>
      <url>2020/07/02/LeetCode-75-Sort-Colors/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 73. Set Matrix Zeroes</title>
      <link href="2020/07/02/LeetCode-73-Set-Matrix-Zeroes/"/>
      <url>2020/07/02/LeetCode-73-Set-Matrix-Zeroes/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 60. Permutation Sequence</title>
      <link href="2020/06/26/LeetCode-60-Permutation-Sequence/"/>
      <url>2020/06/26/LeetCode-60-Permutation-Sequence/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/spiral-matrix/">LeetCode 54. Spiral Matrix</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个m * n的矩阵，将其螺旋打印出来。例如：</p><pre><code>Example 1:Input:[[ 1, 2, 3 ],[ 4, 5, 6 ],[ 7, 8, 9 ]]Output: [1,2,3,6,9,8,7,4,5]Example 2:Input:[[1, 2, 3, 4],[5, 6, 7, 8],[9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/26/2020-06-26/" title="LeetCode 59. Spiral Matrix II">LeetCode 59. Spiral Matrix II</a></li></ol><p>极其经典的螺旋打印的问题，这里的暴力做法其实是很麻烦的，用方向数组比较好！</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>这里问题其实是在于，如何判断当前行所放的皇后是否合理，这里我的做法是直接将二维的棋盘表示了出来，然后用board[i - x][j - x]表示左上到右下的对角线，用board[i - x][j + x]表示右上到左下的对角线（注意边界）。</p><p>但是其实还有另外一种更为节省空间的做法（其实必要性不大），用bool型数组来表示每一行、每一列、每一个对角线是否已经共存在了一个皇后。如果已知n，那么每一组（左上到右下算一组，左下到右上算一组）对角线的个数也是已知的，2n - 1，然后用[i, j]做一个映射即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 也就是说每一行，每一列，每一个斜线上都不能有任意两个皇后。每一行和每一列都还算好判断，斜线上要怎么判断呢？可以用[i][j]来做映射。但是这里我打算采用一个二维数组来做计算，写起来方便。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] board = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        backtrack(<span class="number">0</span>, n, board, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] board, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断一下是否已经填完了最后一层，如果是，则向结果集中添加一个solution</span></span><br><span class="line">        <span class="keyword">if</span> (line == n) &#123;</span><br><span class="line">            List&lt;String&gt; solution = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    sb.append(board[i][j] == <span class="number">0</span> ? <span class="string">&quot;.&quot;</span> : <span class="string">&quot;Q&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                solution.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(solution);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有填完最后一层，则填line这一层，从0到n-1逐个尝试，每次尝试出一个valid的就继续向下一层出发。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            board[line][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (checkValid(board, line, i)) &#123;</span><br><span class="line">                backtrack(line + <span class="number">1</span>, n, board, res);</span><br><span class="line">            &#125;</span><br><span class="line">            board[line][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkValid</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> line, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查第line行，pos位置放queen是否合法（同一行无须检查）</span></span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查同一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][pos] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左上到右下的对角线，注意只用检查line线以上的即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = line - <span class="number">1</span>, j = pos - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左下到右上的对角线，注意只用检查line线以上的即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = line - <span class="number">1</span>, j = pos + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
          <category> medium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-06-26</title>
      <link href="2020/06/26/2020-06-26/"/>
      <url>2020/06/26/2020-06-26/</url>
      
        <content type="html"><![CDATA[<h1 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h1><h2 id="LeetCode-52-N-Queens-II"><a href="#LeetCode-52-N-Queens-II" class="headerlink" title="LeetCode 52. N-Queens II"></a><a href="https://leetcode.com/problems/n-queens-ii/">LeetCode 52. N-Queens II</a></h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>和<a href="/2020/06/26/LeetCode-51-N-Queens/" title="LeetCode 51. N-Queens">LeetCode 51. N-Queens</a>一模一样，只是这个要求数量，而不是所有的解。</p><h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] board = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        backtrack(<span class="number">0</span>, n, board);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断一下是否已经填完了最后一层，如果是，则向结果集中添加一个solution</span></span><br><span class="line">        <span class="keyword">if</span> (line == n) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有填完最后一层，则填line这一层，从0到n-1逐个尝试，每次尝试出一个valid的就继续向下一层出发。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            board[line][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (checkValid(board, line, i)) &#123;</span><br><span class="line">                backtrack(line + <span class="number">1</span>, n, board);</span><br><span class="line">            &#125;</span><br><span class="line">            board[line][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkValid</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> line, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查第line行，pos位置放queen是否合法（同一行无须检查）</span></span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查同一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][pos] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左上到右下的对角线，注意只用检查line线以上的即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = line - <span class="number">1</span>, j = pos - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左下到右上的对角线，注意只用检查line线以上的即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = line - <span class="number">1</span>, j = pos + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">countCharacters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要求：按照字典序输出，但是hashmap本身就不保证顺序，还是使用treemap来保证有序性。</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Map&lt;String, Integer&gt; res = <span class="keyword">new</span> TreeMap&lt;String, Integer&gt;(</span><br><span class="line">                <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String obj1, String obj2)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 升序排序</span></span><br><span class="line">                        <span class="keyword">return</span> obj1.compareTo(obj2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            String temp = s.substring(i, i + <span class="number">1</span>);</span><br><span class="line">            res.put(temp, res.getorDefault(temp, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOddEvenNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution2 solution2 = <span class="keyword">new</span> Solution2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个线程，一个打印奇数，一个打印偶数</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Thread.currentThread().setName(<span class="string">&quot;打印偶数的线程 &quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    printNum.printOdd();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Thread.currentThread().setName(<span class="string">&quot;打印奇数的线程&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    printNum.printEven();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于打印偶数的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">printEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前打印的数字是否为偶数，如果不是，则等待</span></span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是偶数</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        num++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知另一个线程</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于打印奇数的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">printOdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前打印的数字是否为奇数，如果不是，则等待</span></span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">2</span> != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是奇数</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        num++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知另一个线程</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> daily diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 56. Merge Intervals</title>
      <link href="2020/06/26/LeetCode-56-Merge-Intervals/"/>
      <url>2020/06/26/LeetCode-56-Merge-Intervals/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/merge-intervals/">LeetCode 56. Merge Intervals</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一系列区间，合并它们，给出合并后的结果。例如：</p><pre><code>Example 1:Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/07/03/LeetCode-57-Insert-Interval/" title="LeetCode 57. Insert Interval">LeetCode 57. Insert Interval</a></li><li><a href="https://leetcode.com/problems/meeting-rooms-ii/">LeetCode 253. Meeting Rooms II（待做，会议室问题的一系列，很重要）</a></li></ol><p>也算是老经典的区间相关的问题了，可以单独整理一个小专题。慢慢添加，其实和57题基本上是一致的，都是先按照左边界进行排序，然后对右边界进行处理。</p><h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><p>其实最大的问题就是如何合并两个相邻区间，每次先取一个区间，然后和后面的进行合并，直到不能够再合并为止。不能再合并的条件就是后一个的start大于前一个的end，然后先用一个List存着，然后再转为Array，注意List转为Array的方法！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先对区间进行排序</span></span><br><span class="line">        Arrays.sort(intervals, (<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = intervals[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 依次合并后面的可以合并的interval，经过排序后保证了后面的start一定是不小于当前的start的，因此只要判断后者的start和当前的end的大小</span></span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; intervals.length &amp;&amp; intervals[i + <span class="number">1</span>][<span class="number">0</span>] &lt;= temp[<span class="number">1</span>]) &#123;</span><br><span class="line">                temp[<span class="number">1</span>] = Math.max(intervals[i + <span class="number">1</span>][<span class="number">1</span>], temp[<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            merged.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[merged.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
          <category> medium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 54. Spiral Matrix</title>
      <link href="2020/06/26/LeetCode-54-Spiral-Matrix/"/>
      <url>2020/06/26/LeetCode-54-Spiral-Matrix/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/spiral-matrix/">LeetCode 54. Spiral Matrix</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个m * n的矩阵，将其螺旋打印出来。例如：</p><pre><code>Example 1:Input:[[ 1, 2, 3 ],[ 4, 5, 6 ],[ 7, 8, 9 ]]Output: [1,2,3,6,9,8,7,4,5]Example 2:Input:[[1, 2, 3, 4],[5, 6, 7, 8],[9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/26/2020-06-26/" title="LeetCode 59. Spiral Matrix II">LeetCode 59. Spiral Matrix II</a></li></ol><p>极其经典的螺旋打印的问题，这里的暴力做法其实是很麻烦的，用方向数组比较好！</p><h3 id="暴力解法——螺旋打印"><a href="#暴力解法——螺旋打印" class="headerlink" title="暴力解法——螺旋打印"></a>暴力解法——螺旋打印</h3><p>注意这里的边界情况是只有一行或者一列的情况，要特殊处理，比较麻烦，建议直接去看第二写法或者解法二。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次打印一圈，直至index越界直接return，写一个子函数。</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        helper(matrix, <span class="number">0</span>, <span class="number">0</span>, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span> <span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> height = m - <span class="number">2</span> * i, width = n - <span class="number">2</span> * j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 越界的情况</span></span><br><span class="line">        <span class="keyword">if</span> (width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩下一行或一列的情况</span></span><br><span class="line">        <span class="keyword">if</span> (height == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</span><br><span class="line">                res.add(matrix[i][j + x]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (width == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; height; x++) &#123;</span><br><span class="line">                res.add(matrix[i + x][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始按圈添加res</span></span><br><span class="line">        <span class="comment">// 上方一行，例如[1,2]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width - <span class="number">1</span>; x++) &#123;</span><br><span class="line">            res.add(matrix[i][j + x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右侧一列，例如[3,6]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; height - <span class="number">1</span>; x++) &#123;</span><br><span class="line">            res.add(matrix[i + x][j + width - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下方一行，例如[9,8]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width - <span class="number">1</span>; x++) &#123;</span><br><span class="line">            res.add(matrix[i + height - <span class="number">1</span>][j + width - <span class="number">1</span> - x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左侧一列，例如[7, 4]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; height - <span class="number">1</span>; x++) &#123;</span><br><span class="line">            res.add(matrix[i + height - <span class="number">1</span> - x][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        helper(matrix, i + <span class="number">1</span>, j + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种写法和下面的解法二有异曲同工之妙，最好记一下，这样不需要去使用额外的m*n的空间，也就是isVisited数组。题解链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="comment">// left to right.</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="comment">// top to bottom.</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="comment">// right to left.</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="comment">// bottom to top.</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方向数组巧妙解法"><a href="#方向数组巧妙解法" class="headerlink" title="方向数组巧妙解法"></a>方向数组巧妙解法</h3><p>对于这种需要四个方向dfs的题目来说，方向数组最适合不过了，对于四个方向，只需要定义dx和dy即可。也就是说dx = [-1, 1, 0, 0]， dy = [0, 0, -1, 1]，分别对应“上下左右”四个方向，每次只需要判断是否越界或者已经填充即可。这么写的好处是节省脑力，不需要判断每次的长度，很省事！！！但是相应的有一丢丢浪费空间，因为需要额外的bool数组来存储每个数字是否已经打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 这里用一个boolean数组来定义是否已经访问过该数字</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="comment">// 定义四个方向，此题的顺序应该是右下左上，注意顺序</span></span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 定义一个返回的结果集</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, direction = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (res.size() &lt; m * n) &#123;</span><br><span class="line">            res.add(matrix[x][y]);</span><br><span class="line">            isVisited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (x + dx[direction] &lt; <span class="number">0</span> || x + dx[direction] &gt;= m || y + dy[direction] &lt; <span class="number">0</span> || y + dy[direction] &gt;= n || isVisited[x + dx[direction]][y + dy[direction]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 此时需要变更方向</span></span><br><span class="line">                direction = (direction + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x += dx[direction];</span><br><span class="line">            y += dy[direction];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
          <category> hard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 51. N-Queens</title>
      <link href="2020/06/26/LeetCode-51-N-Queens/"/>
      <url>2020/06/26/LeetCode-51-N-Queens/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/n-queens/">LeetCode 51. N-Queens</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个整形数n，找出”n皇后问题“的所有解。每一行，每一列以及每个皇后所在的对角线不能包含其他皇后。例如：</p><p><img src="/images/leetcode51.png" alt="Example" title="Example"></p><pre><code>Example:Input: 4Output: [[&quot;.Q..&quot;,  // Solution 1&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,  // Solution 2&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/26/2020-06-26/" title="LeetCode 52. N-Queens II">LeetCode 52. N-Queens II</a></li></ol><p>极其经典的”八皇后问题“，用回溯法。跟数独问题基本上是一样的，但是要稍微简单些。</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>这里问题其实是在于，如何判断当前行所放的皇后是否合理，这里我的做法是直接将二维的棋盘表示了出来，然后用board[i - x][j - x]表示左上到右下的对角线，用board[i - x][j + x]表示右上到左下的对角线（注意边界）。</p><p>但是其实还有另外一种更为节省空间的做法（其实必要性不大），用bool型数组来表示每一行、每一列、每一个对角线是否已经共存在了一个皇后。如果已知n，那么每一组（左上到右下算一组，左下到右上算一组）对角线的个数也是已知的，2n - 1，然后用[i, j]做一个映射即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 也就是说每一行，每一列，每一个斜线上都不能有任意两个皇后。每一行和每一列都还算好判断，斜线上要怎么判断呢？可以用[i][j]来做映射。但是这里我打算采用一个二维数组来做计算，写起来方便。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] board = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        backtrack(<span class="number">0</span>, n, board, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] board, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断一下是否已经填完了最后一层，如果是，则向结果集中添加一个solution</span></span><br><span class="line">        <span class="keyword">if</span> (line == n) &#123;</span><br><span class="line">            List&lt;String&gt; solution = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    sb.append(board[i][j] == <span class="number">0</span> ? <span class="string">&quot;.&quot;</span> : <span class="string">&quot;Q&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                solution.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(solution);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有填完最后一层，则填line这一层，从0到n-1逐个尝试，每次尝试出一个valid的就继续向下一层出发。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            board[line][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (checkValid(board, line, i)) &#123;</span><br><span class="line">                backtrack(line + <span class="number">1</span>, n, board, res);</span><br><span class="line">            &#125;</span><br><span class="line">            board[line][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkValid</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> line, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查第line行，pos位置放queen是否合法（同一行无须检查）</span></span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查同一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][pos] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左上到右下的对角线，注意只用检查line线以上的即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = line - <span class="number">1</span>, j = pos - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左下到右上的对角线，注意只用检查line线以上的即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = line - <span class="number">1</span>, j = pos + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
          <category> hard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 49. Group Anagrams</title>
      <link href="2020/06/25/LeetCode-49-Group-Anagrams/"/>
      <url>2020/06/25/LeetCode-49-Group-Anagrams/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/group-anagrams/">LeetCode 49. Group Anagrams</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一组字符串（全部由小写字母组成），将由相同字母组成的字符串按组进行返回。例如：</p><pre><code>Example:Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;bat&quot;]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>其实这道题是很直接的一道题，问题就在于统计anagram，如何才能判断两个字符串啊anagram。这里我们用一个很巧妙的hash方法，记录每个字符串组成字母的哈希值。如下：</p><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str : strs)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] strArray = str.toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] keyArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : strArray) &#123;</span><br><span class="line">                keyArray[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 用一个字符串来表示一个特殊的hash key。</span></span><br><span class="line">            String key = String.valueOf(keyArray);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!result.containsKey(key))&#123;</span><br><span class="line">                result.put(key, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            result.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
          <category> medium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash table </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 42. Trapping Rain Water</title>
      <link href="2020/06/23/LeetCode-42-Trapping-Rain-Water/"/>
      <url>2020/06/23/LeetCode-42-Trapping-Rain-Water/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/trapping-rain-water/">LeetCode 42. Trapping Rain Water</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一组非负整数表示地形，每一个竖条的宽度为1，计算下雨后，地形中能储存多少水。例如：</p><p><img src="/images/leetcode42.png" alt="Example" title="Example 1"></p><pre><code>Example:Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/18/LeetCode-503-Next-Greater-Element-II/" title="LeetCode 503. Next Greater Element II">LeetCode 503. Next Greater Element II</a></li><li><a href="/2020/06/18/LeetCode-556-Next-Greater-Element-III/" title="LeetCode 556. Next Greater Element III">LeetCode 556. Next Greater Element III</a></li><li><a href="https://leetcode.com/problems/daily-temperatures/">LeetCode 739. Daily Temperatures(无解析)</a></li></ol><h3 id="monotonous-stack（单调栈）"><a href="#monotonous-stack（单调栈）" class="headerlink" title="monotonous stack（单调栈）"></a>monotonous stack（单调栈）</h3><p>自己复习的时候直接看<a href="https://www.acwing.com/video/1364/">yxc的题解21分40秒</a>，有图才能更清晰。这里不做过多的解释了，很难讲。</p><p>其实这道题是属于单调栈的一种不常见的case，也是属于单调栈的一种，我们每次遇到一个“洼地”的时候其实需要计算一下可以存多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">int</span> n = height.length, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// last用来记录上一次的高度，这里初始化为0是为了防止边界情况，首次pop的时候不计算面积。</span></span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt;= height[stack.peek()]) &#123;</span><br><span class="line">                <span class="comment">// 这里首次计算的时候，i - stack.peek() - 1一定为0，这里是做了一个mapping。</span></span><br><span class="line">                res += (height[stack.peek()] - last) * (i - stack.peek() - <span class="number">1</span>);</span><br><span class="line">                last = height[stack.pop()];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果pop完以后发现左侧还有一个更高的，把小尾巴计算上（以【4，2，3】为例）</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                res += (i - stack.peek() - <span class="number">1</span>) * (height[i] - last);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
          <category> hard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> monotonous stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-06-22</title>
      <link href="2020/06/22/2020-06-22/"/>
      <url>2020/06/22/2020-06-22/</url>
      
        <content type="html"><![CDATA[<h1 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h1><h2 id="LeetCode-43-Multiply-Strings"><a href="#LeetCode-43-Multiply-Strings" class="headerlink" title="LeetCode 43. Multiply Strings"></a><a href="https://leetcode.com/problems/multiply-strings/">LeetCode 43. Multiply Strings</a></h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h4 id="乘法直接计算"><a href="#乘法直接计算" class="headerlink" title="乘法直接计算"></a>乘法直接计算</h4><p>这道题怎么说呢，做过不难，但是有很多细节，见代码注释。</p><p>这里我们先对num1[i]和num2[j]进行乘积，将其暂时存到一个初始化长度为m + n的int数组num中，其中num1[i]和num2[j]相乘我们存储到num[i + j]中，对于i + j相同的值我们加起来存到num[i + j]上。因为长度m的数和长度为n的数字相乘，最多也不过m + n - 1的长度，因此我们不必担心溢出的问题。</p><p>然后再进行进位操作，一位位进行计算，细节注释如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(zero) || num2.equals(zero)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zero;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这道题很巧妙，我们不需要每次乘一次就去运算各种进位什么的，不划算，直接记录每一位的进位值，画个图就懂了。</span></span><br><span class="line">        <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">        <span class="keyword">int</span>[] numA = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">int</span>[] numB = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] num= <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从低位到高位存储每一位数字，计算的时候低位运算结果也要写在前面，为了防止和没用到的0相冲突！！！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            numA[m - <span class="number">1</span> - i] = num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            numB[n - <span class="number">1</span> - i] = num2.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res从低位到高位存储，index从0开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                num[i + j] += numA[i] * numB[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从前向后计算进位</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; i++) &#123;</span><br><span class="line">            temp += num[i];</span><br><span class="line">            num[i] = temp % <span class="number">10</span>;</span><br><span class="line">            temp = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前遍历，去掉多余的0，也就是多余的高位0不要</span></span><br><span class="line">        <span class="keyword">int</span> end = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &gt;= <span class="number">0</span> &amp;&amp; num[end] == <span class="number">0</span>) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前依次append每一位</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sb.append(Integer.toString(num[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-48-Rotate-Image"><a href="#LeetCode-48-Rotate-Image" class="headerlink" title="LeetCode 48. Rotate Image"></a><a href="https://leetcode.com/problems/rotate-image/">LeetCode 48. Rotate Image</a></h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><h4 id="翻转做法（很tricky）"><a href="#翻转做法（很tricky）" class="headerlink" title="翻转做法（很tricky）"></a>翻转做法（很tricky）</h4><p>这道题算是脑筋急转弯，直接背解法即可。</p><p>将数组先沿着左上角到右下角的轴线进行对折翻转，然后沿着竖轴中线进行翻转，即可得到答案。</p><p>其实这道题还有多种对折方式，画一下，尝试一下！！！顺时针转90度，逆时针转90度等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先沿着对角线翻转，左上角到右下角的那条线；然后再沿着中轴竖着翻转；</span></span><br><span class="line">        <span class="comment">// 或者沿着左下角到右上角的线进行翻转，然后再沿着横中轴进行翻转。</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意不要翻转两遍！！！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[i][n - <span class="number">1</span> - j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> daily diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-06-20</title>
      <link href="2020/06/22/2020-06-20/"/>
      <url>2020/06/22/2020-06-20/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1105. Filling Bookcase Shelves</title>
      <link href="2020/06/19/LeetCode-1105-Filling-Bookcase-Shelves/"/>
      <url>2020/06/19/LeetCode-1105-Filling-Bookcase-Shelves/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/filling-bookcase-shelves/">LeetCode 1105. Filling Bookcase Shelves</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一堆书和一个书架，每本书有宽和高，书架有宽度w，我们需要按照给定的顺序排列书籍，求出书架最少需要多高才能放下所有的书籍（建议去看leetcode原本题目，这里表述比较简略）。例如：</p><p><img src="/images/leetcode1105.png" alt="Shelves" title="Example 1"></p><pre><code>Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4Output: 6Explanation:The sum of the heights of the 3 shelves are 1 + 3 + 2 = 6.Notice that book number 2 does not have to be on the first shelf.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考资料：</p><ol><li><a href="https://www.youtube.com/watch?v=a7TLEVdqg0Q">花花酱的解析</a></li></ol><h3 id="dynamic-programming"><a href="#dynamic-programming" class="headerlink" title="dynamic programming"></a>dynamic programming</h3><p>这是一道十分典型的动态规划问题，没遇到很难想出来。</p><p>这里看似是一个二维的问题，实际上是一维。限制条件就是书架的宽度，这里就先不放图片了，在上面花花酱的视频里面有解释。对于任意第i本书，它有两种可能性，一种是从它自身开始重新加一层，另一种方式就是和前面的一些书一起构成一层。但是具体怎么样才算是最优解我们并不清楚，也没有判断的方法。</p><p>Greedy肯定是不可用的，因为即使我们找到了当前的最优解，也不确定它是否是全局最优解的一部分。因此我们需要遍历所有可能的书架上书的排列情况。</p><p>我们假设dp[i]是对于前i本书，最小的高度。</p><p>那么从第i本书向前搜索x本书，x本书的宽度不超过书架宽度(0&lt;= x &lt; i)，height(i, j)表示从第i本书到第j本书最高高度。那么有：</p><p>$$dp[i] = min(dp[i - x] + height(i - x, i)， dp[i]) (x本书的宽度要小于书架宽度)$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minHeightShelves</span><span class="params">(<span class="keyword">int</span>[][] books, <span class="keyword">int</span> shelf_width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = books.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i]表示前i个元素组成的书架的最小高度，对于所有的j在0到i-1之间的书，我们从后向前找x本书，使得x本书的宽度不会超过书架的width，dp[i] = min(dp[i], dp[j] + height) j在0到i-1之间。</span></span><br><span class="line"></span><br><span class="line">        Arrays.fill(dp, <span class="number">1000000</span>);</span><br><span class="line">        <span class="comment">// 初始化dp[0]和dp[1]</span></span><br><span class="line">        dp[<span class="number">1</span>] = books[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> width = <span class="number">0</span>, height = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                width += books[j - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                height = Math.max(height, books[j - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (width &lt;= shelf_width) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[j - <span class="number">1</span>] + height, dp[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-06-19</title>
      <link href="2020/06/19/2020-06-19/"/>
      <url>2020/06/19/2020-06-19/</url>
      
        <content type="html"><![CDATA[<h1 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h1><h2 id="LeetCode-1048-Longest-String-Chain"><a href="#LeetCode-1048-Longest-String-Chain" class="headerlink" title="LeetCode 1048. Longest String Chain"></a><a href="https://leetcode.com/problems/longest-string-chain/">LeetCode 1048. Longest String Chain</a></h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>用hashmap存储每个string的最长的chain length。记住先排序！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按照长度对words进行排序</span></span><br><span class="line">        Arrays.sort(words, (word1, word2) -&gt; word1.length() - word2.length());</span><br><span class="line">        <span class="comment">// 创建一个hashmap，记录当前每个word的最长的word chain是多少</span></span><br><span class="line">        Map&lt;String, Integer&gt; dp = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> longest = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            String temp = words[i];</span><br><span class="line">            <span class="keyword">int</span> chainLength = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.length(); j++) &#123;</span><br><span class="line">                StringBuilder sb= <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                String newStr = sb.append(temp.substring(<span class="number">0</span>, j)).append(temp.substring(j + <span class="number">1</span>, temp.length())).toString();</span><br><span class="line">                chainLength = Math.max(chainLength, dp.getOrDefault(newStr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp.put(words[i], chainLength);</span><br><span class="line">            longest = Math.max(longest, chainLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DFS-memorization（待完成）"><a href="#DFS-memorization（待完成）" class="headerlink" title="DFS + memorization（待完成）"></a>DFS + memorization（待完成）</h4><h2 id="LeetCode-268-Missing-Number"><a href="#LeetCode-268-Missing-Number" class="headerlink" title="LeetCode 268. Missing Number"></a><a href="https://leetcode.com/problems/missing-number/">LeetCode 268. Missing Number</a></h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>用一个boolean数组即可解决该问题。或者使用异或运算。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] check = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            check[num] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><p>简单举个例子就能看懂了：</p><p>详情见: <a href="https://leetcode.com/problems/missing-number/solution/">LeetCode Solution 3</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missing = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            missing ^= i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> daily diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 268. Missing Number</title>
      <link href="2020/06/19/LeetCode-268-Missing-Number/"/>
      <url>2020/06/19/LeetCode-268-Missing-Number/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 41. First Missing Positive</title>
      <link href="2020/06/19/LeetCode-41-First-Missing-Positive/"/>
      <url>2020/06/19/LeetCode-41-First-Missing-Positive/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/first-missing-positive/">LeetCode 41. First Missing Positive</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个未排序的整形数组，找出最小的缺失的正整数，要求只能使用常数级别的extra space。例如：</p><pre><code>Example 1:Input: [1,2,0]Output: 3Example 2:Input: [3,4,-1,1]Output: 2Example 3:Input: [7,8,9,11,12]Output: 1</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="https://leetcode.com/problems/missing-number/">LeetCode 268. Missing Number</a></li></ol><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>这道题是属于比较smart的那种题，比较考验数学思维，做过基本上就会，没做过很难想。属于hard里难度较低的那种。</p><p>首先我们对于一个长度为n的数组，它的第一个missing number最大只可能是n+1，边界情况是n个数是由(1…n)不重复组成。</p><p>因此，对于负数，0或者大于n的数字，我们都可以把它转化成一个固定的数，这里我们设置为n+1，这样我们就能保证数组中的数都是正整数了。</p><p>现在问题在于如何使用常数级别的extra space。我们知道一共是有n个数，数组中的数字经过转化以后都变为了[1, n + 1]之间，因此，如果某个数字i有出现过，我们将第i个数（index为i - 1）置为负数即可（i != n + 1），最后判断第一个出现的正数，那么该index + 1即为所求；如果没有找到正数，那么返回n + 1。</p><p>这里有一些小tips需要注意，例如不要对一个数字两次取反，以及计算index的时候需要取绝对值，因为有可能在处理前面的数字的时候把后面的数已经置为负数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接看解法的一道题。首先，我们假设n为nums的长度，而最终的答案最多只可能是n+1，也就是说前n个数恰好是1到n。因此我们要先排除负数和0和大于n的数，我们将其都设为n+1。修改以后，数组里每个数字的范围就是1到n+1,然后我们遍历数组，用一个negative的符号来表示当前数字已经出现过了并跳过数字n+1,修改下标的符号。然后遍历数组，如果找到第一个非负数，那么返回它。如果没有找到，返回n+1.</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将不合法的数都变成n+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span> || nums[i] &gt; n) &#123;</span><br><span class="line">                nums[i] = n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，目前数组中每个数都是在1到n+1之间，将以nums[i]的存在的数为下标的数字变为负数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 防止nums[i]在遍历到的时候已经是负号了</span></span><br><span class="line">            <span class="keyword">int</span> num = Math.abs(nums[i]);</span><br><span class="line">            <span class="comment">// 防止加两次负号</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n &amp;&amp; nums[num - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[num - <span class="number">1</span>] = -<span class="number">1</span> * nums[num - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，找到第一个非负数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到，直接返回n+1</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> hard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 37. Sudoku Solver</title>
      <link href="2020/06/19/LeetCode-37-Sudoku-Solver/"/>
      <url>2020/06/19/LeetCode-37-Sudoku-Solver/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/sudoku-solver/">LeetCode 37. Sudoku Solver</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个9 * 9的数独游戏表格，找出它的解（保证有解）。例如：</p><p><img src="/images/leetcode37.webp" alt="Soduku Problem" title="Soduku Problem"></p><p><img src="/images/leetcode37-2.png" alt="Soduku Solution" title="Soduku Solution"></p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="https://leetcode.com/problems/valid-sudoku/">LeetCode 36. Valid Sudoku</a></li></ol><p>参考资料：</p><ol><li><a href="https://labuladong.github.io/ebook/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/sudoku.html">labuladong的算法小抄-数独问题</a></li></ol><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>老数独题目了，回溯法可解，就是暴力穷举，回溯法的经典题目之一。我一开始的做法是使用了hashset，其实用hashmap也OK，因为hashset的底层实现就是hashmap，本质上是一样的。</p><p>这里我们还要注意创建collections数组的方法，要先创建引用，然后再for循环创建每一个collection实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Character&gt;[] rows = <span class="keyword">new</span> HashSet[<span class="number">9</span>];</span><br><span class="line">    Set&lt;Character&gt;[] cols = <span class="keyword">new</span> HashSet[<span class="number">9</span>];</span><br><span class="line">    Set&lt;Character&gt;[] boxes = <span class="keyword">new</span> HashSet[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            rows[i] = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            cols[i] = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            boxes[i] = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    rows[i].add(board[i][j]);</span><br><span class="line">                    cols[j].add(board[i][j]);</span><br><span class="line">                    boxes[(i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>].add(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtracking(board, <span class="number">0</span>, <span class="number">0</span>, rows, cols, boxes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, Set&lt;Character&gt;[] rows, Set&lt;Character&gt;[] cols, Set&lt;Character&gt;[] boxes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 到达最后一列，开始对下一行进行回溯</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> backtracking(board, i + <span class="number">1</span>, <span class="number">0</span>, rows, cols, boxes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成最后一行，结束，说明找到解了</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> box_id = (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> backtracking(board, i, j + <span class="number">1</span>, rows, cols, boxes);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">&#x27;1&#x27;</span>; c &lt;= <span class="string">&#x27;9&#x27;</span>; c++) &#123;</span><br><span class="line">                <span class="comment">// 检查当前这个值是否valid</span></span><br><span class="line">                <span class="keyword">if</span> (!rows[i].contains(c) &amp;&amp; !cols[j].contains(c) &amp;&amp; !boxes[box_id].contains(c)) &#123;</span><br><span class="line">                    board[i][j] = c;</span><br><span class="line">                    rows[i].add(c);</span><br><span class="line">                    cols[j].add(c);</span><br><span class="line">                    boxes[box_id].add(c);</span><br><span class="line">                    <span class="keyword">if</span> (!backtracking(board, i, j + <span class="number">1</span>, rows, cols, boxes)) &#123;</span><br><span class="line">                        <span class="comment">// 回溯</span></span><br><span class="line">                        rows[i].remove(c);</span><br><span class="line">                        cols[j].remove(c);</span><br><span class="line">                        boxes[box_id].remove(c);</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种写法是参考的上面参考资料，写法更为优雅，且没有用到hashset或者hashmap，写法上更加优雅，但是速度来说没有hashmap或者hashset快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        backtrack(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">9</span>, n = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">            <span class="comment">// 穷举到最后一列的话就换到下一行重新开始。</span></span><br><span class="line">            <span class="keyword">return</span> backtrack(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">            <span class="comment">// 找到一个可行解，触发 base case</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果有预设数字，不用我们穷举</span></span><br><span class="line">            <span class="keyword">return</span> backtrack(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">&#x27;1&#x27;</span>; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch++) &#123;</span><br><span class="line">            <span class="comment">// 如果遇到不合法的数字，就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!isValid(board, i, j, ch))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            board[i][j] = ch;</span><br><span class="line">            <span class="comment">// 如果找到一个可行解，立即结束</span></span><br><span class="line">            <span class="keyword">if</span> (backtrack(board, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 穷举完 1~9，依然没有找到可行解，此路不通</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">char</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 判断行是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[r][i] == n)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 判断列是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][c] == n)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 判断 3 x 3 方框是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[(r/<span class="number">3</span>)*<span class="number">3</span> + i/<span class="number">3</span>][(c/<span class="number">3</span>)*<span class="number">3</span> + i%<span class="number">3</span>] == n)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-06-18</title>
      <link href="2020/06/18/2020-06-18/"/>
      <url>2020/06/18/2020-06-18/</url>
      
        <content type="html"><![CDATA[<h1 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h1><h2 id="LeetCode-739-Daily-Temperatures"><a href="#LeetCode-739-Daily-Temperatures" class="headerlink" title="LeetCode 739. Daily Temperatures"></a><a href="https://leetcode.com/problems/daily-temperatures/">LeetCode 739. Daily Temperatures</a></h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">// 典型的单调栈题目</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[stack.peek()] &lt; T[i]) &#123;</span><br><span class="line">                res[stack.peek()] = i - stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-274-H-Index"><a href="#LeetCode-274-H-Index" class="headerlink" title="LeetCode 274. H-Index"></a><a href="https://leetcode.com/problems/h-index/">LeetCode 274. H-Index</a></h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>274和275我觉得是很垃圾的两道题，有点像脑筋急转弯。对于274题，其实就是找出一个数x，使得数组中大于等于x的数恰好为x个。</p><p>注意，这里找到的hindex不一定是数组里的数，例如:[4,0,6,1,5]的hindex就是3。</p><p>这里有个弯需要绕一下，就是while循环那里，我们的h要从小到大去遍历，而查找citation的数量需要从后向前找，因为这是一个相遇问题而不是追击问题。需要细品一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终的h的值一定是小于n的，看一下solution里的图就可以明白</span></span><br><span class="line">        <span class="keyword">int</span> n = citation.length, h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n &amp;&amp; citations[n - h - <span class="number">1</span>] &gt; h) &#123;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-275-H-Index-II"><a href="#LeetCode-275-H-Index-II" class="headerlink" title="LeetCode 275. H-Index II"></a><a href="https://leetcode.com/problems/h-index-ii/">LeetCode 275. H-Index II</a></h2><h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><p>和274基本一致，只是这里的array是有序的，用二分查找更方便。目标是找到一个target似的citations[i]<br>= n - i，如果没有这样的i，那么最终的left及其后面的数的数量就是h个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, n = citations.length;</span><br><span class="line">    <span class="keyword">int</span> pivot, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivot = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (citations[pivot] == n - pivot) <span class="keyword">return</span> n - pivot;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (citations[pivot] &lt; n - pivot) left = pivot + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> right = pivot - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-36-Valid-Sudoku"><a href="#LeetCode-36-Valid-Sudoku" class="headerlink" title="LeetCode 36. Valid Sudoku"></a><a href="https://leetcode.com/problems/valid-sudoku/">LeetCode 36. Valid Sudoku</a></h2><h3 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h3><p>就是通过多个hashmap或者hashset来对每一行、每一列以及每一个box进行查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这道题只要判断数独是否合法，而不一定有解！！！</span></span><br><span class="line">        <span class="comment">// 分情况讨论即可</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查每一行是否valid</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            Set&lt;Character&gt; dict = <span class="keyword">new</span> HashSet(); </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dict.contains(board[i][j])) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dict.add(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查每一列是否valid</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            Set&lt;Character&gt; dict = <span class="keyword">new</span> HashSet(); </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dict.contains(board[i][j])) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dict.add(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查每一个3x3小方框是否valid</span></span><br><span class="line">        Set&lt;Character&gt;[] dicts = <span class="keyword">new</span> HashSet[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            dicts[i] = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dicts[id].contains(board[i][j])) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dicts[id].add(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> daily diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 32. Longest Valid Parentheses</title>
      <link href="2020/06/18/LeetCode-32-Longest-Valid-Parentheses/"/>
      <url>2020/06/18/LeetCode-32-Longest-Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/longest-valid-parentheses/">LeetCode 32. Longest Valid Parentheses</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个仅有”(“和”)”组成的字符串，找出其中最长的valid的括号匹配字符串长度。例如：</p><pre><code>Example 1:Input: &quot;(()&quot;Output: 2Explanation: The longest valid parentheses substring is &quot;()&quot;Example 2:Input: &quot;)()())&quot;Output: 4Explanation: The longest valid parentheses substring is &quot;()()&quot;</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="https://leetcode.com/problems/valid-parentheses/">LeetCode 20. Valid Parentheses(无解析)</a></li></ol><p>一开始的想法也是动态规划，但是dp的思路出了点问题，直接看下面这个思路即可。</p><h3 id="dynamic-programming"><a href="#dynamic-programming" class="headerlink" title="dynamic programming"></a>dynamic programming</h3><ol><li>假设dp[i]表示以第i-1个元素为结尾，最长的valid的长度；这里我们要注意，这里的dp值是以当前为结尾，而不是在此之前的最长长度！！！</li><li>那么当s[i]为”(“时，那么dp[i] = 0;</li><li>当s[i]为”)”时，分为两种情况。第一种：如果s[i - 1]为’(‘，dp[i] = dp[i - 1] + 2;</li><li>第二种情况：如果s[i - 1]为’)’，那么逻辑复杂一点，倘若dp[i - dp[i - 1] - 1] == ‘(‘，那么dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]；倘若dp[i - dp[i - 1] - 1] == ‘)’，那么说明其无法凑成对，仍然是0。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化dp</span></span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; arr[<span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        longest = dp[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从index为2开始遍历，只有当前字符为&#x27;)&#x27;且和前面某个&#x27;(&#x27;匹配时，才会更新dp值，否则都为0！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; arr[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; arr[i - <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + ((i - dp[i - <span class="number">1</span>] - <span class="number">2</span>) &gt;= <span class="number">0</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = Math.max(dp[i], longest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>使用stack的方式十分巧妙，通过记录上一次不合法括号的最后的index来判断。每次遇到一个合法的’)’时，计算一下以当前的’)’结尾的子串的最长合法长度是多少。代码如下（直接抄的solution）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxans = Math.max(maxans, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> hard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图算法——最短路径算法</title>
      <link href="2020/06/18/%E5%9B%BE%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
      <url>2020/06/18/%E5%9B%BE%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><p>最短路径算法是图计算中一种极为常见的算法，而且相对来说比较复杂，并不是因为难，而是因为情况多变。例如：有无环，边是否有权重，有无负权边等等，每种组合也可对应不同的算法，这里做一次小小的总结。</p><h2 id="最短路径算法分类"><a href="#最短路径算法分类" class="headerlink" title="最短路径算法分类"></a>最短路径算法分类</h2><h3 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h3><h4 id="无向图的单源最短路径"><a href="#无向图的单源最短路径" class="headerlink" title="无向图的单源最短路径"></a>无向图的单源最短路径</h4><h4 id="有向图的单源最短路径"><a href="#有向图的单源最短路径" class="headerlink" title="有向图的单源最短路径"></a>有向图的单源最短路径</h4><p>单源最短路径指的就是给定一个有向带权图*G(V, E)*，给出其中的一个源点V0，求V0到其余各点的最短路径。</p><h3 id="全图最短路径"><a href="#全图最短路径" class="headerlink" title="全图最短路径"></a>全图最短路径</h3>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 总结 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 556. Next Greater Element III</title>
      <link href="2020/06/18/LeetCode-556-Next-Greater-Element-III/"/>
      <url>2020/06/18/LeetCode-556-Next-Greater-Element-III/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/next-greater-element-iii/">LeetCode 556. Next Greater Element III</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个32-bit的正整数，找出由它的每一位组成的下一个比它大一点的数字，如果当前已经是最大或者没有一个32位的int值可以表示，则返回-1。例如：</p><pre><code>Example 1:Input: 12Output: 21Example 2:Input: 21Output: -1</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/18/LeetCode-496-Next-Greater-Element-I/" title="LeetCode 496. Next Greater Element I">LeetCode 496. Next Greater Element I</a></li><li><a href="/2020/06/18/LeetCode-556-Next-Greater-Element-III/" title="LeetCode 556. Next Greater Element III">LeetCode 556. Next Greater Element III</a></li><li><a href="/2020/06/04/LeetCode-31-Next-Permutation/" title="LeetCode 31. Next Permutation">LeetCode 31. Next Permutation</a></li></ol><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>这道题其实和<a href="/2020/06/18/LeetCode-130-Surrounded-Regions/" title="LeetCode 130. Surrounded Regions">LeetCode 130. Surrounded Regions</a>的单调栈没有任何关系，反而是和<a href="/2020/06/04/LeetCode-31-Next-Permutation/" title="LeetCode 31. Next Permutation">LeetCode 31. Next Permutation</a>一模一样，目的就是找出下一个更大的数字，其难点在于注意integer的max值，如果变换后值超出int1的范围，则返回-1.</p><p>具体思路见：<a href="/2020/06/04/LeetCode-31-Next-Permutation/" title="LeetCode 31. Next Permutation">LeetCode 31. Next Permutation</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我觉得这里更多需要注意的是32位整形的这个约束条件，为了不溢出，我们需要将其转化为long类型</span></span><br><span class="line">        <span class="comment">// 和next permutation一样的做法，从后向前找第一个降序数字x，如果找不到，说明不行；例如12386，我们找到的就是8；</span></span><br><span class="line">        <span class="comment">// 然后我们从x(包括x)的右侧找到第一个比“3”大的数字，也就是6，交换它们；</span></span><br><span class="line">        <span class="comment">// 数字变成12683，然后将x及x的右侧降序排列</span></span><br><span class="line">        <span class="comment">// 比较其和intMax的大小，如果更大，则还是返回-1。</span></span><br><span class="line">        <span class="keyword">long</span> intMax = Integer.MAX_VALUE;</span><br><span class="line">        List&lt;Integer&gt; digitsList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> num = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算数字各个位，存起来转化成数组，方便计算；从低位到高位存。</span></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            digitsList.add(num % <span class="number">10</span>);</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = digitsList.size();</span><br><span class="line">        <span class="keyword">int</span>[] digits = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            digits[i] = digitsList.get(length - i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前找第一个降序的数字</span></span><br><span class="line">        <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] &gt; digits[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前找第一个比digits[pos - 1]大的数字，交换它们，这个数字一定存在，最坏情况不过是pos这个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= pos; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] &gt; digits[pos - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = digits[pos - <span class="number">1</span>];</span><br><span class="line">                digits[pos - <span class="number">1</span>] = digits[i];</span><br><span class="line">                digits[i] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新排列从pos到末尾的数字，但是我们知道它们都是降序的，首尾pointer交换</span></span><br><span class="line">        <span class="keyword">int</span> start = pos, end = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = digits[start];</span><br><span class="line">            digits[start] = digits[end];</span><br><span class="line">            digits[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将重新生成的数字用long看一下是否越界了</span></span><br><span class="line">        <span class="keyword">long</span> newNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> multiplier = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            newNum += multiplier * digits[i];</span><br><span class="line">            multiplier *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newNum &gt; intMax) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)newNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 496. Next Greater Element I</title>
      <link href="2020/06/18/LeetCode-496-Next-Greater-Element-I/"/>
      <url>2020/06/18/LeetCode-496-Next-Greater-Element-I/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/next-greater-element-i/">LeetCode 496. Next Greater Element I</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个<strong>无重复</strong>数组nums1和nums2，nums1是nums2的子集，找出nums1中所有元素在nums2中的下一个更大的元素，如果没有，则为-1。例如：</p><pre><code>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation:    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.    For number 1 in the first array, the next greater number for it in the second array is 3.    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/18/LeetCode-503-Next-Greater-Element-II/" title="LeetCode 503. Next Greater Element II">LeetCode 503. Next Greater Element II</a></li><li><a href="/2020/06/18/LeetCode-556-Next-Greater-Element-III/" title="LeetCode 556. Next Greater Element III">LeetCode 556. Next Greater Element III</a></li><li><a href="https://leetcode.com/problems/daily-temperatures/">LeetCode 739. Daily Temperatures(无解析)</a></li></ol><h3 id="monotonous-stack（单调栈）"><a href="#monotonous-stack（单调栈）" class="headerlink" title="monotonous stack（单调栈）"></a>monotonous stack（单调栈）</h3><p>这是单调栈，经典的数据结构之一，单调栈的目的就是为了查找<strong>下一个更大/小的元素</strong>，步骤如下：</p><ol><li>如果栈为空，或者栈顶元素大于当前元素时，push当前元素到栈顶；</li><li>如果栈不为空，且栈顶元素小于当前元素时，一直pop，直到栈为空或者栈顶元素大于当前元素。</li></ol><p><strong>注意：</strong>上面说的“下一个更大/更小元素”并不绝对，重要的是单调栈是什么样子的，找下一个更大更小元素只是其中一个应用，其他更多的应用还有很多！！！例如<a href="https://leetcode.com/problems/132-pattern/">LeetCode 456. 132 Pattern</a>!!!这点一定要注意！！！要深入理解数据结构，而不是单一问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 找到nums2里所有元素的next greater element，由于无重复元素，因此用hashmap来存储，然后对nums1进行循环get即可。</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        Map&lt;Integer, Integer&gt; dict = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; num &gt; stack.peek()) &#123;</span><br><span class="line">                dict.put(stack.pop(), num);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// stack里剩下的说明都是没有next greater element的数字</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            dict.put(stack.pop(), -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            nums1[i] = dict.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> monotonous stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 503. Next Greater Element II</title>
      <link href="2020/06/18/LeetCode-503-Next-Greater-Element-II/"/>
      <url>2020/06/18/LeetCode-503-Next-Greater-Element-II/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/next-greater-element-ii/">LeetCode 503. Next Greater Element II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个环形数组（首尾相连）nums，找出nums每一个元素在nums中的下一个更大的元素，如果没有，则为-1。例如：</p><pre><code>Example 1:Input: [1,2,1]Output: [2,-1,2]Explanation: The first 1&#39;s next greater number is 2; The number 2 can&#39;t find next greater number; The second 1&#39;s next greater number needs to search circularly, which is also 2.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/18/LeetCode-496-Next-Greater-Element-I/" title="LeetCode 496. Next Greater Element I">LeetCode 496. Next Greater Element I</a></li><li><a href="/2020/06/18/LeetCode-556-Next-Greater-Element-III/" title="LeetCode 556. Next Greater Element III">LeetCode 556. Next Greater Element III</a></li><li><a href="https://leetcode.com/problems/daily-temperatures/">LeetCode 739. Daily Temperatures(无解析)</a></li></ol><h3 id="monotonous-stack（单调栈）"><a href="#monotonous-stack（单调栈）" class="headerlink" title="monotonous stack（单调栈）"></a>monotonous stack（单调栈）</h3><a href="/2020/06/18/LeetCode-496-Next-Greater-Element-I/" title="LeetCode 496. Next Greater Element I">LeetCode 496. Next Greater Element I</a>的进阶版，这里其实算法和之前是一样的，只不过数组变成了环形，而且存在“重复”的数字，所以我们不能再使用hashmap来存储，而是**使用index**来存储，因此使用arraylist是最好的。<p>这里有几点需要注意：</p><ol><li>这里我们push进stack的东西是数组的index，而不是数字，注意和前一道进行区分；</li><li>在for循环后，stack里面剩下的，不是没有next greater element的元素，这里我们需要注意。这里我们举个例子:[5,4,3,2,1]，我们将其copy后变成[5,4,3,2,1,5,4,3,2,1]，最终stack里面剩下的是后面数组里没有next greater element的index，也就是我们后面的54321都是没用next greater element的，但是实际上4321是哟肚饿，因为在前面已经计算完了。这里需要特别注意一下！！！</li></ol><pre><code class="java">class Solution &#123;    public int[] nextGreaterElements(int[] nums) &#123;        // 和next greater element 1的区别在于这里是环形数组，之前是只能在它的后面到end之间，现在是可以绕一圈再回到自身位置，因此我们遍历到末尾后再从头遍历一次数组。        if (nums.length == 0) &#123;            return nums;        &#125;        Stack&lt;Integer&gt; stack = new Stack();        int n = nums.length;        int[] res = new int[n];        Arrays.fill(res, -1);        for (int i = 0; i &lt; 2 * n; i++) &#123;            int index = i % n;            while (!stack.isEmpty() &amp;&amp; nums[index] &gt; nums[stack.peek()]) &#123;                res[stack.pop()] = nums[index];            &#125;            stack.push(index);        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> monotonous stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 130. Surrounded Regions</title>
      <link href="2020/06/18/LeetCode-130-Surrounded-Regions/"/>
      <url>2020/06/18/LeetCode-130-Surrounded-Regions/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/surrounded-regions/">LeetCode 130. Surrounded Regions</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个由’O’和’X’组成的二维数组，将所有由‘X’包围的‘O’替换成‘X’。例如：</p><pre><code>Example:X X X XX O O XX X O XX O X XAfter running your function, the board should be:X X X XX X X XX X X XX O X X</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="https://leetcode.com/problems/number-of-islands/">LeetCode 200. Number of Islands(无解析)</a></li></ol><h3 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS || BFS"></a>DFS || BFS</h3><ol><li>先将和边界相连的所有‘O’都替换成另一个字母‘W’，这里DFS或者BFS都可以（这里以DFS为例）；</li><li>然后将board中剩余的‘O’都替换成’X‘；</li><li>将替换后的board中的’W‘再替换回去。</li></ol><p>这里需要注意的只有我们用了一个Pair的List来记录了初始和边界相连的’O‘的位置，第三部只需要一个个遍历换回去即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DFS，先将所有从边界出发的“O”替换为“W”，然后将board中所有的“O”替换成“X”，然后再替换回来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断输入为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历四周，将与边相连的“O”变为“W”</span></span><br><span class="line">        <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        List&lt;Pair&lt;Integer, Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                replace(board, i, <span class="number">0</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                replace(board, i, n - <span class="number">1</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                replace(board, <span class="number">0</span>, j, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                replace(board, m - <span class="number">1</span>, j, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历全局，找出所有的剩余的‘O’替换为‘X’</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复‘W’为‘O’</span></span><br><span class="line">        <span class="keyword">for</span> (Pair&lt;Integer, Integer&gt; pair : list) &#123;</span><br><span class="line">            board[pair.getKey()][pair.getValue()] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换与边界相连的O为W</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> replace, <span class="keyword">char</span> target, List&lt;Pair&lt;Integer, Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= board.length || col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == replace) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Pair&lt;Integer, Integer&gt;(row, col));</span><br><span class="line">            board[row][col] = target;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">                replace(board, row + direction[<span class="number">0</span>], col + direction[<span class="number">1</span>], replace, target, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 673. Number of Longest Increasing Subsequence</title>
      <link href="2020/06/11/LeetCode-673-Number-of-Longest-Increasing-Subsequence/"/>
      <url>2020/06/11/LeetCode-673-Number-of-Longest-Increasing-Subsequence/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/">LeetCode 673. Number of Longest Increasing Subsequence</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个未排序的整形数组，返回其最长递增系序列的数量。例如：</p><pre><code>Example 1:Input: [1,3,5,4,7]Output: 2Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].</code></pre><p><font color=12DBF1>Note:<br><br>数据规模不会超过2000且保证最终的解是32位整形数<br></font></p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/09/LeetCode-300-Longest-Increasing-Subsequence/" title="LeetCode 300. Longest Increasing Subsequence">LeetCode 300. Longest Increasing Subsequence</a></li></ol><p>和300题不同的是，这里我们需要返回的是数量，而不是长度，也就是说仅仅找出长度已经无法满足我们的需求，我们不仅需要记录长度，还需要记录数量。</p><p>另一种思路是使用segement tree，暂时还没学到那块，等学到了在回头看！！！</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们需要记录的有两个数值，到当前数字截止的最长的递增子序列长度和数量。因此，这是一个二维dp问题。对于300题中的第二种解法我们可以抛弃了，因为它只能找出长度，而无法找到数量。</p><p>因此，我们记录一个二维dp数组，每一维数组都有两个值，一个是长度，一个是数量。</p><p>当我们向前一个个查找的时候，记录最长的递增子序列的数量。</p><p>时间复杂度为O(n ^ 2)，因为每次都要去找前面所有的数字，很慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][0]表示到当前的最长长度，dp[i][1]表示当前最长长度的数量；初始化dp[0][0] = 0, dp[0][1] = 1。</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里需要注意！！！count需要初始化为1，因为假设说前面都没有比它小的，那么它就不会进入循环，它自己本身就是一个序列。</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>, longestLength = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 只有当前面数字比当前数字小的时候才会进行判断</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (longestLength &lt; dp[j][<span class="number">0</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                        count = dp[j][<span class="number">1</span>];</span><br><span class="line">                        longestLength = dp[j][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (longestLength == dp[j][<span class="number">0</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                        count += dp[j][<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = longestLength;</span><br><span class="line">            dp[i][<span class="number">1</span>] = count;</span><br><span class="line">            maxLength = Math.max(maxLength, longestLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据最长长度遍历dp数组，记录总的最长长度数量</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][<span class="number">0</span>] == maxLength) &#123;</span><br><span class="line">                res += dp[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 304. Range Sum Query 2D - Immutable</title>
      <link href="2020/06/11/LeetCode-304-Range-Sum-Query-2D-Immutable/"/>
      <url>2020/06/11/LeetCode-304-Range-Sum-Query-2D-Immutable/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/">LeetCode 304. Range Sum Query 2D - Immutable</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个二维矩阵，矩阵中每个元素都是整数。然后给出一个左上角和右下角（保证合法），计算给出的围起来的长方形的值。例如：</p><pre><code>Example:Given matrix = [[3, 0, 1, 4, 2],[5, 6, 3, 2, 1],[1, 2, 0, 1, 5],[4, 1, 0, 1, 7],[1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12</code></pre><p><font color=12DBF1>Note:<br><br>1. sumRegion函数会被call很多次；<br><br>2. 假设矩阵不变；<br></font></p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="https://leetcode.com/problems/range-sum-query-2d-mutable/">LeetCode 308. Range Sum Query 2D - Mutable（未做——线段树）</a></li><li><a href="https://leetcode.com/problems/range-sum-query-immutable/">LeetCode 303. Range Sum Query - Immutable</a></li></ol><p>这道题比起dp问题更像是一个数学问题。</p><h3 id="DP-Math方法"><a href="#DP-Math方法" class="headerlink" title="DP(Math方法)"></a>DP(Math方法)</h3><p>其实有点像求面积，用图来画一下会比较直白。我们目标就是绿色部分的面积（或者说是数字和），根据(row1, col1)和(row2, col2)我们可以清楚地知道四个部分的面积，相信一眼就能看出来这里怎么算了，我们用S(row, col)来表示从(0, 0)点到(row, col)的面积大小:</p><p>$$Target = S(row2, col2) - S(row1, col2) - S(row2, col1) + S(row1, col1)$$</p><p>时间复杂度：O(m * n)，初始化时候的复杂度，其他操作为O(1)。</p><p>另外，下面的写法欧典复杂了，判断了很多边界情况，其实可以做padding的，第二种写法是solution里做了padding的写法，更加简洁，可以参考一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += matrix[<span class="number">0</span>][i];</span><br><span class="line">            dp[<span class="number">0</span>][i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                sum += matrix[i][j];</span><br><span class="line">                dp[i][j] = sum + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, sum3 = <span class="number">0</span>, sum4 = dp[row2][col2];</span><br><span class="line">        <span class="comment">// sum1是左上角，sum2是上方，sum3是左侧。</span></span><br><span class="line">        <span class="keyword">if</span> (row1 == <span class="number">0</span> &amp;&amp; col1 == <span class="number">0</span>) &#123;</span><br><span class="line">            sum1 = <span class="number">0</span>;</span><br><span class="line">            sum2 = <span class="number">0</span>;</span><br><span class="line">            sum3 = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row1 == <span class="number">0</span> &amp;&amp; col1 != <span class="number">0</span>) &#123;</span><br><span class="line">            sum1 = <span class="number">0</span>;</span><br><span class="line">            sum2 = <span class="number">0</span>;</span><br><span class="line">            sum3 = dp[row2][col1 - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row1 != <span class="number">0</span> &amp;&amp; col1 == <span class="number">0</span> ) &#123;</span><br><span class="line">            sum1 = <span class="number">0</span>;</span><br><span class="line">            sum2 = dp[row1 - <span class="number">1</span>][col2];</span><br><span class="line">            sum3 = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum1 = dp[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>];</span><br><span class="line">            sum2 = dp[row1 - <span class="number">1</span>][col2];</span><br><span class="line">            sum3 = dp[row2][col1 - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum4 - sum2 - sum3 + sum1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="DP（做padding，简单写法）"><a href="#DP（做padding，简单写法）" class="headerlink" title="DP（做padding，简单写法）"></a>DP（做padding，简单写法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length + <span class="number">1</span>][matrix[<span class="number">0</span>].length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; matrix.length; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; matrix[<span class="number">0</span>].length; c++) &#123;</span><br><span class="line">                dp[r + <span class="number">1</span>][c + <span class="number">1</span>] = dp[r + <span class="number">1</span>][c] + dp[r][c + <span class="number">1</span>] + matrix[r][c] - dp[r][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - dp[row1][col2 + <span class="number">1</span>] - dp[row2 + <span class="number">1</span>][col1] + dp[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 279. Perfect Squares</title>
      <link href="2020/06/11/LeetCode-279-Perfect-Squares/"/>
      <url>2020/06/11/LeetCode-279-Perfect-Squares/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/perfect-squares/">LeetCode 279. Perfect Squares</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个正整数n，找出最少的能够组成n的完全平方数的个数。例如：</p><pre><code>Example 1:Input: n = 12Output: 3 Explanation: 12 = 4 + 4 + 4.Example 2:Input: n = 13Output: 2Explanation: 13 = 4 + 9.</code></pre><p><font color=12DBF1>Note:<br><br>最坏情况就是全都由1来组成，例如 3 = 1 + 1 + 1<br></font></p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考链接：<a href="https://leetcode.com/problems/perfect-squares/solution/">LeetCode 5种解法</a></p><p>其实讲道理，这道题的解法看得我头昏眼花，这里暂时只讲dp解法，关于greedy，BFS和math方法，后面有空再看，待完善。</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>首先，我们先计算sqrt(n)，向下取整为x，那么1到x都是我们的备选区间，然后我们从1到x进行遍历，找到最少的需要的数量（从后向前遍历不一定是最小值，例如：12 = 9 + 1 + 1 + 1，但是最少的是12 = 4 + 4 + 4）。我们用一个dp数组来记录当前的最小值即可，减少遍历次数。</p><p>时间复杂度为O(n * 根号n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        findNumSquares(n, dp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findNumSquares</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            dp[n] = n;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        <span class="comment">// dp值为0，说明从未找过；dp值大于0，即为解；最差情况就全是1喽</span></span><br><span class="line">        <span class="keyword">int</span> max = (<span class="keyword">int</span>)Math.floor(Math.sqrt((<span class="keyword">double</span>)n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">            res = Math.min(res, findNumSquares(n - i * i, dp) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[n] = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 221. Maximal Square</title>
      <link href="2020/06/10/LeetCode-221-Maximal-Square/"/>
      <url>2020/06/10/LeetCode-221-Maximal-Square/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/maximal-square/">LeetCode 221. Maximal Square</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个二维矩阵由0和1组成，找出其中最大的由1组成的最大正方形的面积。例如：</p><pre><code>Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/10/LeetCode-85-Maximal-Rectangle/" title="LeetCode 85. Maximal Rectangle">LeetCode 85. Maximal Rectangle</a></li></ol><p>这道题的变种，85题和这道题的思路完全不同，强烈建议重新看一下。而且85题的dp思路极其难懂，用的方法很不一样。</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>其实这道题也是用画图的方式来解决的。其实让我们找出最大的正方形面积，其实也就是找到最大的正方形边长。我们用一个dp值来记录，<strong>以当前位置为右下角的最大的正方形边长</strong>。假如说我们遍历到某个点(i, j)为1时（为0的时候不可能为正方形），那么以它为右下角的正方形的边长满足如下递推式：</p><p>$$dp[i][j] = min (dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1$$</p><p>记录全局的最大边长。遍历结束后计算出面积即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j]表示以[i][j]为右下角的正方形最大的边长，记得找一个全局最长的边即可。</span></span><br><span class="line">        <span class="comment">// 这里dp可以转化为一维！</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length, maxEdge = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxEdge = Math.max(dp[i][j], maxEdge);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxEdge * maxEdge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 85. Maximal Rectangle</title>
      <link href="2020/06/10/LeetCode-85-Maximal-Rectangle/"/>
      <url>2020/06/10/LeetCode-85-Maximal-Rectangle/</url>
      
        <content type="html"><![CDATA[<p>DFS：<br>LeetCode 51 N-Queens<br>LeetCode 37. Sudoku Solver<br>LeetCode 46. Permutations<br>LeetCode 47. Permutations II<br>LeetCode 39. Combination Sum<br>LeetCode 40. Combination Sum II</p><p>树:<br>LeetCode 145. Binary Tree Postorder Traversal (循环写法，复习一下直接抄即可)<br>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal<br>LeetCode 102. Binary Tree Level Order Traversal<br>LeetCode 236. Lowest Common Ancestor of a Binary Tree<br>LeetCode 124. Binary Tree Maximum Path Sum<br>LeetCode 297. Serialize and Deserialize Binary Tree</p><p>dp：<br>LeetCode 121. Best Time to Buy and Sell Stock<br>LeetCode 122. Best Time to Buy and Sell Stock II<br>LeetCode 123. Best Time to Buy and Sell Stock III<br>LeetCode 188. Best Time to Buy and Sell Stock IV<br>LeetCode 139. Word Break<br>LeetCode 174. Dungeon Game<br>LeetCode 198. House Robber<br>LeetCode 213. House Robber II<br>LeetCode 322. Coin Change<br>LeetCode 1269. Number of Ways to Stay in the Same Place After Some Steps</p><p>二分：<br>LeetCode 33. Search in Rotated Sorted Array<br>LeetCode 74. Search a 2D Matrix<br>LeetCode 240. Search a 2D Matrix II<br>LeetCode 155. Min Stack</p><p>单调栈<br>LeetCode 84. Largest Rectangle in Histogram<br>LeetCode 496. Next Greater Element I<br>LeetCode 503. Next Greater Element II</p><p>单调队列<br>LeetCode 239. Sliding Window Maximum</p><p>其他经典题目：<br>LeetCode 31. Next Permutation</p><p>.etc</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 378. Kth Smallest Element in a Sorted Matrix</title>
      <link href="2020/06/09/LeetCode-378-Kth-Smallest-Element-in-a-Sorted-Matrix/"/>
      <url>2020/06/09/LeetCode-378-Kth-Smallest-Element-in-a-Sorted-Matrix/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">LeetCode 378. Kth Smallest Element in a Sorted Matrix</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个m * n大小的矩阵，找出其第k大的数：</p><ol><li>每一行从左到右都是递增的整形数</li><li>每一列从上至下都是递增的整形数</li></ol><p>例如：</p><pre><code>matrix = [[ 1,  5,  9],[10, 11, 13],[12, 13, 15]],k = 8,return 13.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/05/27/LeetCode-74-Search-a-2D-Matrix/" title="LeetCode 74. Search a 2D Matrix">LeetCode 74. Search a 2D Matrix</a></li><li><a href="/2020/06/09/LeetCode-240-Search-a-2D-Matrix-II/" title="LeetCode 240. Search a 2D Matrix II">LeetCode 240. Search a 2D Matrix II</a></li></ol><p>这道题和<a href="/2020/06/09/LeetCode-240-Search-a-2D-Matrix-II/" title="LeetCode 240. Search a 2D Matrix II">LeetCode 240. Search a 2D Matrix II</a>特别像，基本上是一个模子里出来的，只不过这个更麻烦一些，它并不是去找某个数那样明确的目标，而是一个比较间接的值，需要做一些小改变。</p><p>按照我们正常的思路，start和end分别是左上角和右下角，但是我们的mid并不一定在matrix中存在，我们也不能用mid + 1或者mid - 1来更新start和end。因此，我们要做的有两件事：<br>（1）记录全局数组中小于等于mid值的个数。<br><br>（2）需要更新的值，也就是比mid小的最大值和比mid大的最小值。</p><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>我们还需要注意一点，数组中可能存在重复的值，就像例子里那样，13是我们的target，但是13有两个，也就是说我们找第7小的数和第8小的数都是13，如果我们找第7个，那么当我们遍历到13的时候，我们得到的个数永远都是8，8 &gt; 7，然后我们应该让end减小，但是小于等于13的最大的数还是13，因为我们这里有两个13，就无限循环了，start是13，end也是13.</p><p>所以，我们要注意的点就是二分搜索的循环条件，这里如果l == r，则说明当前值即为所求，不要再继续循环了。这一点一定要注意！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于横竖都有序，所以用二分搜索继续查找也是有一定规律的，我们可以从右上或者左下进行查找，可以记一个小tips。smallLargeNumber用于记录小于middle的最大值和大于middle的最小值。</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, l = matrix[<span class="number">0</span>][<span class="number">0</span>], r = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的循环结束条件，不是l &lt;=r</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span>[] smallLargeNumber = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> count = countLessEqual(matrix, m, smallLargeNumber);</span><br><span class="line">            <span class="keyword">if</span> (count &lt; k) &#123;</span><br><span class="line">                l = smallLargeNumber[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; k) &#123;</span><br><span class="line">                r = smallLargeNumber[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> smallLargeNumber[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countLessEqual</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> middle, <span class="keyword">int</span>[] smallLargeNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        smallLargeNumber[<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        smallLargeNumber[<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; n &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] &gt; middle) &#123;</span><br><span class="line">                smallLargeNumber[<span class="number">1</span>] = Math.min(smallLargeNumber[<span class="number">1</span>], matrix[row][col]);</span><br><span class="line">                col--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                smallLargeNumber[<span class="number">0</span>] = Math.max(smallLargeNumber[<span class="number">0</span>], matrix[row][col]);</span><br><span class="line">                count += col + <span class="number">1</span>;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 875. Koko Eating Bananas</title>
      <link href="2020/06/09/LeetCode-875-Koko-Eating-Bananas/"/>
      <url>2020/06/09/LeetCode-875-Koko-Eating-Bananas/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/koko-eating-bananas/">LeetCode 875. Koko Eating Bananas</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><pre><code>示例 1：输入: piles = [3,6,7,11], H = 8输出: 4示例 2：输入: piles = [30,11,23,4,20], H = 5输出: 30示例 3：输入: piles = [30,11,23,4,20], H = 6输出: 23</code></pre><p><font color=12DBF1>Note:<br><br>1 &lt;= piles.length &lt;= 10^4<br><br>piles.length &lt;= H &lt;= 10^9<br><br>1 &lt;= piles[i] &lt;= 10^9<br></font></p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/">LeetCode 1011. Capacity To Ship Packages Within D Days(无解析)</a></li></ol><p>这道题和1011特别像，但是又有所不同，看完解析后建议再去做一下1011这道题目。</p><p>这道题目的核心点在于找到一个合适的值去满足条件，而不是直接通过数值对比。也就是说我们表面上是对每小时吃多少香蕉速度K做二分搜索，但是实际作比较的却是时间，注意其中的转换关系。</p><p>而且，要注意能否进行切割！什么意思呢？拿示例3为例，如果K = 23，第一个小时可以不都吃完，只吃23个，剩下的7个下个小时再吃。对于1011题就完全不同，1011题里每个package不能进行切割。这里区别很大，要注意。</p><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>那么我们二分搜索的起始和结束分别是多少呢？start很明显，一个小时最少吃1根，因此start = 1；我们需要注意题里说的一点，如果当前小时的香蕉吃完了，那么就不再继续吃了，所以end的最大值就是piles[i]的最大值，也就是10 ^ 9。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> time = getHours(piles, m);</span><br><span class="line">            <span class="keyword">if</span> (time &lt;= H) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHours</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hours = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">            hours += (pile - <span class="number">1</span>) / speed + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hours;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 719. Find K-th Smallest Pair Distance</title>
      <link href="2020/06/09/LeetCode-719-Find-K-th-Smallest-Pair-Distance/"/>
      <url>2020/06/09/LeetCode-719-Find-K-th-Smallest-Pair-Distance/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/">LeetCode 719. Find K-th Smallest Pair Distance</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个未排序的整形数组，返回其最长递增子序列的长度。</p><pre><code>Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </code></pre><p><font color=12DBF1>Note:<br><br>只需要长度，而不是具体的串<br><br>time complexity要在O(n ^ 2)以下<br></font></p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/">673. Number of Longest Increasing Subsequence</a></li></ol><p>首先要注意我们只需要返回长度即可，这里不需要考虑找出最长的那个子串，只要找到该串的长度即可。</p><h3 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h3><p>我们先来看看最暴力的思路，我们对每个节点记录一个dp值，该值表示从0到当前位置的数字中，以当前数字为结尾的最长递增子序列的长度。每次新到达一个数字后，找到其前面的所有数字中，比它小的所有数字中dp值最大的数字（不能等于，等于就不叫递增了），找出该节点的dp值，加一，即为当前节点的dp值。</p><p>$$dp[i] = max(dp[i], dp[j] + 1) (for j in 0 to n - 1 and nums[j] &lt; nums[i])$$</p><p>时间复杂度为O(n ^ 2)，因为每次都要去找前面所有的数字，很慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxDP = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i] &amp;&amp; dp[j] &gt; maxDP) &#123;</span><br><span class="line">                    maxDP = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = maxDP + <span class="number">1</span>;</span><br><span class="line">            ret = Math.max(dp[i], ret)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> binary search </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 240. Search a 2D Matrix II</title>
      <link href="2020/06/09/LeetCode-240-Search-a-2D-Matrix-II/"/>
      <url>2020/06/09/LeetCode-240-Search-a-2D-Matrix-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">LeetCode 240. Search a 2D Matrix II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个m * n大小的矩阵，以及一个target，返回该矩阵中是否存在该数字。该矩阵有如下两条性质：</p><ol><li>每一行从左到右都是递增的整形数</li><li>每一列从上至下都是递增的整形数</li></ol><p>例如：</p><pre><code>Consider the following matrix:[[1,   4,  7, 11, 15],[2,   5,  8, 12, 19],[3,   6,  9, 16, 22],[10, 13, 14, 17, 24],[18, 21, 23, 26, 30]]Given target = 5, return true.Given target = 20, return false.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/05/27/LeetCode-74-Search-a-2D-Matrix/" title="LeetCode 74. Search a 2D Matrix">LeetCode 74. Search a 2D Matrix</a></li><li><a href="/2020/06/09/LeetCode-378-Kth-Smallest-Element-in-a-Sorted-Matrix/" title="LeetCode 378. Kth Smallest Element in a Sorted Matrix">LeetCode 378. Kth Smallest Element in a Sorted Matrix</a></li></ol><p>这是一类很特殊的二分查找的题目，建议背下来，它并不是全局有序，而是拥有一些有序的特性，总结为下面两点：</p><ol><li>矩阵的左上角的值全局最小；右下角的值全局最大；</li><li>对于每个L型的路径，其都是有序的，例如第一列和最后一行构成的L型或者第一行和最后一列构成的L型。</li></ol><p>那么利用这些性质，我们应该如何去做呢？根据二分查找，我们将start设置为matrix[0][0]，end设为matrix[m - 1][n - 1]（m、n为行数和列数）。然后<strong>我们遍历的起点要从右上角或者左下角开始，每次舍弃一行或者一列</strong>。</p><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>注意一下这里的起点和终点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个的规律在于，第一行与最后一列连在一起是有序的，从右上角出发，如果这个数比target大，那么它就不可能在第一行，如果这个数比target小，那么它就不可能在最后一列。</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="number">0</span>) &#123;</span><br><span class="line">            n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span> || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[m - <span class="number">1</span>][n - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; matrix[i][j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[i][j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 887. Super Egg Drop</title>
      <link href="2020/06/09/LeetCode-887-Super-Egg-Drop/"/>
      <url>2020/06/09/LeetCode-887-Super-Egg-Drop/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 300. Longest Increasing Subsequence</title>
      <link href="2020/06/09/LeetCode-300-Longest-Increasing-Subsequence/"/>
      <url>2020/06/09/LeetCode-300-Longest-Increasing-Subsequence/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/">LeetCode 300. Longest Increasing Subsequence</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个未排序的整形数组，返回其最长递增子序列的长度。</p><pre><code>Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </code></pre><p><font color=12DBF1>Note:<br><br>只需要长度，而不是具体的串<br><br>time complexity要在O(n ^ 2)以下<br></font></p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/">673. Number of Longest Increasing Subsequence</a></li></ol><p>首先要注意我们只需要返回长度即可，这里不需要考虑找出最长的那个子串，只要找到该串的长度即可。</p><h3 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h3><p>我们先来看看最暴力的思路，我们对每个节点记录一个dp值，该值表示从0到当前位置的数字中，以当前数字为结尾的最长递增子序列的长度。每次新到达一个数字后，找到其前面的所有数字中，比它小的所有数字中dp值最大的数字（不能等于，等于就不叫递增了），找出该节点的dp值，加一，即为当前节点的dp值。</p><p>$$dp[i] = max(dp[i], dp[j] + 1) (for j in 0 to n - 1 and nums[j] &lt; nums[i])$$</p><p>时间复杂度为O(n ^ 2)，因为每次都要去找前面所有的数字，很慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxDP = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i] &amp;&amp; dp[j] &gt; maxDP) &#123;</span><br><span class="line">                    maxDP = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = maxDP + <span class="number">1</span>;</span><br><span class="line">            ret = Math.max(dp[i], ret)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找（直接背的最优解）"><a href="#二分查找（直接背的最优解）" class="headerlink" title="二分查找（直接背的最优解）"></a>二分查找（直接背的最优解）</h3><p>这道题二分查找的思路特别难想，建议直接背下来。思路如下：</p><ol><li>我们维护一个数组，初始化为长度为nums.length，首个元素为nums[0]，记录size = 1；</li><li>然后向后遍历每一个数字，<strong>二分法</strong>找到在当前数组中它应该在的位置pos（如果比当前末尾的数要大，那么就是在末尾后面一位；如果比第一个数要小，那么位置就是0）；</li><li>替换掉pos位置的数字。判断：如果pos == size，那么size++；</li><li>直至循环结束，最终的size就是我们的大小。</li></ol><p><font color = red>Attention：</font>这里只有size是我们想要的，而我们维护的那个数组并不一定是！！！</p><p>那么为什么是这样呢？size是我们想要的我们这点很清楚，因为对于任何一个数字而言，它只有两种可能性：（1）替换掉当前数组中某个数字（2）将数字加到末尾的后一位，size++。</p><p>如果替换掉当前数组中的任何一个，其实并不会改变当前size的大小。如果在末尾添加一个比较大的数，size也的确是增加了，不会存在任何影响，那么问题就在于我们为什么要替换掉数字呢？其实是为了避免下面这种情况，我们举一个极端的例子。</p><p>nums = [20, 100, 2, 3, 4, 5, 10, 80]，很明显，最终答案应该是6，如果我们不进行替换，那么我们就会发现从2以后好几个数字完全插不进去整个数组，因为他们都太小了，着很明显不是我们想要的，所以只有替换了，才能保证我们对于后面的查找判断不受影响。</p><p>那么为什么我们最后得到的不一定是我们最长的子序列呢？那是因为我们不一定能够替换完全。什么意思呢？我们再举个例子：nums = [20, 100, 2]和nums = [20, 100, 2, 3]，是不是好像明白了些什么？</p><p>其实，我们的目的是保证我们当前维护的这个最长递增序列的每个数的值尽可能保持小，如果后面有更小的序列我们就替换掉它，但是有可能在替换的过程中值替换了一半，所以并不保证最终得到的就是一个合法的最长递增子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 找到num的位置，二分法找到比num大的最小的数。而且这里注意闭区间r和size的关系。</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (arr[m] &gt;= num) &#123;</span><br><span class="line">                    r = m - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = m + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[l] = num;</span><br><span class="line">            <span class="keyword">if</span> (l == size) &#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 416. Partition Equal Subset Sum</title>
      <link href="2020/06/08/LeetCode-416-Partition-Equal-Subset-Sum/"/>
      <url>2020/06/08/LeetCode-416-Partition-Equal-Subset-Sum/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/partition-equal-subset-sum/">LeetCode 416. Partition Equal Subset Sum</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个非空的正整数数组，判断该数组是否能一分为二，且两个子集的数值和相等。例如：</p><pre><code>Input: [1, 5, 11, 5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11].</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/">LeetCode 698. Partition to K Equal Sum Subsets（待做）</a></li></ol><p>经典的<strong>子集背包问题</strong>（后面抽空会写一篇背包问题总结），完全背包问题是<a href="/2020/06/07/LeetCode-518-Coin-Change-2/" title="LeetCode 518. Coin Change 2">LeetCode 518. Coin Change 2</a>。</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>我们首先要判断数组和是否是偶数，如果是，则OK，我们可以继续往下找；如果是基数，则pass。</p><p>然后我们算出的target = sum / 2。也就是说我们需要从数组中找出一个子集，使得其和为target。</p><p>我们写dp方程的时候先来判断一下我们有多少个变量，一个是数字个数，另一个是target大小，因此我们推测这是一个二维dp。dp[i][j]为前i个数，和为j的可能性，true或者false。</p><p>那么我们可以得出如下递推式：</p><p>$$dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]$$</p><p>而且，我们可以知道的是每一次计算dp值的时候，只依赖于上一次的结果，因此我们可以将空间复杂度降到一维。</p><font color=12DBF1>时间复杂度：O（n ^ 2）。因为target为 n / 2，需要遍历从0到target。<p>空间复杂度：O(n）。n为nums长度。<br></font></p><p><font color=red>Attention:如果是使用一维数组进行dp的话，target的遍历要从后向前，因为它会依赖上一次计算前面的dp值，如果从前向后遍历，则会覆盖掉。</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果和为奇数，pass</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 这里的dp[j]就是上一次的i-1的dp[j]</span></span><br><span class="line">                    dp[j] = dp[j] || dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 213. House Robber II</title>
      <link href="2020/06/07/LeetCode-213-House-Robber-II/"/>
      <url>2020/06/07/LeetCode-213-House-Robber-II/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/house-robber-ii/">LeetCode 213. House Robber II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>一个专业的抢到想要洗劫一个街区的商户，每个商户有不同数额的金钱，该街区是环形排列的（第一户和最后一户相连），当抢劫连续两个商户时，就会触发报警。问在不触发报警的情况下，如何抢劫能使获得的钱数最多，找出那个最大金额。例如：</p><pre><code>Example 1:Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.Example 2:Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关题目：</p><ol><li><a href="https://leetcode.com/problems/house-robber/">LeetCode 198. House Robber</a></li><li><a href="https://leetcode.com/problems/house-robber-iii/">LeetCode 337. House Robber III(待完成)</a></li><li>paint house系列（例如：<a href="/2020/06/07/LeetCode-1473-Paint-House-III/" title="LeetCode 1473. Paint House III（待完成）">LeetCode 1473. Paint House III（待完成）</a>）</li></ol><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>和House Robber 1（解析见动态规划一的例题）不同的是，这次首尾是相连的。也就是说如果按照1中的做法，找出来的最优解中包含了第一户和最后一户，那么这个就是一种不合法的最大值。</p><p>所以，我们的做法是如果选择了第一户，不要选择最后一户不就好了？反之亦然，所以说我们计算两个最大值，一个是从第1户到第n - 1户，另一个是从第2户到第n户，取二者的最大值即可。</p><p>我们假设F(i, j)计算的是从第i户到第j户的能够抢的最大值，那么有。</p><p>$$F(1, n) = max(F(1, n - 1), F(2, n))$$</p><p>至于F的求法，和之前一样：</p><p>$$ F(n) = Math.max(F(n - 1), F(n - 2) + nums[n]) (F(1) = nums[1], F(2) = Math.max(nums[1], nums[2])) $$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(robFromTo(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>), robFromTo(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">robFromTo</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[start], nums[end]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = nums[start], cur = Math.max(nums[start], nums[]start + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++)</span><br><span class="line">            <span class="keyword">int</span> temp = cur;</span><br><span class="line">            cur = Math.max(pre + nums[i], cur);</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 399. Evaluate Division</title>
      <link href="2020/06/07/LeetCode-399-Evaluate-Division/"/>
      <url>2020/06/07/LeetCode-399-Evaluate-Division/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/evaluate-division/">LeetCode 399. Evaluate Division</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一系列等式，例如”A / B = k”，A和B都是字符串形式的字母，k是一个double数字。然后给出一些要求计算的等式，如果能根据已知的等式求出来，则计算，不能则返回-1.0。例如：</p><pre><code>Example:Given a / b = 2.0, b / c = 3.0.queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .return [6.0, 0.5, -1.0, 1.0, -1.0 ].</code></pre><p>上面的例子给出的输入是如下所示：</p><pre><code>equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],values = [2.0, 3.0],queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ]. </code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考视频：<a href="https://www.youtube.com/watch?v=UwpvInpgFmo">花花酱LeetCode</a></p><p>经典老题目，可以用DFS也可以用union-find。</p><h3 id="Graph-DFS"><a href="#Graph-DFS" class="headerlink" title="Graph + DFS"></a>Graph + DFS</h3><p>我们想一下，如果说我们将给出的所有等式当做一个图，对于每个query，我们对于这两个数的商的计算其实就是找一下这两个数之间是否存在一条路径，如果找到一条路径，则说明二者相除有结果；如果没有，则为-1。</p><p>时间复杂度：O(e + q * e)，q是query的数量，e是equation数量。首次生成graph的时候是O(e)的复杂度，q * e是所有query的复杂度，因此每次都要重新做DFS。</p><p>空间复杂度：O(e)，就是存储整张图的graph大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="keyword">new</span> HashMap();</span><br><span class="line">        buildGraph(equations, values, graph);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">            res[i] = getResult(queries.get(i).get(<span class="number">0</span>), queries.get(i).get(<span class="number">1</span>), <span class="keyword">new</span> HashSet&lt;String&gt;(), graph);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1是除数，s2是被除数，找s1/s2之间的一条路径，并将所有double值相乘</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(String s1, String s2, Set&lt;String&gt; visited, Map&lt;String, Map&lt;String, Double&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(s1) || !graph.containsKey(s2) || visited.contains(s1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.0d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1.equals(s2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始dfs</span></span><br><span class="line">        visited.add(s1);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; nei: graph.get(s1).entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nei.getKey().equals(s2)) &#123;</span><br><span class="line">                <span class="keyword">return</span> nei.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> temp = getResult(nei.getKey(), s2, visited, graph);</span><br><span class="line">            <span class="keyword">if</span> (temp != -<span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp * nei.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1.0d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, Map&lt;String, Map&lt;String, Double&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">            String s1 = equations.get(i).get(<span class="number">0</span>), s2 = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!graph.containsKey(s1)) &#123;</span><br><span class="line">                graph.put(s1, <span class="keyword">new</span> HashMap&lt;String, Double&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!graph.containsKey(s2)) &#123;</span><br><span class="line">                graph.put(s2, <span class="keyword">new</span> HashMap&lt;String, Double&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// value为0怎么办？</span></span><br><span class="line">            graph.get(s1).put(s2, values[i]);</span><br><span class="line">            graph.get(s2).put(s1, <span class="number">1</span> / values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Union-Find-待完成"><a href="#Union-Find-待完成" class="headerlink" title="Union-Find(待完成)"></a>Union-Find(待完成)</h3><p>上面的时间复杂度其实可以再往下降一些的，因为每次都用DFS其实某种程度上很累赘。如果我们使用Union-Find，每个字母和根节点parent相连，每次计算只需要判断二者是否在同一个森林里，如果再，则只需要计算一下每个节点与根节点相除的值，然后二者相除即可；不在同一个森林则是-1.0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
            <tag> union find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Union-Find总结</title>
      <link href="2020/06/07/Union-Find%E6%80%BB%E7%BB%93/"/>
      <url>2020/06/07/Union-Find%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Union-Find是什么"><a href="#Union-Find是什么" class="headerlink" title="Union-Find是什么"></a>Union-Find是什么</h1><p>详情参考：</p><ol><li><a href="https://labuladong.github.io/ebook/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html">labuladong的算法小抄——Union-Find算法详解</a></li><li><a href="https://labuladong.github.io/ebook/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8.html">labuladong的算法小抄——Union-Find算法应用</a></li><li><a href="https://www.youtube.com/watch?v=VJnUwsE4fWA&list=PLLuMmzMTgVK5Hy1qcWYZcd7wVQQ1v0AjX&index=20">花花酱的Union-Find视频</a></li></ol><p>Union-Find其实是一种解决图的连通性问题的算法。或者说解决某张图里连通分量的问题。比如说最简单的<a href="https://leetcode.com/problems/number-of-islands/">Number of Islands</a>，就是查找图里有多少个连通分量。</p><p>其实并查集的问题并不多，而且绝大多数并查集用DFS也都能够解决，union-find主要是一种思想，某些情况下会有不错的效果。</p><h1 id="Union-Find基础思路"><a href="#Union-Find基础思路" class="headerlink" title="Union-Find基础思路"></a>Union-Find基础思路</h1><h2 id="思想推导"><a href="#思想推导" class="headerlink" title="思想推导"></a>思想推导</h2><h3 id="基本操作Union与Find"><a href="#基本操作Union与Find" class="headerlink" title="基本操作Union与Find"></a>基本操作Union与Find</h3><p>这里推导只是简单的文字描述，作图的话时间不太充沛，以后有机会再补，觉得看不懂可以参考第一节里的参考资料，里面有很详细的分析。</p><p>首先，我们假设有n个独立的节点，我们定义每个节点i存在它的parent[i]，初始化为自己本身。</p><p>然后我们定义两种操作，Union和Find。</p><ol><li><strong>Union</strong>的过程就是将两个节点连接起来的过程，如果我们Union(a, b)，那么我们就将a的parent节点设置为b。</li><li><strong>Find</strong>的过程就是找到某节点的root节点，root节点就是一级一级向上找，直到找到某个节点的parent节点是本身，该节点就是root节点。</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="Path-Regression（Find优化）"><a href="#Path-Regression（Find优化）" class="headerlink" title="Path Regression（Find优化）"></a>Path Regression（Find优化）</h4><p>在find的时候，每次找到root节点时，可以将路径上所有节点的parent全部都指向root节点，这样的话可以保证树的高度不会很高，每次查询都可降低后续查询的复杂度。</p><h4 id="Merge-Optimization（Union优化）"><a href="#Merge-Optimization（Union优化）" class="headerlink" title="Merge Optimization（Union优化）"></a>Merge Optimization（Union优化）</h4><p>在Union的时候，我们希望把比较小的树连接到比较大的树上，这样整棵树的高度不会更高。因此我们需要一个size，来记录每棵树的大小。</p><h2 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent; <span class="comment">// 每个连通分量的父节点</span></span><br><span class="line">    <span class="keyword">int</span>[] size; <span class="comment">// 每个连通分量的大小</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// 当前有多少个连通分量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并的时候把size小的merge到高的上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = findRoot(a);</span><br><span class="line">        <span class="keyword">int</span> rootB = findRoot(b);</span><br><span class="line">        <span class="keyword">if</span> (rootA == rootB) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size[a] &gt;= size[b]) &#123;</span><br><span class="line">            parent[rootB] = rootA;</span><br><span class="line">            size[a] += size[b];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootA] = rootB;</span><br><span class="line">            size[b] += size[a];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到根节点这种写法是将树的高度压缩为3以内</span></span><br><span class="line">    <span class="comment">// private int findRoot(int x) &#123;</span></span><br><span class="line">    <span class="comment">//     while (x != parent[x]) &#123;</span></span><br><span class="line">    <span class="comment">//         parent[x] = parent[parent[x]];</span></span><br><span class="line">    <span class="comment">//         x = parent[x];</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return x;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//这种写法是把树的高度压缩成2，一个根带多个孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">            parent[x] = findRoot(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展：有向图的Union-Find"><a href="#拓展：有向图的Union-Find" class="headerlink" title="拓展：有向图的Union-Find"></a>拓展：有向图的Union-Find</h2><p>经典题目就是：<a href="https://leetcode.com/problems/redundant-connection-ii/">LeetCode 685. Redundant Connection II</a></p><h1 id="Union-Find应用题目"><a href="#Union-Find应用题目" class="headerlink" title="Union-Find应用题目"></a>Union-Find应用题目</h1><ol><li><a href="https://leetcode.com/problems/friend-circles/">LeetCode 547. Friend Circles</a></li><li><a href="https://leetcode.com/problems/evaluate-division/">LeetCode 399. Evaluate Division</a></li><li><a href="https://leetcode.com/problems/redundant-connection/">LeetCode 684. Redundant Connection</a></li><li><a href="https://leetcode.com/problems/redundant-connection-ii/">LeetCode 685. Redundant Connection II</a></li><li><a href="https://leetcode.com/problems/surrounded-regions/">LeetCode 130. Surrounded Regions</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 总结 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> union-find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 518. Coin Change 2</title>
      <link href="2020/06/07/LeetCode-518-Coin-Change-2/"/>
      <url>2020/06/07/LeetCode-518-Coin-Change-2/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/coin-change-2/">LeetCode 518. Coin Change 2</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一组不重复的coins，以及目标金额amount，找出所有能够组成目标金额的硬币组合方式的数量。例如：</p><pre><code>Example 1:Input: amount = 5, coins = [1, 2, 5]Output: 4Explanation: there are four ways to make up the amount:5=55=2+2+15=2+1+1+15=1+1+1+1+1</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>动态规划中最经典的背包问题之完全背包问题，可以参考着这篇labuladong大佬的blog来看：<a href="https://labuladong.github.io/ebook/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E8%83%8C%E5%8C%85%E9%9B%B6%E9%92%B1.html">传送门</a></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>经典问题之一的完全背包问题，指的是在不限制每种物品的情况下，一共有多少种可能的组合，使得背包装满。</p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>那么为什么会想到回溯呢？没有为什么，因为回溯能做出来这种需要遍历所有可能的问题。就这么简单。</p><p>对于一个数组A和某个target值，我们希望找出target所有的组合可能，假设F(int[] A, int start, int target)为从数组A中以start为起点找出target的所有可能组合，思路如下。</p><ol><li>对A从小到大进行排序，取A[0]作为第一个数，那么我们当前的目标是F(A, 0, target - A[0])；将其结果和A[0]放在一起作为第一种解。</li><li>然后取A[1]作为第一个数，然后我们目标是F(A, 1, target - A[1])。不从0开始是因为如果取了0，就会和第一步中的某种solution重复，故不取。</li><li>终止条件为target == 0，最终结果添加一条；target &lt; 0，回溯上去继续搞。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> knapsack problem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1473. Paint House III</title>
      <link href="2020/06/07/LeetCode-1473-Paint-House-III/"/>
      <url>2020/06/07/LeetCode-1473-Paint-House-III/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1471. The k Strongest Values in an Array</title>
      <link href="2020/06/07/LeetCode-1471-The-k-Strongest-Values-in-an-Array/"/>
      <url>2020/06/07/LeetCode-1471-The-k-Strongest-Values-in-an-Array/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 322. Coin Change</title>
      <link href="2020/06/07/LeetCode-322-Coin-Change/"/>
      <url>2020/06/07/LeetCode-322-Coin-Change/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/coin-change/">LeetCode 322. Coin Change</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一些面值的硬币coins，和目标金额mount，找出最少需要多少枚硬币能够组成amount，如果无法组成，则返回-1。例如：</p><pre><code>Example 1：Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1Example 2:Input: coins = [2], amount = 3Output: -1</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/05/24/LeetCode-39-Combination-Sum/" title="LeetCode 39. Combination Sum">LeetCode 39. Combination Sum</a></li><li><a href="/2020/05/24/LeetCode-40-Combination-Sum-II/" title="LeetCode 40. Combination Sum II">LeetCode 40. Combination Sum II</a></li><li><a href="/2020/05/24/LeetCode-216-Combination-Sum-III/" title="LeetCode 216. Combination Sum III">LeetCode 216. Combination Sum III</a></li></ol><p>经典老题目，我们需要留意的是它和combination sum的区别，combination sum是找具体的组合，而coin change只要找最小的合法组合。因此，这道题我们考虑用dp，而不是回溯法。</p><p>那么如何找到最优子问题呢？对于例子中的amount为11，它有几种组合方式：（1）10 + 1 （2）9 + 2 （3）6 + 5，找出这三者中最小的即可。其base case是当amount为0的时候，组合方式有且只有一种。递推式如下：</p><p>$$dp[i] = Math.min(dp[i - coin] + 1, dp[i]) (for coin in coins)$$</p><h3 id="动态规划（top-down）"><a href="#动态规划（top-down）" class="headerlink" title="动态规划（top-down）"></a>动态规划（top-down）</h3><p>初始化的值没必要设置成Integer.MAX_VALUE，最大设置为amount+1即可，因为最多也就是amount个1元硬币。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意和combination sum的区别，combination sum是要找所有的解决方案，所以采用回溯，这里只要找最少的那个就好了。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getMinCoins(coins, amount, dp, amount + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinCoins</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span>[] dp, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[amount] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[amount];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里不用min，直接用dp[amount]直接操作也可以的！！！</span></span><br><span class="line">        <span class="comment">// dp[amount] = max + 1;</span></span><br><span class="line">        <span class="comment">// for (int coin : coins) &#123;</span></span><br><span class="line">        <span class="comment">//     int temp = getMinCoins(coins, amount - coin, dp, max);</span></span><br><span class="line">        <span class="comment">//     dp[amount] = temp == -1 ? dp[amount] : Math.min(dp[amount], temp + 1);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//dp[amount] = dp[amount] == max + 1 ? -1 : dp[amount];</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = max + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = getMinCoins(coins, amount - coin, dp, max);</span><br><span class="line">            min = temp == -<span class="number">1</span> ? min : Math.min(min, temp + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[amount] = min == max + <span class="number">1</span> ? -<span class="number">1</span> : min;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划（Bottom-up）"><a href="#动态规划（Bottom-up）" class="headerlink" title="动态规划（Bottom-up）"></a>动态规划（Bottom-up）</h3><p>这里我们需要注意的只有边界case，也就是dp[0] = 0，这里要和coin change 2进行区分，那个是求方式，这个是求硬币数，不一样的！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - coin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt;= max ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 46. Permutations</title>
      <link href="2020/06/05/LeetCode-46-Permutations/"/>
      <url>2020/06/05/LeetCode-46-Permutations/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/permutations/">LeetCode 46. Permutations</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一列不重复整数，找出其所有的全排列。例如：</p><pre><code>Input: [1,2,3]Output:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>back tracking回溯法的经典题目之一，要注意和subset以及combination sum不同的是，这里是要找排列，而不是子集合，思路有很大的不同。</p><p>首先我们先来找一下规律，对于上面的例子，不外乎就是找到以1开头的所有排列，和以2开头的所有排列以及以3开头的所有排列。</p><p>我们对于以1开头的全排列，就是“1 + 2和3的全排列”，然后我们再以同样的思路去找2和3组成的全排列，2和3的全排列就是以2开头，找3的全排列和以3开头找2的全排列。2和3都是单独的数字时，其全排列只有一种，返回。</p><p>那么我们如何去将各种不同的开头的可能性都给找出来呢？我们只需要将某数字和后面的数字轮流置换即可，找完一个以后再换回来，然后和下一个进行置换，直到首个字母和最后一个字母进行置换完成。</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>回溯法置换当前数字和其后面的数字，然后递归调用。</p><p>时间复杂度：O(2 ^ n)，空间复杂度：O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       getPermutations(nums, <span class="number">0</span>, res);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPermutations</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; solution = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                solution.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(solution);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">            getPermutations(nums, i + <span class="number">1</span>, res);</span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back tracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 47. Permutations II</title>
      <link href="2020/06/05/LeetCode-47-Permutations-II/"/>
      <url>2020/06/05/LeetCode-47-Permutations-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/permutations-ii/">LeetCode 47. Permutations II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一列有重复的数，找出其所有的全排列。例如：</p><pre><code>Input: [1,1,2]Output:[[1,1,2],[1,2,1],[2,1,1]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>back tracking回溯法的经典题目之一，<a href="/2020/06/05/LeetCode-46-Permutations/" title="LeetCode 46. Permutations">LeetCode 46. Permutations</a>的进阶版，问题在于我们怎么去应对这个重复数字的问题。</p><p><strong>如果按照以往的思路</strong>，对于这种有重复数字的，我们首先需要对数组进行排序，然后才能更好地去对重复数字进行处理。</p><p>那么我们能否还像permutation<br>1的时候，交换然后再找全排列么？不行的，这种去重方式的核心思想在于后面不会再出现比当前更小的数字，这么说可能有点抽象，我们来看个例子。</p><pre><code>我们给出一个排好序的数组[1, 1, 2, 2, 3]，按照如上思路的话：1. 从第1个数开始，分别和1、2、3、4、5进行替换，然后寻找其后面的全排列；2. 为了不重复，我们每次（除了首次的自我替换）寻找替换的数字的时候，都要找到和当前不一样的数字为止，例如第1个1，和第2个1就不会进行替换，以此类推；3. 那么问题会出在哪里呢？当我们需要替换第1个1和末尾的3时，数组变为[3, 1, 2, 2, 1]，然后我们找出[1, 2, 2, 1]的全排列;4. 按照我们的逻辑，1先和第1个2替换，然后跳过第2个2，然后判断到了第2个1，第2个1和它之前的数字2是不同的，因此我们再次替换，到这里我们就会发现出现了重复，明明1和1不应该再替换的，在这里却被再次替换，所以会多出很多重复。</code></pre><p>因此我们去重的方式其实可以更简单一点，用hashset来判断是之前是否和同样的元素交换过就可以了，而且原始数组不需要排序也可以。</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>注意这里去重的方式和subset 2以及combination sum<br>2的去重方式完全不同，具体原因在上面已经详细描述了，建议自己尝试写一下，这里把错误的代码放在文章末尾，大家有兴趣可以自己debug一下，看看哪里出了问题。</p><p>这里我们使用hashset来去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getPermutations(nums, <span class="number">0</span>, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPermutations</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">            List&lt;Integer&gt; solution = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                solution.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(solution);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果set中成功添加了num，则说明当前数字尚未和该数字交换过</span></span><br><span class="line">            <span class="keyword">if</span> (set.add(nums[i])) &#123;</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">                getPermutations(nums, start + <span class="number">1</span>, res);</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误版本的代码，警戒"><a href="#错误版本的代码，警戒" class="headerlink" title="错误版本的代码，警戒"></a>错误版本的代码，警戒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getPermutations(nums, <span class="number">0</span>, res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// debug专用，找重复</span></span><br><span class="line">        <span class="comment">// Set&lt;List&lt;Integer&gt;&gt; set = new HashSet();</span></span><br><span class="line">        <span class="comment">// List&lt;List&lt;Integer&gt;&gt; newRes = new ArrayList();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (List&lt;Integer&gt; solution : res) &#123;</span></span><br><span class="line">        <span class="comment">//     if (!set.add(solution)) &#123;</span></span><br><span class="line">        <span class="comment">//         newRes.add(solution);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPermutations</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">            List&lt;Integer&gt; solution = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                solution.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(solution);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//这里的去重不行，有很多重复的case,这种写法对于[1,1,2,2,3]没问题，但是对于[0,0,1,1,2,2,3]有问题，自己可以尝试一下。</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; (nums[i] == nums[i - <span class="number">1</span>] || nums[start] == nums[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">            getPermutations(nums, start + <span class="number">1</span>, res);</span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back tracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 31. Next Permutation</title>
      <link href="2020/06/04/LeetCode-31-Next-Permutation/"/>
      <url>2020/06/04/LeetCode-31-Next-Permutation/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/permutations-ii/">LeetCode 31. Next Permutation</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一组数，找出其字典序的下一个序列，如果已经是字典序最后一个序列，则返回其排列组合的第一个字典序。例如：</p><pre><code>1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="/2020/06/05/LeetCode-46-Permutations/" title="LeetCode 46. Permutations">LeetCode 46. Permutations</a></li><li><a href="/2020/06/05/LeetCode-47-Permutations-II/" title="LeetCode 47. Permutations II">LeetCode 47. Permutations II</a></li></ol><p>经典老题目，算法可以默写的那种。对于数字的字典序来说，就是比当前数大的下一个数。根据这个思路，我们可以按照如下思路来计算：</p><pre><code>1. 从右到左寻找第一个降序的数字i，对于12354而言，第一个降序数字就是3；2. 从i的右侧寻找出比i大的最小数字j，对于12354而言，就是4；3. 交换两个数字的位置，变成12453；4. 然后将4后面所有的数字按照升序排列。</code></pre><h3 id="硬核算法"><a href="#硬核算法" class="headerlink" title="硬核算法"></a>硬核算法</h3><p>纯碎的数学问题，对于一个数字，我们想找到比它的下一个字母序组合数字，其实就是找出它所有位组合的数字里刚刚好比它大的那个数字，，我们肯定不能从高位入手，要从低位开始寻求变化，因为高位变化影响大，不符合要求。</p><p>我们知道，对于一组数字而言，升序排列最小，降序排列最大；因此我们才要从右向左找第一个降序。</p><p>如果从左至右全是升序排列，那么说明当前数字已经是最大值了，直接将数组升序排列。</p><p>注意，不要忘了最后的交换，而且我们知道它们都是降序排列，所以直接收尾交换机可，不需要重新写排序函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右到左找到第一个降序的数字，为什么从右找呢？因为前面高位的数字太大，改一个要增大很多，所以从右找。</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; (nums[i] &lt;= nums[i - <span class="number">1</span>])) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经是最大数字了，排序成升序序列即可</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于i的右侧全部降序，从右至左找到第一个比a[i - 1]更大的数字，交换他们</span></span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[i - <span class="number">1</span>];</span><br><span class="line">                nums[i - <span class="number">1</span>] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意最后还需要将a[i - 1]右侧的数字升序排列，由于我们知道是降序的，所以只要两两互换即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; (nums.length - i) / <span class="number">2</span>; x ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i + x];</span><br><span class="line">            nums[i + x] = nums[nums.length - <span class="number">1</span> - x];</span><br><span class="line">            nums[nums.length - <span class="number">1</span> - x] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 90. Subsets II</title>
      <link href="2020/06/04/LeetCode-90-Subsets-II/"/>
      <url>2020/06/04/LeetCode-90-Subsets-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/subsets-ii/">LeetCode 90. Subsets II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一列整数（可能重复），找出其所有不重复的子集合（包括空集）。例如：</p><pre><code>Input: [1,2,2]Output:[[2],[1],[1,2,2],[2,2],[1,2],[]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题就是<a href="/2020/06/04/LeetCode-78-Subsets/" title="LeetCode 78. Subsets">LeetCode 78. Subsets</a>的进阶版，和<a href="/2020/05/24/LeetCode-40-Combination-Sum-II/" title="LeetCode 40. Combination Sum II">LeetCode 40. Combination Sum II</a>特别像，连去重的方式都一模一样，这个必须要记住！！！</p><p><font color=Red>注意:</font>这里需要排序，因为要去重！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 这次就必须要sort了，为什么呢？因为我们要去重，例子中的[1,2]只能有一个。和combination sum 2的去重方式可以一致。每次遍历重复的数只用一次。</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">        getAllSubsets(nums, <span class="number">0</span>, res, path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAllSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;List&lt;Integer&gt;&gt; res, LinkedList&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意，这里的去重很精髓，通过i &gt; start这么个判断条件，使得每种重复的数字只会用一次，比如[1,2,2,2]只会出现一次。细品！！！</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            getAllSubsets(nums, i + <span class="number">1</span>, res, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back tracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法小结</title>
      <link href="2020/06/04/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
      <url>2020/06/04/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯法基本思想"><a href="#回溯法基本思想" class="headerlink" title="回溯法基本思想"></a>回溯法基本思想</h1><p>参考文章：<a href="https://labuladong.github.io/ebook/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88.html">回溯法</a></p><p>首先我们要明确的是回溯法使用的场景，从我个人角度来看，回溯法和没有做任何优化的递归是一样的（或者说回溯法本身就是递归），都是属于暴力搜索的一种方式，但是有些时候我们难以区分回溯法和DP的区别，在第二小节我们详细解释。</p><p>解决一个回溯问题，其实就是遍历所有可能的情况，<strong>在需要记录的时候对解决方案进行记录，在发现当前方案不符合预期的时候返回遍历下一种方案</strong>，其最经典的应用有：求子集合、全排列以及组合问题。</p><p>伪代码框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，这里看似简单，却有很多天坑。回溯法有很多难题，后面遇到了会一一记录，而且面试考察也很多，因为回溯法经常可以和BFS、DFS一起考察。</p><h1 id="回溯法与DP的使用区别"><a href="#回溯法与DP的使用区别" class="headerlink" title="回溯法与DP的使用区别"></a>回溯法与DP的使用区别</h1><p>那么回溯法的难点在哪里呢？其实有很多小tips，例如<a href="/2020/05/24/LeetCode-377-Combination-Sum-IV/" title="LeetCode 377. Combination Sum IV">LeetCode 377. Combination Sum IV</a>，明明前三道combination都是在用回溯法，为什么到了第四题就用DP而不是回溯法了呢？再比如说为什么求subset的时候就不需要sort，而有些时候就需要sort呢？</p><p>我们这里先来看一下回溯法解决的问题和DP解决问题最大的不同</p><table><thead><tr><th>类目</th><th>回溯法</th><th>DP</th></tr></thead><tbody><tr><td>解决问题类型</td><td>通常是求出给定条件的集合，注意，是最终的详细的解，而不是个数。</td><td>一般是求某个值，例如说最大值，最小值，或者XXX的个数，一般情况下不会给出额外的限定条件，因为DP是要写递推式的，有额外条件不方便写出普适的递推式。</td></tr></tbody></table><p>这么看起来感觉比较抽象，我们来举个例子，<a href="/2020/05/24/LeetCode-39-Combination-Sum/" title="LeetCode 39. Combination Sum">LeetCode 39. Combination Sum</a>和<a href="/2020/05/24/LeetCode-377-Combination-Sum-IV/" title="LeetCode 377. Combination Sum IV">LeetCode 377. Combination Sum IV</a>。</p><p><font color = red>注意，以下分析仅针对39和337，所谓的不同的解就用DP之类的仅针对该题目，具体问题具体分析，这里只是举例看二者的区别</font></p><p>这里不再赘述题目。39题和377题最大的不同点在于39题可以重复，而337不行，什么意思呢？例如[1,3]和[3,1]在39题里是同一个解，而337题里是不同的解。</p><p>那么为什么不同的解就可以用DP而不能用回溯呢？我们要注意，不是说不能用回溯，只是说DP更快。因为回溯其实是暴力搜索的一种，而DP是对暴力搜索的优化，<strong>因此对这道题而言</strong>，能用DP就自然也能用回溯（这里存在遍历选项的问题因此可以用回溯，并不是所有DP都能用回溯，要注意这里是必要不充分条件）。</p><p>将39题的递归调用backtracking那块的代码，将i变换成0就是变成找出所有解了，就会将[1,3]和[3,1]当做不同解。从0开始递归找全局组合方式。</p><p>例如：给出[1,2,3]，我们的target是4，那么我们使用dp的时候，dp[4 - 1]和dp[4 - 3]我们都会去计算，因为我们不关心dp[3]和dp[1]是怎么来的，我们可以任意组合数字。</p><p>当我们使用回溯法的时候需要先对数组进行排序，然后遍历的时候只能向后遍历（包含当前节点），例如说我们到了1，我们可以从[1,2,3]中找可以组合成为3的组合；再或者我们到了2，我们就不能回去找1，就只能从[2,3]里找出所有可以组合为2的可能。这样保证了不重复</p><h1 id="回溯法需要注意的点"><a href="#回溯法需要注意的点" class="headerlink" title="回溯法需要注意的点"></a>回溯法需要注意的点</h1><h2 id="什么时候回溯需要sort，而什么时候不要？"><a href="#什么时候回溯需要sort，而什么时候不要？" class="headerlink" title="什么时候回溯需要sort，而什么时候不要？"></a>什么时候回溯需要sort，而什么时候不要？</h2><p>当我们原始数组里有重复数字（包括数字不重复可以重复使用）且需要不重复的解的时候需要sort。多看看下面的例子自行体会~</p><p>需要sort的例子有：<a href="/2020/05/24/LeetCode-39-Combination-Sum/" title="LeetCode 39. Combination Sum">LeetCode 39. Combination Sum</a><br> <a href="/2020/05/24/LeetCode-40-Combination-Sum-II/" title="LeetCode 40. Combination Sum II">LeetCode 40. Combination Sum II</a><br><a href="/2020/06/04/LeetCode-90-Subsets-II/" title="LeetCode 90. Subsets II">LeetCode 90. Subsets II</a></p><p>不需要sort的例子有：<a href="/2020/05/24/LeetCode-377-Combination-Sum-IV/" title="LeetCode 377. Combination Sum IV">LeetCode 377. Combination Sum IV</a><br><a href="/2020/06/04/LeetCode-78-Subsets/" title="LeetCode 78. Subsets">LeetCode 78. Subsets</a></p><h2 id="当给出的数组中存在重复数字怎么办？如何避免重复解"><a href="#当给出的数组中存在重复数字怎么办？如何避免重复解" class="headerlink" title="当给出的数组中存在重复数字怎么办？如何避免重复解"></a>当给出的数组中存在重复数字怎么办？如何避免重复解</h2><p>在循环选项之前加上这么一个if判断即可，例题：</p><a href="/2020/05/24/LeetCode-40-Combination-Sum-II/" title="LeetCode 40. Combination Sum II">LeetCode 40. Combination Sum II</a><br><a href="/2020/06/04/LeetCode-90-Subsets-II/" title="LeetCode 90. Subsets II">LeetCode 90. Subsets II</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 总结 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 78. Subsets</title>
      <link href="2020/06/04/LeetCode-78-Subsets/"/>
      <url>2020/06/04/LeetCode-78-Subsets/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/subsets/">LeetCode 78. Subsets</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一列不重复整数，找出其所有子集合（包括空集）。例如：</p><pre><code>Input: nums = [1,2,3]Output:[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>back tracking回溯法的经典题目之一，和<a href="/2020/06/04/LeetCode-90-Subsets-II/" title="LeetCode 90. Subsets II">LeetCode 90. Subsets II</a>区别在于，这道题无需考虑重复数字的问题，和combination sum很像。这里是找组合，而不是sum，所以无需排序。</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>直接回溯法计算即可。固定住其中一些位置，然后从前向后找。</p><p>时间复杂度：O(2 ^ n)，空间复杂度：O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">        backtracking(nums, <span class="number">0</span>, path, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>, path, res);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back tracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1029. Two City Scheduling</title>
      <link href="2020/06/03/LeetCode-1029-Two-City-Scheduling/"/>
      <url>2020/06/03/LeetCode-1029-Two-City-Scheduling/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/two-city-scheduling/">LeetCode 1029. Two City Scheduling</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>公司有2N个面试者，一共有两个面试地点A和B，需要保证每个地点都有N个人面试，每个面试者距离AB远近不同，导致路程花销也不一样。每个人的到达A、B地点的花销用一个二维数组来表示，求怎么样分配使得总花销最小，求出这个总花销。例如：</p><pre><code>Input: [[10,20],[30,200],[400,50],[30,20]]Output: 110Explanation: The first person goes to city A for a cost of 10.The second person goes to city A for a cost of 30.The third person goes to city B for a cost of 50.The fourth person goes to city B for a cost of 20.The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.</code></pre><p>限制：</p><ol><li>1 &lt;= costs.length &lt;= 100</li><li>It is guaranteed that costs.length is even.</li><li>1 &lt;= costs[i][0], costs[i][1] &lt;= 1000</li></ol><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>首先最直接的办法使用DFS，回溯，遍历所有可能性，时间复杂度为O(2^n)，这里n为总人数，由于n在最大为100，因此这个方法一定会超时，放弃。</p><p>那么能否使用DP呢？也不行！因为要求每个面试地点都要有N个人，也就是说前面的选择对后面的选择会造成影响，说明问题不算独立子问题，所以也不行。</p><p>这里我们使用贪心法。</p><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>公司希望总花销最小，其实这不单单是从整体的角度考虑，更要从个人的角度去看，对于每个人来说，都有两种选择，A和B，而每个人到A和到B的花销的差其实才是我们最关心的，如果差的特别多，比如说cost[i][0]很小，而cost[i][1]很大，那么我们就应该选择A地点，因为如果选择B地点的话，就会多花出很多钱。</p><p>我们定义一个变量叫做营收S，对于A的营收S(A) = cost[i][0] - cost[i][1]，这个营收S可能为正，也可能为负，如果为正，就说明到A的cost比到B的cost要多，我们将他分配到A地点的可能性就更小；相反若为负，则可能性更大。</p><p>因此我们将每个数对按照对A的营收进行排序，前N个元素就为A地点的面试人，剩下的就是B地点的面试人。</p><font color=12DBF1>时间复杂度:O(nlogn)，排序的复杂度。<p>空间复杂度:O(1)。<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能用DP，因为有N个的限制，状态有依赖关系？每个只有两种选择的可能性，使用backtracking + 剪枝？也不行，因为可能性实在是太多了，不可能全都穷举完，cost的length达到了100。考虑使用贪心。</span></span><br><span class="line">        Arrays.sort(costs, (a1, a2) -&gt; (a1[<span class="number">0</span>] - a1[<span class="number">1</span>]) - (a2[<span class="number">0</span>] - a2[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> n = costs.length / <span class="number">2</span>, minCost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            minCost += costs[i][<span class="number">0</span>] + costs[i + n][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minCost;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 445. Add Two Numbers II</title>
      <link href="2020/06/03/LeetCode-445-Add-Two-Numbers-II/"/>
      <url>2020/06/03/LeetCode-445-Add-Two-Numbers-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/add-two-numbers-ii/">LeetCode 445. Add Two Numbers II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个链表，每个链表表示一个数字，链表中的每个元素表示每一位，<strong>从高到低</strong>，求两个链表加和（有进位）。例如：</p><pre><code>Example:Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>类似的题目还有<a href="/2020/06/03/LeetCode-2-Add-Two-Numbers/" title="LeetCode 2. Add Two Numbers">LeetCode 2. Add Two Numbers</a>，注意此题是从高位到低位存储，而LeetCode2中是从低到高存储。</p><h3 id="双指针-Stack"><a href="#双指针-Stack" class="headerlink" title="双指针 + Stack"></a>双指针 + Stack</h3><p>如果我们从头开始遍历的话，发现是从最高位开始的，但是我们计算又不能从最高位开始计算，一定要从最低位开始，因此我们需要一种能够从后向前遍历的数据结构，我们选择stack。</p><font color=red>我们这里有一点需要着重强调，在对链表进行赋值计算的时候，每次对ptr.next进行new，然后将ptr = ptr.next。</font><font color=12DBF1><p>时间复杂度:O(m + n)</p><p>空间复杂度:O(m + n)<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> l2;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> l1;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack(), stack2 = <span class="keyword">new</span> Stack(), stack = <span class="keyword">new</span> Stack();</span><br><span class="line">         <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">             stack1.push(l1.val);</span><br><span class="line">             l1 = l1.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">             stack1.push(l2.val);</span><br><span class="line">             l2 = l2.next;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty() || flag != <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> value1 = stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">             <span class="keyword">int</span> value2 = stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">             <span class="keyword">int</span> value = (value1 + value2 + flag) % <span class="number">10</span>;</span><br><span class="line">             flag = (value1 + value2 + flag) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">             stack.push(value);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         ListNode head = <span class="keyword">new</span> ListNode(), ptr = head;</span><br><span class="line">         <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">             ptr.next = <span class="keyword">new</span> ListNode(stack.pop());</span><br><span class="line">             ptr = ptr.next;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双指针-ArrayList"><a href="#双指针-ArrayList" class="headerlink" title="双指针 + ArrayList"></a>双指针 + ArrayList</h3><p>其实数字的存储不一定要用stack，用arraylist会更快。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; num1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        List&lt;Integer&gt; num2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        ListNode ptr = l1;</span><br><span class="line">        <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            num1.add(ptr.val);</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = l2;</span><br><span class="line">        <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            num2.add(ptr.val);</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// form back to start</span></span><br><span class="line">        <span class="keyword">int</span> ptr1 = num1.size() - <span class="number">1</span>, ptr2 = num2.size() - <span class="number">1</span>, flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ptr1 &gt;= <span class="number">0</span> || ptr2 &gt;= <span class="number">0</span> || flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value1 = ptr1 &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.get(ptr1).intValue();</span><br><span class="line">            <span class="keyword">int</span> value2 = ptr2 &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.get(ptr2).intValue();</span><br><span class="line">            <span class="keyword">int</span> value = (value1 + value2 + flag) % <span class="number">10</span>;</span><br><span class="line">            flag = (value1 + value2 + flag) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里注意给head赋值的方式，因为是从后向前进行遍历的。</span></span><br><span class="line">            head.val = value;</span><br><span class="line">            ListNode temp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            temp.next = head;</span><br><span class="line">            head = temp;</span><br><span class="line">            ptr1--;</span><br><span class="line">            ptr2--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linked list </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 24. Swap Nodes in Pairs</title>
      <link href="2020/06/03/LeetCode-24-Swap-Nodes-in-Pairs/"/>
      <url>2020/06/03/LeetCode-24-Swap-Nodes-in-Pairs/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">LeetCode 24. Swap Nodes in Pairs</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个链表，从头开始使其两两交换。例如：</p><pre><code>Example:Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>也是LeetCode中比较靠前的老题目，其进阶版本<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">LeetCode 25. Reverse Nodes in k-Group</a>。</p><p>对于这种需要更改链表的题目，包括reverse linked list的题目，最重要的一点就是画图，画图然后去更改每一个指针的指向，然后将当前的节点向后移。否则很容易出错。</p><p>这里需要注意的是初次进行swap的时候要进行判断，是否是要和pre的指针相连，如果是初次swap，则pre是null，不需要相连。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode ret = head.next, ptr = head, pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr != <span class="keyword">null</span> &amp;&amp; ptr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode post = ptr.next.next;</span><br><span class="line">            ptr.next.next = ptr;</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.next = ptr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr.next = post;</span><br><span class="line">            pre = ptr;</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 92. Reverse Linked List II</title>
      <link href="2020/06/03/LeetCode-92-Reverse-Linked-List-II/"/>
      <url>2020/06/03/LeetCode-92-Reverse-Linked-List-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/">LeetCode 92. Reverse Linked List II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个链表，和两个正整数m、n（1 &lt;= m &lt;= n &lt;= length），翻转该链表的第m和n之间的元素。例如：</p><pre><code>Example:Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>经典题目的难度加大的版本，难度在于我们需要找到起始位置和终止位置，基本思路如下：</p><ol><li>首先找到第m个元素ptr，以及它前面的那个元素pre，pre有可能为null；</li><li>定义tail = ptr，因为翻转后，第m个元素就是翻转部分链表的结尾；</li><li>定义con = pre，这个con是用来记录当前pre是否为null的，如果不为null值，就将con和反转后的表头相连，，为null就直接返回反转后的表头；</li><li>定义tail = ptr，因为当前未翻转部分的表头ptr其实是反转后的末尾，记录一下，因为后面while循环后ptr就不在翻转列表里了，需要重新连一下。</li><li>while循环，记录post元素，将ptr的next指向pre，然后更改ptr和pre（这里有一个注意事项，就是翻转第一个元素的时候可能有人会觉得不合理，其实这只是暂存，while循环后面会修正的）。</li><li>修正tail的指向；</li><li>判断连接处con是否为空，如果不为空则连接，为空则不连接。</li></ol><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode ptr = head, pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            pre = ptr;</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode con = pre, tail = ptr;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode post = ptr.next;</span><br><span class="line">            <span class="comment">// 注意，对于第一个翻转的元素，这里只是暂存！！！后面ptr会变，这里其实是tail</span></span><br><span class="line">            ptr.next = pre;</span><br><span class="line">            pre = ptr;</span><br><span class="line">            ptr = post;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail.next = ptr;</span><br><span class="line">        <span class="comment">// while循环结束时，ptr处于第n+1个元素，pre是原本的第n个元素</span></span><br><span class="line">        <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">            con.next = pre;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 206. Reverse Linked List</title>
      <link href="2020/06/03/LeetCode-206-Reverse-Linked-List/"/>
      <url>2020/06/03/LeetCode-206-Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/reverse-linked-list/">LeetCode 206. Reverse Linked List</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个链表，翻转该链表。例如：</p><pre><code>Example:Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>最经典的题目之一了，没啥好说的，背就完了，其进阶版本<a href="/2020/06/03/LeetCode-92-Reverse-Linked-List-II/" title="LeetCode 92. Reverse Linked List II">LeetCode 92. Reverse Linked List II</a>。</p><p>自己画图，找出ptr，pre和post之间的连接关系应该怎么去解决，以及边界条件，初始化的问题，稍微注意一下就好，难是不难，就是绕。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode ptr = head, pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode post = ptr.next;</span><br><span class="line">            <span class="comment">// 将后面指向前面，第一个元素反转后将会是末尾，所以指向null，没毛病</span></span><br><span class="line">            ptr.next = pre;</span><br><span class="line">            pre = ptr;</span><br><span class="line">            ptr = post;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode reversed = reverseList(head.next);</span><br><span class="line">        <span class="comment">//这时候，head.next被置换到了末尾，所以需要将末尾指向自己</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        <span class="comment">// 注意置换到了末尾后，要将自己的next置为null</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reversed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 142. Linked List Cycle II</title>
      <link href="2020/06/03/LeetCode-142-Linked-List-Cycle-II/"/>
      <url>2020/06/03/LeetCode-142-Linked-List-Cycle-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">LeetCode 142. Linked List Cycle II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个链表，判断链表是否存在环，如果有环，找出入环点，如果没有环，则返回null。例如：</p><p><img src="/images/leetcode142.png" alt="Example" title="Example"></p><pre><code>Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>极其经典的老题目，类似题目：<a href="/2020/06/03/LeetCode-141-Linked-List-Cycle/" title="LeetCode 141. Linked List Cycle">LeetCode 141. Linked List Cycle</a></p><p>依然采用双指针做法，但是需要一些数学推导，由于markdown中不方便编辑公式，直接在纸上写以图片的形式说明算法。</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>两个指针，一个slow，一个fast，slow每次走一步，fast每次走两步，如果fast先到达null值，则说明无环；如果slow和fast相遇，则说明有环，我们记录相遇点。</p><p><img src="/images/leetcode142-%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF.jpeg" alt="算法思路" title="algorithm"></p><font color=12DBF1>时间复杂度:O(n).<p>空间复杂度:O(1)，只有fast和slow两个指针变量。<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数学推导过程记得写一下</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">        ListNode cross = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow.equals(fast)) &#123;</span><br><span class="line">                cross = slow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cross == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有环，开始找环</span></span><br><span class="line">        ListNode ptr1 = head, ptr2 = cross;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，这里是返回的是ptr1或者ptr2</span></span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linked list </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 141. Linked List Cycle</title>
      <link href="2020/06/03/LeetCode-141-Linked-List-Cycle/"/>
      <url>2020/06/03/LeetCode-141-Linked-List-Cycle/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/linked-list-cycle/">LeetCode 141. Linked List Cycle</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个链表，判断链表是否存在环。例如：</p><p><img src="/images/leetcode141.png" alt="Example" title="Example"></p><pre><code>Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>极其经典的老题目，类似题目：<a href="/2020/06/03/LeetCode-142-Linked-List-Cycle-II/" title="LeetCode 142. Linked List Cycle II">LeetCode 142. Linked List Cycle II</a></p><p>一种做法是用hashset来存储，每次遍历的时候去查找是否之前遍历过相同的点。这种方法看似简单，时间复杂度也不高，但是实际上调用contains函数次数也很多，时间反而较长。</p><p>这里我们使用双指针做法更好。</p><p><font color=red> 注意，2 pointers的代码要背下来，注意取while循环的方式，这个是死的。不要slow = head， fast = head.next，这样做步长就不是二倍关系，而是2倍-1，而且对于找入环点没有帮助。</font></p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>两个指针，一个slow，一个fast，slow每次走一步，fast每次走两步，如果fast先到达null值，则说明无环，否则有环；如果slow和fast相遇，则说明有环。</p><font color=12DBF1>时间复杂度:O(n)，无环的情况下自然不用多说，我们只考虑有环情况下的复杂度。如果有环，则slow进入环以后，fast可能在某位置，slow走一圈的时间，fast必定能走两圈，所以必定会相遇，而不是白绕很多圈，所以时间复杂度为O(n).<p>空间复杂度:O(1)，只有fast和slow两个指针变量。<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linked list </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 23. Merge k Sorted Lists</title>
      <link href="2020/06/03/LeetCode-23-Merge-k-Sorted-Lists/"/>
      <url>2020/06/03/LeetCode-23-Merge-k-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/merge-k-sorted-lists/">LeetCode 23. Merge k Sorted Lists</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>合并多个有序链表。例如：</p><pre><code>Example:Input:[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>极其经典的老题目，类似题目：<a href="/2020/06/03/LeetCode-21-Merge-Two-Sorted-Lists/" title="LeetCode 21. Merge Two Sorted Lists">LeetCode 21. Merge Two Sorted Lists</a></p><p>我们首先需要注意的是k个数组的话如果继续使用迭代的方式，会产生很多条件的判断，例如每次添加了一个节点之后，需要判断k个List中哪些已经到头了，计算起来很麻烦，而且易错。那么我们如何将问题分解成之前做过的“Merge 2 Sorted Arrays”呢？答案就是分治法。</p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>每次二分整个lists，直到分为了两个list的合并或者一个单独的list，合并它们并返回。</p><font color=12DBF1>时间复杂度:O(n * logk)，n是所有list节点总数，k是list个数。这是因为我们其实一共需要对每个元素合并logk次，每次返回上一级都要重新合并，因此是乘法。<p>空间复杂度:O(logk)，大部分的操作都是O(1)空间的，只有递归层数是需要压栈要空间。<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//**</span></span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"> *     <span class="keyword">int</span> val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergeLists(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function is used to divide numerous lists into smaller parts and merge them into one list.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeLists</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[start];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(lists[start], lists[end]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            ListNode left = mergeLists(lists, start, mid);</span><br><span class="line">            ListNode right = mergeLists(lists, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode ptr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                ptr.next = l1;</span><br><span class="line">                ptr = ptr.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ptr.next = l2;</span><br><span class="line">                ptr = ptr.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ptr.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> divide and conquer </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 21. Merge Two Sorted Lists</title>
      <link href="2020/06/03/LeetCode-21-Merge-Two-Sorted-Lists/"/>
      <url>2020/06/03/LeetCode-21-Merge-Two-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/">LeetCode 21. Merge Two Sorted Lists</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>合并两个有序链表。例如：</p><pre><code>Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考解法：<a href="https://www.youtube.com/watch?v=qckKEYP9bBA">花花酱LeetCode</a></p><p>极其经典的老题目，每年肯定都有考的，背下来就可以了。进阶版本：<a href="/2020/06/03/LeetCode-23-Merge-k-Sorted-Lists/" title="LeetCode 23. Merge k Sorted Lists">LeetCode 23. Merge k Sorted Lists</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>当两个list有一个为空时，直接返回另一个。如果都不为空，比较两个list队首的值，选其中较小的那个，我们设为node，将该node.text设为node.next和另一个List的merge结果即可，返回node节点。</p><font color=12DBF1>时间复杂度:O(m + n)，最坏情况m+n次递归，每次O(1)。<p>空间复杂度:O(m + n)，递归的最坏情况是二者之和。<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>思路基本一致，只是需要注意其中一个为空的时候的情况。</p><font color=12DBF1>时间复杂度:O(m + n)，最坏情况m+n次递归，每次O(1)。<p>空间复杂度:O(1)，不需要额外空间，merge都是直接操作指针的，没有新建链表。<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode ptr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value1 = l1.val, value2 = l2.val;</span><br><span class="line">            <span class="keyword">if</span> (value1 &lt;= value2) &#123;</span><br><span class="line">                ptr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                ptr = ptr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ptr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                ptr = ptr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ptr.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 2. Add Two Numbers</title>
      <link href="2020/06/03/LeetCode-2-Add-Two-Numbers/"/>
      <url>2020/06/03/LeetCode-2-Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/add-two-numbers/">LeetCode 2. Add Two Numbers</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个链表，每个链表表示一个数字，链表中的每个元素表示每一位，<strong>从低到高</strong>，求两个链表加和（有进位）。例如：</p><pre><code>Example:Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>LeetCode 2的题目，一看就知道也是经典老题了。类似的题目还有<a href="/2020/06/03/LeetCode-445-Add-Two-Numbers-II/" title="LeetCode 445. Add Two Numbers II">LeetCode 445. Add Two Numbers II</a></p><p>这里是从低位到高位，我们需要注意的地方有两点：一是进位二茂铁，二是二者长度不相等的问题，pointer为空的时候要注意。</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>两个指针分别指向两个list的初始位置，然后计算是否存在进位，然后计算下一位，如果为空，则为0，继续计算，直至两个pointer均为null且进位也为0.</p><font color=red>我们这里有一点需要着重强调，在对链表进行赋值计算的时候，每次对ptr.next进行new，然后将ptr = ptr.next。</font><font color=12DBF1><p>时间复杂度:O(m + n)</p><p>空间复杂度:O(m + n)<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode ptr1 = l1, ptr2 = l2, ptr = head;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ptr1 != <span class="keyword">null</span> || ptr2 != <span class="keyword">null</span> || flag != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value1 = ptr1 == <span class="keyword">null</span> ? <span class="number">0</span> : ptr1.val;</span><br><span class="line">            <span class="keyword">int</span> value2 = ptr2 == <span class="keyword">null</span> ? <span class="number">0</span> : ptr2.val;</span><br><span class="line">            <span class="keyword">int</span> value = (value1 + value2 + flag) % <span class="number">10</span>;</span><br><span class="line">            flag = (value1 + value2 + flag) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            ptr.next = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">            ptr1 = ptr1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : ptr1.next;</span><br><span class="line">            ptr2 = ptr2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 226. Invert Binary Tree</title>
      <link href="2020/06/02/LeetCode-226-Invert-Binary-Tree/"/>
      <url>2020/06/02/LeetCode-226-Invert-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>翻转一棵二叉树。例如：</p><pre><code>Invert a binary tree.Example:Input:     4   /   \  2     7 / \   / \1   3 6   9Output:     4   /   \  7     2 / \   / \9   6 3   1</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>一道被大佬吐槽的easy题目。DFS或者BFS均可。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>递归调用invert，前中后序均可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.left = invertTree(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.right = invertTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.left = invertTree(root.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.right = invertTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.left = invertTree(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.right = invertTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            TreeNode temp = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 64. Minimum Path Sum</title>
      <link href="2020/06/02/LeetCode-64-Minimum-Path-Sum/"/>
      <url>2020/06/02/LeetCode-64-Minimum-Path-Sum/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/minimum-path-sum/">LeetCode 64. Minimum Path Sum</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个m x n的网格，每个格子有一个数字，求问从top-left到bottom-right的所有路径中数字和最小是多少。</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考解法：<a href="https://www.youtube.com/watch?v=fmpP5Ll0Azc">花花酱LeetCode</a></p><p>是<a href="/2020/06/02/LeetCode-62-Unique-Paths/" title="LeetCode 62. Unique Paths">LeetCode 62. Unique Paths</a>进阶问题，思路类似。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>和之前思路类似，只是base case小改一下，以及dp[i][j]记录的不再是走法，而是从[0, 0]到当前节点的最小path和。</p><font color=12DBF1>时间复杂度:O(m * n)<p>空间复杂度:O(m * n)<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            sum += grid[i][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">0</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            sum += grid[<span class="number">0</span>][j];</span><br><span class="line">            dp[<span class="number">0</span>][j] = sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 63. Unique Paths II</title>
      <link href="2020/06/02/LeetCode-63-Unique-Paths-II/"/>
      <url>2020/06/02/LeetCode-63-Unique-Paths-II/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/unique-paths-ii/">LeetCode 63. Unique Paths II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>一个机器人坐落在一个网格中，初始点在top-left，终点在bottom-right，机器人只能向右或者向下走，而且存在一些路障（数值为1），求问有多少种走法可以到达终点。</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考解法：<a href="https://www.youtube.com/watch?v=fmpP5Ll0Azc">花花酱LeetCode</a></p><p>是<a href="/2020/06/02/LeetCode-62-Unique-Paths/" title="LeetCode 62. Unique Paths">LeetCode 62. Unique Paths</a>进阶问题，思路类似。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>和之前思路类似，只是base case中，如果出现了路障，则后面是0。而且在动态规划递推的过程中，对于grid值为1的点dp值直接置为0。</p><font color=12DBF1>时间复杂度:O(m * n)<p>空间复杂度:O(m * n)<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// top-down</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// without padding</span></span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize the base cases.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                value = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>][j] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                value = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(obstacleGrid, dp, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[][] dp, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[m][n] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[m][n] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[m][n] = <span class="number">0</span>;</span><br><span class="line">        dp[m][n] += helper(grid, dp, m - <span class="number">1</span>, n);</span><br><span class="line">        dp[m][n] += helper(grid, dp, m, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bottom-up</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize the base cases.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                value = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>][j] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                value = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 62. Unique Paths</title>
      <link href="2020/06/02/LeetCode-62-Unique-Paths/"/>
      <url>2020/06/02/LeetCode-62-Unique-Paths/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/unique-paths/">LeetCode 62. Unique Paths</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>一个机器人坐落在一个m x n的一个网格中，初始点在top-left，终点在bottom-right，机器人只能向右或者向下走，求问有多少种走法可以到达终点。</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考解法：<a href="https://www.youtube.com/watch?v=fmpP5Ll0Azc">花花酱LeetCode</a></p><p>也是一道经典老题目了，DP的代表问题之一。<a href="/2020/06/02/LeetCode-63-Unique-Paths-II/" title="LeetCode 63. Unique Paths II">LeetCode 63. Unique Paths II</a></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们定义dp[i][j]为从[0][0]到达当前点的所有可能的方式，由于只能向右或者向下走，所以有如下递推式：</p><p>$$dp[i][j] = dp[i - 1][j] + dp[i][j - 1]$$</p><p>base case就是dp[0]和dp[i][0]，这两条边线的初始值都为1，只有一种走法。</p><font color=12DBF1>时间复杂度:O(m * n)<p>空间复杂度:O(m * n)<br></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// top-down</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.fill(dp[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(dp, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[][] dp, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[m][n] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[m][n] = helper(dp, m, n - <span class="number">1</span>) + helper(dp, m - <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bottom-up</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.fill(dp[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 10. Regular Expression Matching</title>
      <link href="2020/06/02/LeetCode-10-Regular-Expression-Matching/"/>
      <url>2020/06/02/LeetCode-10-Regular-Expression-Matching/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/regular-expression-matching/">LeetCode 10. Regular Expression Matching</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个字符串s和p，其中s是由小写字母组成，p是由小写字母以及’.’和’*‘组成，’.’和’*‘分别有如下含义：</p><pre><code>&#39;.&#39; 可以表示任何单个字符&#39;*&#39; 可以表示0个或者多个*前面的字符（需要组合起来看，例如:&#39;a*&#39;可以表示0个a或者多个a）</code></pre><p>例如：</p><pre><code>Example 1:Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.Example 2:Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.Example 3:Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.Example 4:Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>相关问题：</p><ol><li><a href="https://leetcode.com/problems/wildcard-matching/">LeetCode 44. Wildcard Matching</a></li><li><a href="/2020/06/02/LeetCode-72-Edit-Distance/" title="“LeetCode 72. Edit Distance”">“LeetCode 72. Edit Distance”</a></li></ol><p>这种题就是做过一次才能有大概思路，也不能保证完全能做出来。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>首先，对于这道题，直接用动态规划分析，没有为什么。分析p的两种特殊字符，比较麻烦的是’*’，因为我们不知道它会代表几个字符。因此我们只能逐个分析，代表0个，1个……</p><p>这里latex写公式有点问题，因此主体逻辑在注释中，其实其中最难理解的部分就是p[j]为’*’时的情况。</p><p>这里我们将其分为两种子情况：</p><ol><li><p>s[i] 和 p[j - 1]不匹配：那么dp[i][j] = dp[i][j - 2]，这是因为既然二者不匹配的话，说明只能将dp[j - 1]dp[j]这个小pattern当做是空串；</p></li><li><p>s[i] 和 p[j - 1]匹配：这里我们再去分析其可能的情况。匹配0个s[i]，1个s[i]，2个s[i]……但是我们仔细一想可以发现，假如说匹配2个及以上个s[i]的话，那么s的前i-1个字符的子串和p的前j个字符的子串也一定是匹配的！这里以两个为例:</p><p> s:”acbbbd”<br> p:”acb*d”</p></li></ol><p>当i = 3时，也就是计算s的子串”acbb”时，当我们匹配到j = 3时，也就是说”acb*”时，我们发现”acb*”和i = 2时的”acb”也是匹配的，因为这里”b*”表示为1个b。换句话说，如果”b*”表示两个及以上的“b”的话，那么s[0， i-1]和p[0, j]也一定是匹配的，因为”b*”表示的重复有很多。</p><p>因此对于上面的情况2，我们可以将匹配2个及以上s[i]的情况递推为dp[i - 1][j]，因此我们有递推式：</p><p>dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j]</p><p>三项分别对应0个，1个和多个的情况。</p><p>进一步，我们可以将其规约为两项，因为如果*的前一个字符和s[i]相匹配，那么可以匹配0个，1个，2个，3个…对于1个及以上的情况，我们可以将其规约到dp[i-1][j+1]里面，因为这次的的1个,2个,3个等于上次匹配的0个,1个，2个…</p><p>dp[i][j] = dp[i][j - 2] || dp[i - 1][j]</p><p>参考解析：<a href="https://leetcode.com/problems/regular-expression-matching/discuss/5651/Easy-DP-Java-Solution-with-detailed-Explanation">LeetCode discussion区的大佬解法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里s和p可能都为空</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">char</span>[] s_char = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] p_char = p.toCharArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p_char[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 相当于中间要跨一个格子，例如s=“”，p=&quot;a#b#&quot;</span></span><br><span class="line">                dp[<span class="number">0</span>][i+<span class="number">1</span>] = dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 二者正常匹配，无#情况</span></span><br><span class="line">                <span class="keyword">if</span> (p_char[j] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s_char[i] == p_char[j] || p_char[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果p[j]==&#x27;*&#x27;，分情况讨论</span></span><br><span class="line">                <span class="keyword">if</span> (p_char[j - <span class="number">1</span>] != s_char[i] &amp;&amp; p_char[j - <span class="number">1</span>] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// *的前一个字符不匹配，那么只能当做匹配0个处理了</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// *的前一个字符和s[i]相匹配，那么可以匹配0个，1个，2个，3个...对于1个及以上的情况，我们可以将其规约到dp[i-1][j+1]里面，因为这次的的1个,2个,3个等于上次匹配的0个,1个，2个...</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] || dp[i][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 72. Edit Distance</title>
      <link href="2020/06/02/LeetCode-72-Edit-Distance/"/>
      <url>2020/06/02/LeetCode-72-Edit-Distance/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/edit-distance/">LeetCode 72. Edit Distance</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个单词word1和word2，找出从word1变为word2的最少操作数。共计有如下几种操作：</p><ol><li><p>Insert a character</p></li><li><p>Delete a character</p></li><li><p>Replace a character</p><p> Input: word1 = “horse”, word2 = “ros”<br> Output: 3<br> Explanation:<br> horse -&gt; rorse (replace ‘h’ with ‘r’)<br> rorse -&gt; rose (remove ‘r’)<br> rose -&gt; ros (remove ‘e’)</p></li></ol><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考解法：<a href="https://www.youtube.com/watch?v=Q4i_rqON2-E">花花酱LeetCode</a></p><p>也是一道经典老题目了，这种题和正则匹配类的题目基本上是类似的。等下写完本篇Blog再去做一下那道题，也很经典。<a href="/2020/06/02/LeetCode-10-Regular-Expression-Matching/" title="LeetCode 10. Regular Expression Matching">LeetCode 10. Regular Expression Matching</a></p><p>这种题的做法其实并不复杂，复杂的是分情况讨论。因此实际上是hard难度的题目，真的很难想。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们假设两个字符串为“####a###”和”####b###”，“#”字符是什么我们不用去管，我们只知道我们比较到了一对不一样的字母，‘a’和‘b’，位置为i和j，此时，我们有三种解决方式：插入、删除、替换：</p><pre><code>第一种，我们在word1中a的位置后插入一个b，让其和word2中的b相等，然后再去比较剩下的字符串；dp[i][j - 1]第二种，我们删除word1中的a，然后继续比较word1和word2中剩下的字符；dp[i - 1][j]第三种，我们将word1中的a替换成b，然后继续比较剩下的字符。dp[i - 1][j - 1]</code></pre><p>我们应该取这三种选项中操作次数最少的。<br>那么我们如何把他用dp递推式的形式展现出来呢？我们假设dp[i][j]为word1的前i个字符转换成word2中前j个字符所需要的最少操作数。</p><p>$$dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])$$</p><p>base case就是当比较的两个字符串其中一个为空时，另一个需要操作的次数等于它的长度，需要全部删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// top - down解法</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">char</span>[] w1, w2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = word1.length(), l2 = word2.length();</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[l1 + <span class="number">1</span>][l2 + <span class="number">1</span>];</span><br><span class="line">        w1 = word1.toCharArray();</span><br><span class="line">        w2 = word2.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[l1][l2] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w1[l1 - <span class="number">1</span>] == w2[l2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[l1][l2] = helper(l1 - <span class="number">1</span>, l2 - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[l1][l2] = <span class="number">1</span> + Math.min(Math.min(helper(l1 - <span class="number">1</span>, l2), helper(l1, l2 - <span class="number">1</span>)), helper(l1 - <span class="number">1</span>, l2 - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 494. Target Sum</title>
      <link href="2020/06/02/LeetCode-494-Target-Sum/"/>
      <url>2020/06/02/LeetCode-494-Target-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/target-sum/">LeetCode 494. Target Sum</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一组非负整数nums，和一个目标数S，对每个数字前面我们可以添加正负号，求问一共有多少种添加正负号的方式使得整个数组加和为S。</p><p>注意：数组的长度不会超过20；整个数组的加和不会大于1000；返回值一定是32位整形数。</p><pre><code>Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考解法：<a href="https://www.youtube.com/watch?v=zks6mN06xdQ">花花酱LeetCode</a></p><p>这是一道极其经典的老题目了，target sum和0-1背包问题很是相像，并且其能够转化为0-1背包问题，这里一起记录一下整道题的思路吧。</p><h3 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h3><p>首先，对于本题目，最容易想到的方式自然是暴力递归，DFS来遍历所有可能的分支，时间复杂度为O(2 ^ n)，n为数组数字个数。这道题的输入大小没有超过20，所以2^20勉强在合格范围内，但是依然耗时很长。空间复杂度为O(n)，n也是递归层数。</p><p>时间复杂度：O(2 ^ n)，空间复杂度：O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// recursion DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findWays(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, S);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == end &amp;&amp; (nums[start] == target || nums[start] == <span class="number">0</span> - target)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findWays(nums, start + <span class="number">1</span>, end, target - nums[start]) + findWays(nums, start + <span class="number">1</span>, end, target + nums[start]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DP-记忆化搜索"><a href="#DP-记忆化搜索" class="headerlink" title="DP 记忆化搜索"></a>DP 记忆化搜索</h3><p>我们发现其实我们的重复计算有很多，因为其实对于第i个数而言，它就两种取值方式，正 or 负，前i - 1个数的所有取值种类我们只要算一次就好，不需要正负全算，因此加上一个memo数组，就可以用动态规划来解决了。</p><p>memo[i][j]：当前i个数字和为j时，从i（index为i，实际为第i+1）开始（包括i）后面数字所有排列组合满足target为S的可能性有多少种。<font color=Red>注意！ </font>这里的 j 并不是实际的和，因为我们的和有可能是负值，而下标不能为负，所以实际的和为j - offset，offset是nums所有元素的sum和。</p><p>base case：memo[0][offset] = 1。用0个元素，和为0（j - offset = 0）的方法有一种。</p><p>时间复杂度：O(sum * n)，sum是整体数组的和，因为每个位置上的数字最多被填写一次。</p><p>空间复杂度：O(sum * n)，sum是整体数组的和，大小为memo数组的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DP top-down</span></span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memo.length; i++) &#123;</span><br><span class="line">            Arrays.fill(memo[i], Integer.MIN_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, sum, S, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> sum, <span class="keyword">int</span> total, <span class="keyword">int</span> S, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == S) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[index][sum + total] != Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[index][sum + total];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> add = dfs(nums, sum + nums[index], total, S, index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> substract = dfs(nums, sum - nums[index], total, S, index + <span class="number">1</span>);</span><br><span class="line">            memo[index][sum + total] = add + substract;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> memo[index][sum + total];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DP-bottom-up"><a href="#DP-bottom-up" class="headerlink" title="DP bottom-up"></a>DP bottom-up</h3><p>其实这道题用DP的bottom-up更符合思维一点，因为bottom-up才是正统的DP思想。</p><p>首先我们假设dp[i][j]为前i个数，和为j一共有多少种可能的方式。j有两种选择方式，一种是加上当前的第i个数，另一种是减去当前的第i个数，那么我们可以有如下递推式：</p><p>$$ dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]] $$</p><p>这里要注意，我们的j有可能是负值，实际运算时注意要加上一个offset。</p><p><font color = orange>base case：</font>dp[0][0] = 1</p><p><font color = red>Attention：</font>这里有两种递推方式，push和pull，前者是将自身的值，主动推到下一层，另一种是遍历当前值的时候向上一层去拉，二者思路上是一致的，但是需要注意的是写法，i+1还是i-1之类的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DP bottom-up push</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> offset = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意边界条件的判断！！！</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么这里要length+ 1而上面的top-down就不用呢？因为二者dp表示的含义根本就不同，没有可比性！！上面的top - down只是单纯的记录，而不是递推，需要边界case。</span></span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][offset] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是push类型，由于会推到i+1层，所以这里i的上限要注意</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里j的遍历是因为我们需要对j-nums[i]和j+nums[i]进行查找，所以缩小一下范围，加速遍历过程。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nums[i]; j &lt; <span class="number">2</span> * sum + <span class="number">1</span> - nums[i]; j++) &#123;</span><br><span class="line">                <span class="comment">// 注意这里的dp方式，是推，不是拉！！！</span></span><br><span class="line">                dp[i + <span class="number">1</span>][j + nums[i]] += dp[i][j];</span><br><span class="line">                dp[i + <span class="number">1</span>][j - nums[i]] += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][S + offset];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DP bottom-up pull</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> offset = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意边界条件的判断！！！</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][offset] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是pull类型，因此从i = 1开始遍历，1层从0层去拉</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里j的遍历要注意，我们不是从nums[i]开始计算，而是nums[i - 1]，原因在于nums[i - 1]是第i个数，上一种push解法是从当前推以后，所以是nums[i]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * sum + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + nums[i - <span class="number">1</span>] &lt; <span class="number">2</span> * sum + <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j + nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*这里给出一种错误写法，原因在于这次是向上去拉，拉的时候对于最底层的右边界情况来说，它应该拉的两个数中有一个是合法的，另一个是越界的，对于合法的那个我们应该去加，对于不合法的那个，我们不去加。如果按照下面的写法，则二者都不加了，肯定是错误的。*/</span></span><br><span class="line">            <span class="comment">// for (int j = nums[i - 1]; j &lt; 2 * sum + 1 - nums[i - 1]; j++) &#123;</span></span><br><span class="line">            <span class="comment">//     dp[i][j] += dp[i - 1][j - nums[i - 1]] + dp[i - 1][j + nums[i - 1]]</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][S + offset];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将问题转化为0-1背包问题"><a href="#将问题转化为0-1背包问题" class="headerlink" title="将问题转化为0-1背包问题"></a>将问题转化为0-1背包问题</h3><p>我们假设有P和Q两个集合，P中存放我们设置为正数的数字，Q中我们存放我们设置为负数的数字，因此我们有这样的推导：</p><pre><code>已知：sum(P) - sum(Q) = sum(nums)sum(P) + sum(Q) = target二者相加：sum(P) - sum(Q) + sum(P) + sum(Q) = sum(nums) + target2 * sum(P) = sum(nums) + targetsum(P) = (sum(nums) + target) / 2</code></pre><p>因此，我们将问题转化成了找出所有的正数的集合P，使其的和为 (sum(nums) + target) / 2，这就转变成了一个0-1背包问题。</p><p>我们假设dp[i][j]表示前i个元素的子集可以加和为j的可能性有多少种。那么我们有如下递推式：</p><p>$$ dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]] $$</p><p>我们先用二维数组来表示，然后再将其降维成一维。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((S + sum) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = (S + sum) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>俺么如何把它降至一维呢？因为它每次计算的时候其实只和上一次计算的值有关，所以每次计算的时候，先copy一份出来做个备份，然后在这个备份上进行操作。</p><p>那么为什么直接在备份上操作呢？因为我们i是从小到大遍历的，i + 1里，和为j的可能组合一定包含了i中和为j的可能组合，我们不过是在i的基础上加了一个数而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((S + sum) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = (S + sum) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 注意这里初始化的方式！！！不要新建数组，然后指向dp</span></span><br><span class="line">            <span class="keyword">int</span>[] copy = Arrays.copyOfRange(dp, <span class="number">0</span>, dp.length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] += copy[j - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，这里是target，而不是S！！！</span></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java小tips记录</title>
      <link href="2020/05/31/Java%E5%B0%8Ftips%E8%AE%B0%E5%BD%95/"/>
      <url>2020/05/31/Java%E5%B0%8Ftips%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java代码小知识点总结"><a href="#Java代码小知识点总结" class="headerlink" title="Java代码小知识点总结"></a>Java代码小知识点总结</h1><h2 id="List转Array"><a href="#List转Array" class="headerlink" title="List转Array"></a>List转Array</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：List.toArray(new Object[0])。注意，这种方法只对Object类型有效，换言之，int，char等无法使用。</span></span><br><span class="line">String[] arr = list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：Stream。这种方式可以将Integer的list转为array</span></span><br><span class="line"><span class="keyword">int</span>[] array = list.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：新建array，一个个赋值，最稳健。</span></span><br><span class="line">Integer[] arr = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)) &#123;</span><br><span class="line">    arr[i] = list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array转List"><a href="#Array转List" class="headerlink" title="Array转List"></a>Array转List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：Arrays.asList(arr)。注意：这种方式所返回的List不是我们常用的List，因此最好做一层转换。</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：Collections.addAll(list, arr)</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list, arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：Stream</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.stream(arr).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="Collections-sort和Arrays-sort"><a href="#Collections-sort和Arrays-sort" class="headerlink" title="Collections.sort和Arrays.sort"></a>Collections.sort和Arrays.sort</h2><p>参考：<a href="https://blog.csdn.net/qq_27127145/article/details/83930498">原文链接</a></p><h3 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections.sort()"></a>Collections.sort()</h3><p>其实主要是两种排序：<strong>Collections.sort(List,Comparator)</strong> 和 **List.sort(Comparator)**，其中Comparator可以用lamada表达式代替。</p><p>Attention:</p><ol><li><font color=Red>Comparator不能更改基本类型的比较方式，<strong>只能更改复合类型或者数组类型。</strong></font>数组类型的比较我们可以参考：<a href="/2020/05/31/LeetCode-973-K-Closest-Points-to-Origin/" title="LeetCode 973. K Closest Points to Origin">LeetCode 973. K Closest Points to Origin</a></li><li>比较的时候，如果是stream的方式，不仅可以用两个object的属性比较，还可以使用额外的外面的变量，详情见:<a href="/2020/06/07/LeetCode-1471-The-k-Strongest-Values-in-an-Array/" title="LeetCode 1471. The k Strongest Values in an Array">LeetCode 1471. The k Strongest Values in an Array</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Collections.sort()使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//被排序的集合</span></span><br><span class="line">        List&lt;User&gt; userList = Lists.newArrayList(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>,<span class="number">11</span>),<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. Java8之前，使用匿名内部类的基本排序</span></span><br><span class="line">        Collections.sort(userList, <span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User user1, User user2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> user1.getAge().compareTo(user2.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. Java8,使用Lambda表达式的基本排序</span></span><br><span class="line">        Collections.sort(userList,</span><br><span class="line">                 (User user1, User user2) -&gt;user1.getAge().compareTo(user2.getAge()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//userList.sort((User user1, User user2) -&gt; user1.getAge().compareTo(user2.getAge()));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. Java8,Lambda表达式可以简化，省略定义类型User</span></span><br><span class="line">        userList.sort((user1, user2) -&gt; user1.getAge().compareTo(user2.getAge()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. Java8,Lambda表达式，多条件排序</span></span><br><span class="line">        userList.sort((user1, user2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (user1.getName().equals(user2.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> user1.getAge() - user2.getAge();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> user1.getName().compareTo(user2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. Java8,多条件组合排序</span></span><br><span class="line">        userList.sort(Comparator.comparing(User::getName).thenComparing(User::getAge));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. Java8,提取Comparator进行排序</span></span><br><span class="line">        Collections.sort(userList, Comparator.comparing(User::getName));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. Java8,自定义静态的比较方法来排序(静态方法必须写在被比较的类(这里是User类)中)</span></span><br><span class="line">        userList.sort(User::compareByAgeThenName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8. Java8,反转排序</span></span><br><span class="line">        Comparator&lt;User&gt; comparator = (user1, user2) -&gt; user1.getName().compareTo(user2.getName());</span><br><span class="line">        userList.sort(comparator);<span class="comment">//先按name排序</span></span><br><span class="line">        userList.sort(comparator.reversed());<span class="comment">//反转排序</span></span><br><span class="line">        Assert.assertEquals(userList.get(<span class="number">0</span>),<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>,<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h3><p>Arrays.sort(数组)默认是对数组进行升序排列，它有几种参数形式，这里以int数组为例：</p><ol><li>**Arrays.sort(int[])**：直接从小到大进行排序</li><li>**Arrays.sort(int[], int from, int to)**：在[from,to)区间进行排序，左闭右开</li><li>**Arrays.sort(Integer[], Comparator)**：自定义Comparator排序顺序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Arrays.sort()使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//被排序的字符串数组</span></span><br><span class="line">        String[] months = &#123;<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>,<span class="string">&quot;March&quot;</span>,<span class="string">&quot;April&quot;</span>,<span class="string">&quot;May&quot;</span>,<span class="string">&quot;June&quot;</span>,<span class="string">&quot;July&quot;</span>,<span class="string">&quot;August&quot;</span>,<span class="string">&quot;September&quot;</span>,<span class="string">&quot;October&quot;</span>,<span class="string">&quot;December&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//按字符串长度排序</span></span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        Arrays.sort(months, (a, b) -&gt; Integer.signum(a.length() - b.length()));</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        Arrays.sort(months, Comparator.comparingInt(String::length));</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        Arrays.sort(months, (a, b) -&gt; a.length() - b.length());</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        Arrays.sort(months,</span><br><span class="line">                (String a, String b) -&gt; &#123; <span class="keyword">return</span> Integer.signum(a.length() - b.length()); &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建List数组"><a href="#构建List数组" class="headerlink" title="构建List数组"></a>构建List数组</h2><p>Java不支持泛型数组的建立，那么如果需要ArrayList数组，需要怎么办？需要先建立指向List的n个引用，然后再依次新建对象。</p><p>注意，new后面一定不能带&lt;Integer&gt;之类的参数！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建大顶堆-小顶堆"><a href="#构建大顶堆-小顶堆" class="headerlink" title="构建大顶堆/小顶堆"></a>构建大顶堆/小顶堆</h2><p>Java中PriorityQueue是默认的小顶堆，对于一些复杂的例子，需要自定义Comparator。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建大顶堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2 - o1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="位移符号"><a href="#位移符号" class="headerlink" title="位移符号"></a>位移符号</h2><p>Java中一共有三种位移符号，关于无符号右移，参考题目<a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a>.</p><ol><li>“&gt;&gt;”。表示有符号位移。负数填充1，正数填充0.</li><li>“&lt;&lt;”。表示符号左移，全都填充0.</li><li>“&gt;&gt;&gt;”。表示无符号右移，全部填充0.</li></ol><h2 id="StringBuilder相关"><a href="#StringBuilder相关" class="headerlink" title="StringBuilder相关"></a>StringBuilder相关</h2><h3 id="StringBuilder去除最后一个字符"><a href="#StringBuilder去除最后一个字符" class="headerlink" title="StringBuilder去除最后一个字符"></a>StringBuilder去除最后一个字符</h3><p>参考链接：<a href="https://www.javacodeexamples.com/java-stringbuilder-remove-last-character-example-stringbuffer/2213">传送门</a></p><p>一共有两种方法去除末尾的字符，文章里有写.我们使用后者，setLength函数，因为后者不需要copy。</p><p>1.使用 deleteCharAt(int index) 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure><p>2.使用setLength(int length) 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> newLength)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 630. Course Schedule III</title>
      <link href="2020/05/31/LeetCode-630-Course-Schedule-III/"/>
      <url>2020/05/31/LeetCode-630-Course-Schedule-III/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 210. Course Schedule II</title>
      <link href="2020/05/31/LeetCode-210-Course-Schedule-II/"/>
      <url>2020/05/31/LeetCode-210-Course-Schedule-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/course-schedule/">207. Course Schedule</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>一共有n门课程需要修，分别是从0到n-1。有些课程需要进行先修课程，我们以数组的形式给出，例如：[0, 1]，就是说如果要修课，必须要上过1课。</p><p>现在给出numCourses门课程，和一个prerequisites数组，求给出一种拓扑排序的方式。</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考解法：<a href="https://www.youtube.com/watch?v=M6SBePBMznU">花花酱LeetCode</a></p><p>和<a href="/2020/05/31/LeetCode-207-Course-Schedule/" title="LeetCode 207. Course Schedule">LeetCode 207. Course Schedule</a>类似，基本一致，这里不再赘述，直接上解析。</p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">// BFS</span></span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Stack&lt;Integer&gt; zeroDegreeVertex = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        ArrayList&lt;Integer&gt;[] relations = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            relations[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            inDegree[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">            relations[prerequisite[<span class="number">1</span>]].add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroDegreeVertex.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!zeroDegreeVertex.isEmpty() &amp;&amp; index != numCourses) &#123;</span><br><span class="line">            res[index] = zeroDegreeVertex.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> vertex : relations[res[index]]) &#123;</span><br><span class="line">                inDegree[vertex]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[vertex] == <span class="number">0</span>) &#123;</span><br><span class="line">                    zeroDegreeVertex.push(vertex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS-backtracking"><a href="#DFS-backtracking" class="headerlink" title="DFS + backtracking"></a>DFS + backtracking</h3><h3 id="DFS优化"><a href="#DFS优化" class="headerlink" title="DFS优化"></a>DFS优化</h3>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> back tracking </tag>
            
            <tag> topological sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 207. Course Schedule</title>
      <link href="2020/05/31/LeetCode-207-Course-Schedule/"/>
      <url>2020/05/31/LeetCode-207-Course-Schedule/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/course-schedule/">LeetCode 207. Course Schedule</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>一共有n门课程需要修，分别是从0到n-1。有些课程需要进行先修课程，我们以数组的形式给出，例如：[0, 1]，就是说如果要修课，必须要上过1课。</p><p>现在给出numCourses门课程，和一个prerequisites数组，问是否能有一种修课方式，能够使得孙俪修完n门课程。</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>参考解法：<a href="https://www.youtube.com/watch?v=M6SBePBMznU">花花酱LeetCode</a></p><p>也是一道经典老题目了，拓扑排序的经典问题，这里这道题我们使用BFS，下面这道类似的题目我们来使用DFS，体会一下差别。。<a href="/2020/05/31/LeetCode-210-Course-Schedule-II/" title="LeetCode 210. Course Schedule II">LeetCode 210. Course Schedule II</a></p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>其实所谓的prerequesites数组就是一个有向图，我们需要做的是在这个有向图中寻找是否存在环，如果存在环，则说明不可能存在一个拓扑排序；如果不存在环，则说明存在拓扑排序。</p><p>那么我们如何去查找环呢？两种做法，DFS和BFS，这里我们使用BFS吧。</p><p>BFS寻找拓扑排序的思路如下：</p><pre><code>1. 统计整张图所有vertex的入度（indegree）；2. 找出入度为0的点，放入一个queue或者stack中，无所谓；3. pop或者poll出一个节点作为当前节点，然后将该节点所指向的节点的入度更改，然后将新的入度为0的顶点添加到栈顶或者队列后；4. 重复2和3的操作，直至stack或者queue为空，如果已经遍历完所有节点，那么我们pop的顺序就是一种拓扑序。</code></pre><p>这里只是找是否存在，所以没必要存当前的拓扑序，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite: prerequisites) &#123;</span><br><span class="line">            indegree[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">            graph[prerequisite[<span class="number">1</span>]].add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; zeroIndegrees = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroIndegrees.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; topoSort = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span> (!zeroIndegrees.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = zeroIndegrees.poll();</span><br><span class="line">            topoSort.add(temp);</span><br><span class="line">            <span class="comment">// 减少所有它指向的节点的入度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> vertex : graph[temp]) &#123;</span><br><span class="line">                indegree[vertex]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[vertex] == <span class="number">0</span>) &#123;</span><br><span class="line">                    zeroIndegrees.add(vertex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (topoSort.size() == numCourses);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>对于DFS而言，其实也有多种DFS的方式，例如 DFS + 回溯，我们可以每次从不同节点开始访问，每个节点有两种状态，访问和未访问。然后从0到n-1进行DFS遍历，每次退出的时候将节点重置为false。为什么要这样做呢？因为如果我们不将其重置为false，DFS到某节点若是已访问的状态，我们不知道它是在当前DFS的访问路径中还是说已经完全访问完毕的状态，这样做会导致大量的重复计算，如下实例，可以自行画图查看一下。</p><pre><code>n = 4prerequisites = [[1, 0], [1, 3], [2, 1]]</code></pre><p><font color = 12DBF1>时间复杂度：O(E+ V^2)；E是构建图的时间，V ^ 2是因为最坏情况下是一条线性的课程依赖关系，所以最坏是V ^ 2的复杂度。</p><p>空间复杂度：O(V+ E)；构建图是O(V + E)，isVisited变量是O(V)，最坏情况下我们需要调用V层栈来储存我们递归函数，因此整体是O(3V + E)，也就是O(v + E)。</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">        <span class="keyword">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// build the whole graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite: prerequisites) &#123;</span><br><span class="line">            graph[prerequisite[<span class="number">1</span>]].add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//DFS确认是否有环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (backtrack(graph, isVisited, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(ArrayList&lt;Integer&gt;[] graph, <span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> vertex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isVisited[vertex]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isVisited[vertex] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[vertex]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (backtrack(graph, isVisited, next)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            isVisited[vertex] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS优化"><a href="#DFS优化" class="headerlink" title="DFS优化"></a>DFS优化</h3><p>看到上面的解，我们发现会有很多重复的计算，我们真的需要通过回溯来重置状态么？其实并不是这样，只要我们加一个visiting的状态即可，和unvisited分开，如果发现访问的节点是visiting状态，则说明有环，退出；若是visited，说明完全没问题，当前节点记录后直接返回；unvisited的话就正常DFS，将节点设为visiting再继续。最终结束的时候将此节点设为visited。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">        <span class="keyword">int</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Arrays.fill(isVisited, -<span class="number">1</span>);<span class="comment">// -1 unvisited, 0 visiting, 1 visited</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build the whole graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite: prerequisites) &#123;</span><br><span class="line">            graph[prerequisite[<span class="number">1</span>]].add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DFS确认是否有环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(graph, isVisited, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有环return true，无环return false</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(ArrayList&lt;Integer&gt;[] graph, <span class="keyword">int</span>[] isVisited, <span class="keyword">int</span> vertex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isVisited[vertex] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVisited[vertex] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isVisited[vertex] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[vertex]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(graph, isVisited, next)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            isVisited[vertex] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> back tracking </tag>
            
            <tag> topological sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 973. K Closest Points to Origin</title>
      <link href="2020/05/31/LeetCode-973-K-Closest-Points-to-Origin/"/>
      <url>2020/05/31/LeetCode-973-K-Closest-Points-to-Origin/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/k-closest-points-to-origin/">LeetCode 973. K Closest Points to Origin</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出某二维平面上的一些坐标，例如[1, 2]，找出这些坐标中距离原点最近的K个节点。例如：</p><pre><code>Input: points = [[1,3],[-2,2]], K = 1Output: [[-2,2]]</code></pre><p>Note:</p><pre><code>1 &lt;= K &lt;= points.length &lt;= 10000-10000 &lt; points[i][0] &lt; 10000-10000 &lt; points[i][1] &lt; 10000</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题难倒是不难，思路也很明确，其实主要是考察数据结构的熟悉程度以及API的调用，否则写起来很麻烦。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>首先我们需要记录每个节点与原点的距离，然后进行排序，找出前k个，并把这k个的对应的pair找出来。</p><p>用最笨的办法的话就是用个map记录一下distance和对应的index之间的关系，然后排序结束以后找出前k的distance，然后再从map中找出index，再进行遍历。这个方法很麻烦，而且耗时长。</p><h3 id="使用Arrays-sort方法自定义排序"><a href="#使用Arrays-sort方法自定义排序" class="headerlink" title="使用Arrays.sort方法自定义排序"></a>使用Arrays.sort方法自定义排序</h3><p>我们知道Arrays.sort函数可以默认排序数字类型，但是其更广泛的用法其实是自定义排序任意类型，这点和Collections.sort一个道理。</p><p>详情见：<a href="/2020/05/31/Java%E5%B0%8Ftips%E8%AE%B0%E5%BD%95/" title="Java知识点记录——第一项">Java知识点记录——第一项</a></p><h3 id="使用PriorityQueue自定义比较方式"><a href="#使用PriorityQueue自定义比较方式" class="headerlink" title="使用PriorityQueue自定义比较方式"></a>使用PriorityQueue自定义比较方式</h3><p>同上，只不过queue也是一种List，可以用Comparator来自定义比较方式从而初始化一个小顶堆。这里有两种方式，多种写法。</p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>找top k问题的常见套路，写一个helper函数来找一个合适的mid，其实并不需要全局有序，只要部分有序就可以了。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><h3 id="暴力解法代码"><a href="#暴力解法代码" class="headerlink" title="暴力解法代码"></a>暴力解法代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; distanceMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        List&lt;Integer&gt; distances = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> distance = points[i][<span class="number">0</span>] * points[i][<span class="number">0</span>] + points[i][<span class="number">1</span>] * points[i][<span class="number">1</span>];</span><br><span class="line">            distances.add(distance);</span><br><span class="line">            <span class="keyword">if</span> (!distanceMap.containsKey(distance)) &#123;</span><br><span class="line">                distanceMap.put(distance, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            distanceMap.get(distance).add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(distances);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; K) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = distances.get(index);</span><br><span class="line">            List&lt;Integer&gt; targetIndexes = distanceMap.get(target);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; targetIndexes.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = targetIndexes.get(i);</span><br><span class="line">                res[count][<span class="number">0</span>] = points[x][<span class="number">0</span>];</span><br><span class="line">                res[count][<span class="number">1</span>] = points[x][<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Arrays-sort"><a href="#使用Arrays-sort" class="headerlink" title="使用Arrays.sort()"></a>使用Arrays.sort()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解法1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(points, (point1, point2) -&gt; point1[<span class="number">0</span>] * point1[<span class="number">0</span>] + point1[<span class="number">1</span>] * point1[<span class="number">1</span>] - point2[<span class="number">0</span>] * point2[<span class="number">0</span>] - point2[<span class="number">1</span>] * point2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index &lt; K) &#123;</span><br><span class="line">            res[index] = points[index];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解法2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        Arrays.sort(points, Comparator.comparing(p -&gt; p[<span class="number">0</span>] * p[<span class="number">0</span>] + p[<span class="number">1</span>] * p[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(points, <span class="number">0</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用PriorityQueu-Comparator"><a href="#使用PriorityQueu-Comparator" class="headerlink" title="使用PriorityQueu+Comparator"></a>使用PriorityQueu+Comparator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="comment">// 要大顶堆，所以返回p2 - p1</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;((p1, p2) -&gt; p2[<span class="number">0</span>] * p2[<span class="number">0</span>] + p2[<span class="number">1</span>] * p2[<span class="number">1</span>] - p1[<span class="number">0</span>] * p1[<span class="number">0</span>] - p1[<span class="number">1</span>] * p1[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] p : points) &#123;</span><br><span class="line">            queue.offer(p);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; K) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res[--K] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="comment">// 要大顶堆，所以返回p2 - p1</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;((p1, p2) -&gt; p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>] - p2[<span class="number">0</span>] * p2[<span class="number">0</span>] - p2[<span class="number">1</span>] * p2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        queue.addAll(Arrays.asList(points));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res[--K] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用分治法找top-k"><a href="#使用分治法找top-k" class="headerlink" title="使用分治法找top k"></a>使用分治法找top k</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = points.length - <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = helper(points, l, r);</span><br><span class="line">            <span class="keyword">if</span> (mid == K) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; K) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; K) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(points, <span class="number">0</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pivot = points[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; compare(points[r], pivot)) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            points[l] = points[r];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; compare(pivot, points[l])) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            points[r] = points[l];</span><br><span class="line">        &#125;</span><br><span class="line">        points[l] = pivot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1是否大于p2</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] p1, <span class="keyword">int</span>[] p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>] - p2[<span class="number">0</span>] * p2[<span class="number">0</span>] - p2[<span class="number">1</span>] * p2[<span class="number">1</span>]) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> divide and conquer </tag>
            
            <tag> heap </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 14. Longest Common Prefix</title>
      <link href="2020/05/30/LeetCode-14-Longest-Common-Prefix/"/>
      <url>2020/05/30/LeetCode-14-Longest-Common-Prefix/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/longest-common-prefix/">LeetCode 14. Longest Common Prefix</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一组字符串，找出这些字符串的最长common前缀。</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="水平比较"><a href="#水平比较" class="headerlink" title="水平比较"></a>水平比较</h3><p>首先，最容易想到的思路就是从前往后，一个个进行比较找common suffix，直到找到最后一个字符串。</p><p>这种方法时间复杂度为O(S)，S是所有字符串的字符数总和，最坏情况就是所有字符串相等，一直比较下去。</p><h3 id="垂直比较"><a href="#垂直比较" class="headerlink" title="垂直比较"></a>垂直比较</h3><p>垂直的意思是从第一位开始比较，比较所有的字符串的第一位，如果相同，则比较下一位；如果不同或者到达某字符串的最大长度，则返回当前的suffix。</p><p>这种方法时间复杂度为O(S)，S是所有字符串的字符数总和，最坏情况就是所有字符串相等，一直比较下去。</p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>可以将原本的数组不断拆分成子数组，然后获取子数组的最长公共前缀，然后再进行合并。</p><p>时间复杂度为O(S),空间复杂度为O(m * logn)。空间复杂度是因为我们需要调用函数logn词，每次空间为m。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><h3 id="水平比较-1"><a href="#水平比较-1" class="headerlink" title="水平比较"></a><strong>水平比较</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">                prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prefix.isEmpty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="垂直比较-1"><a href="#垂直比较-1" class="headerlink" title="垂直比较"></a><strong>垂直比较</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length() ; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.length; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c)</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);             </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分治法-1"><a href="#分治法-1" class="headerlink" title="分治法"></a><strong>分治法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soluton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;    </span><br><span class="line">            <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span> , strs.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">            String lcpLeft =   longestCommonPrefix(strs, l , mid);</span><br><span class="line">            String lcpRight =  longestCommonPrefix(strs, mid + <span class="number">1</span>,r);</span><br><span class="line">            <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">commonPrefix</span><span class="params">(String left,String right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(left.length(), right.length());       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( left.charAt(i) != right.charAt(i) )</span><br><span class="line">                <span class="keyword">return</span> left.substring(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.substring(<span class="number">0</span>, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 28. Implement strStr()</title>
      <link href="2020/05/30/LeetCode-28-Implement-strStr/"/>
      <url>2020/05/30/LeetCode-28-Implement-strStr/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/implement-strstr/">LeetCode 28. Implement strStr()</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个字符串haystack和needle，找出needle在haystack中出现的首次位置，如果没有出现则返回-1。needle为空的时候返回0，例如：</p><pre><code>Example 1:Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2Example 2:Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="2-pointers暴力搜索"><a href="#2-pointers暴力搜索" class="headerlink" title="2 pointers暴力搜索"></a>2 pointers暴力搜索</h3><p>两个指针分别指向s1和s2，如果遇到不匹配，则将s2的指针重置，s1指针向后移动一位。</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法的详解可以参考：</p><ol><li><a href="https://www.youtube.com/watch?v=uKr9qIZMtzw&list=PLLuMmzMTgVK5Hy1qcWYZcd7wVQQ1v0AjX&index=3&t=0s">花花酱的KMP算法视频</a></li><li><a href="https://blog.sengxian.com/algorithms/kmp">某大佬的blog</a></li></ol><p>或者这篇字符串汇总的Blog中：<a href="/2020/05/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93/" title="传送门">传送门</a></p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><h3 id="2-pointers"><a href="#2-pointers" class="headerlink" title="2 pointers"></a>2 pointers</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; h) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; h - n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> currLen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; h &amp;&amp; p2 &lt; n &amp;&amp; haystack.charAt(p1) == needle.charAt(p2)) &#123;</span><br><span class="line">                p1++;</span><br><span class="line">                p2++;</span><br><span class="line">                currLen++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currLen == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> p1 - n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p1 = p1 - currLen + <span class="number">1</span>;</span><br><span class="line">                p2 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="KMP字符型匹配算法"><a href="#KMP字符型匹配算法" class="headerlink" title="KMP字符型匹配算法"></a>KMP字符型匹配算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = buildKMPTable(needle);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.length()) &#123;</span><br><span class="line">                <span class="comment">// 这里不一定是要返回，也可以继续搜索，直接记录个什么数，然后j继续跳回去</span></span><br><span class="line">                <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是大重点！！！KMP表的实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] buildKMPTable(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i + <span class="number">1</span>] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 647. Palindromic Substrings</title>
      <link href="2020/05/30/LeetCode-647-Palindromic-Substrings/"/>
      <url>2020/05/30/LeetCode-647-Palindromic-Substrings/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/palindromic-substrings/">LeetCode 647. Palindromic Substrings</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>找出一个字符串的所有回文子字符串数量。例如：</p><pre><code>Input: &quot;aaa&quot;Output: 6Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>思路和LeetCode 5是一样的，都是找回文子字符串，只不过5是找最长的回文子字符串，这里是找所有回文子字符串的数量。</p><p>其实就是相当于每次找到回文字符串的时候count++就OK了，记得在dp[i][i]赋值的时候+1。</p><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>和<a href="/2020/05/30/LeetCode-5-Longest-Palindromic-Substring/" title="“LeetCode 5”">“LeetCode 5”</a>是一样的解析，这里不多做解释了。</p><h3 id="中心扩散法"><a href="#中心扩散法" class="headerlink" title="中心扩散法"></a>中心扩散法</h3><p>这里同理，注意count++的时机。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><h3 id="Dynamic-Programming-bottom-up"><a href="#Dynamic-Programming-bottom-up" class="headerlink" title="Dynamic Programming bottom-up"></a><strong>Dynamic Programming bottom-up</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.length(), count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; ((j - i &lt;= <span class="number">2</span> )|| dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中心扩散法-1"><a href="#中心扩散法-1" class="headerlink" title="中心扩散法"></a><strong>中心扩散法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.length(), count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            count += findPalindrome(s, i, i) + findPalindrome(s, i , i+ <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findPalindrome</span><span class="params">(String s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;=<span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 516. Longest Palindromic Subsequence</title>
      <link href="2020/05/30/LeetCode-516-Longest-Palindromic-Subsequence/"/>
      <url>2020/05/30/LeetCode-516-Longest-Palindromic-Subsequence/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/">LeetCode 516. Longest Palindromic Subsequence</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>找出一个字符串的最长回文子序列。例如：</p><pre><code>Example 1:Input:&quot;bbbab&quot;Output:4One possible longest palindromic subsequence is &quot;bbbb&quot;.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>和它相似的题目还有两道，LeetCode 5 最长回文子字符串和LeetCode 647 回文子字符串。</p><p>这里我们要注意，这里是子序列，而不是子字符串，子字符串是要求连续的，而子序列不是。</p><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>对于求子序列的题目，而且还是最大值的，我们第一反应肯定还是DP，思路和 LeetCode 5 最长回文子字符串 不同的是，dp策略有所改变。</p><p>我们回忆一下，对于5，我们只考虑dp[i][j]的时候，如果s[i] == s[j]，需要考虑dp[i + 1][j - 1]是否是回文字符串，dp[i][j]表示i到j是否是回文子字符串；那么对于这道题来说，如果s[i] == s[j]，则需要将dp[i + 1][j - 1] + 2，其中dp[i][j]表示i到j的最长回文子序列的长度。</p><p>那么如果s[i] != s[j]时，对于5来说，dp[i][j]直接为false；而对于本题来说，是一个int值，dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])。</p><p>base case的情况是dp[i][i] = 1，不需要考虑j - i之类的，因，如果对于j - i = 2的case来说，dp[i + 1][j - 1] = dp[i + 1][i + 1] = 1，可以正常计算的，不受影响；如果 j - i = 1，那么说明两个数挨着，dp[i + 1][j - 1]看似是不合法的，但实际上是0，直接加2也是OK的，所以边界情况无需再考虑。</p><p>所以递推式如下</p><p>\begin{equation}<br>dp[i][j] = dp[i + 1][j - 1] + 2 \text{  if } s[i] = s[j]<br>\end{equation}</p><p>\begin{equation}<br>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) \text{  if } s[i] \neq s[j]<br>\end{equation}</p><p>遍历顺序依旧按照自身喜好来，但是这里依然是和5做同样选择，因为递推式的前项依赖的需求。</p><p>时间复杂度为O(n ^ 2)，空间复杂度也是O(n ^ 2)</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>这里用中心扩散法就明显行不通了，因为是非连续的，怎么扩散嘛，没辙。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><h3 id="Dynamic-Programming-bottom-up"><a href="#Dynamic-Programming-bottom-up" class="headerlink" title="Dynamic Programming bottom-up"></a><strong>Dynamic Programming bottom-up</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = s.length(), longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    longest = Math.max(longest, dp[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 5. Longest Palindromic Substring</title>
      <link href="2020/05/30/LeetCode-5-Longest-Palindromic-Substring/"/>
      <url>2020/05/30/LeetCode-5-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/longest-palindromic-substring/">LeetCode 5. Longest Palindromic Substring</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>找出一个字符串的最长回文子字符串。例如：</p><pre><code>Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>一道经典老题目了，也不分析了，直接背答案吧，和它相似的题目还有两道，<a href="/2020/05/30/LeetCode-516-Longest-Palindromic-Subsequence/" title="“LeetCode 516 最长回文子序列”">“LeetCode 516 最长回文子序列”</a>和<a href="/2020/05/30/LeetCode-647-Palindromic-Substrings/" title="“LeetCode 647 回文子字符串”">“LeetCode 647 回文子字符串”</a>。</p><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>首先，对于这种求最值的问题，第一反应就应该是DP，确实这道题是一个经典的斜着DP的题目。</p><p>我们定义dp[i][j]表示从index为i到j的子字符串是否是回文序列。</p><p>base case是当i == j时，dp[i][j] = true；对于其他的任意一对i和j，如果s[i]和s[j]相同，则只要dp[i + 1][j - 1]为true，dp[i][j]就为true，或者 j - i &lt;= 2 也可满足要求，若 j-i == 1，则是两个相邻的字符，类似于“aa”；如果j - i == 2，则有可能是“aba”这种类型的字符串，也是回文字符串。故有如下递推式</p><p>\begin{equation}<br>dp[i][j] = dp[i + 1][j - 1] || j - i \leq 2 \text{  if } s[i] = s[j]<br>\end{equation}</p><p>\begin{equation}<br>dp[i][j] = false \text{  if } s[i] \neq s[j]<br>\end{equation}</p><p>遍历顺序根据自身喜好来，注意j是要大于i的，所以整张dp表只有一半会被遍历到。而且要注意，当计算dp[i][j]的时候，dp[i + 1][j - 1]必须是已经计算完毕的了，因此建议i从后向前计算，也就是从n - 1开始，到0。然后每次j从i + 1到n - 1.</p><p>时间复杂度为O(n ^ 2)，空间复杂度也是O(n ^ 2)</p><h3 id="中心扩散法"><a href="#中心扩散法" class="headerlink" title="中心扩散法"></a>中心扩散法</h3><p>对于每个回文序列来说，它的特性是镜像对称的，也就是说它存在一个中心点（长度为奇数）或者中轴（长度为偶数）。</p><p>对于0到n - 1中任意一个字符i，它可能是中心点，也可能是在某中轴的左右侧。如果他是中心点，那么从i分别向左右扩散，会找到以i为中心的回文子串，直到两端或者不匹配；如果中轴刚好在它的右侧，那么从i向左和i+1向右出发（包括i和i+1），逐渐找到回文字符串。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><h3 id="Dynamic-Programming-bottom-up"><a href="#Dynamic-Programming-bottom-up" class="headerlink" title="Dynamic Programming bottom-up"></a><strong>Dynamic Programming bottom-up</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.length(), longest = <span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; ((dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) || (j - i &lt;= <span class="number">2</span>))) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; longest) &#123;</span><br><span class="line">                        start = i;</span><br><span class="line">                        end = j;</span><br><span class="line">                        longest = j - i + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中心扩散法-1"><a href="#中心扩散法-1" class="headerlink" title="中心扩散法"></a><strong>中心扩散法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLongest = Math.max(findPalindrome(s, i, i),findPalindrome(s, i, i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (currentLongest &gt; longest) &#123;</span><br><span class="line">                longest = currentLongest;</span><br><span class="line">                start = i - (longest - <span class="number">1</span>)/ <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + longest);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findPalindrome</span><span class="params">(String s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;=<span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串总结</title>
      <link href="2020/05/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93/"/>
      <url>2020/05/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="String总结"><a href="#String总结" class="headerlink" title="String总结"></a>String总结</h1><h2 id="String常用api"><a href="#String常用api" class="headerlink" title="String常用api"></a>String常用api</h2><table><thead><tr><th>方法</th><th>String</th></tr></thead><tbody><tr><td>增</td><td><strong>String concat(String str):</strong> 将指定字符串连接到此字符串的结尾。（不建议使用）</td></tr><tr><td>删</td><td>字符串不能随便删，trim除外，放到下面部分了。</td></tr><tr><td>改</td><td><strong>char[] toCharArray()：</strong> 将此字符串转换为一个新的字符数组。<br><br><strong>String substring(int beginIndex)：</strong> 返回一个新的字符串，从beginIndex到结尾，它是此字符串的一个子字符串。<br><br><strong>String substring(int beginIndex, int endIndex)</strong>: 返回一个新的字符串，下标从beginIndex到endIndex - 1，是一个左闭右开的区间，它是此字符串的一个子字符串。<br><br><strong>String trim():</strong> 返回字符串的副本，忽略前导空白和尾部空白。<br><br><strong>String toUpperCase():</strong> 将此 String 中的所有字符都转换为大写。<br><br><strong>String toLowerCase():</strong> 将此 String 中的所有字符都转换为小写。<br><br><strong>String replace(char oldChar, char newChar)：</strong> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。<br><br><strong>String replaceAll(String regex, String replacement)：</strong> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。<br><br><strong>String replaceFirst(String regex, String replacement)：</strong>使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td></tr><tr><td>查</td><td><strong>int length():</strong> 返回此字符串的长度。int indexOf(int ch) <br><br> <strong>char charAt(int index)**：返回指定索引处的 char 值 <br> <br>**int indexOf(int ch, int fromIndex)</strong>: 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索（包含），没有则返回-1。<br><br> <strong>int indexOf(String str):</strong>  返回指定子字符串在此字符串中第一次出现处的索引，没有则-1。<br><br> <strong>int indexOf(String str, int fromIndex):</strong> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始，没有则-1。<br><br><strong>int lastIndexOf(int ch):</strong> 返回指定子字符在此字符串中最右边出现处的索引，没有则-1。<br><br><strong>int lastIndexOf(int ch, int fromIndex):</strong> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索，没有则-1。 <br><br><strong>int lastIndexOf(String str):</strong> 返回指定子字符串在此字符串中最右边出现处的索引，没有则-1。<br><br><strong>int lastIndexOf(String str, int fromIndex):</strong>  返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索，没有则-1。 <br><br><strong>boolean startsWith(String prefix, int toffset):</strong> 测试此字符串从指定索引开始的子字符串是否以指定前缀开始，offset是空出字符的数量，也是开始查找的index。<br><br><strong>boolean startsWith(String prefix):</strong>  测试此字符串是否以指定的前缀开始。</td></tr></tbody></table><h2 id="String经典算法"><a href="#String经典算法" class="headerlink" title="String经典算法"></a>String经典算法</h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法是用于字符串匹配的经典算法，但是实现起来比较复杂，故不推荐使用而已，它的最坏时间复杂度是O(m + n)，m和n分别是待匹配字符串和目标字符串的长度。</p><p>KMP算法解释起来很麻烦，可以结合以下资料来观看（因为懒得画图，这里需要很土图示来解释）：</p><ol><li><a href="https://www.youtube.com/watch?v=uKr9qIZMtzw&list=PLLuMmzMTgVK5Hy1qcWYZcd7wVQQ1v0AjX&index=3&t=0s">花花酱的KMP算法视频</a></li><li><a href="https://blog.sengxian.com/algorithms/kmp">某大佬的blog</a></li></ol><p>其实它的核心思想就是对于某次错误的字符串匹配后，不要再进行重新从头匹配，而是跳转到某个合适的位置。例如：</p><pre><code>s1: &quot;aaaabababba&quot;s2: &quot;ababb&quot;希望在s1中找到s2首次出现的位置</code></pre><p>假设我们某次匹配到了s1字符串的子串，aaa<font color=Red>ababa</font>bba，和s2的(ababb)只差了一位，按照传统做法，我们这时候会将s1的指针右移一位，然后重新开始匹配。</p><p>但是我们细心一点可以发现，s1红色的那个子串，最后不匹配的a的前面有ab，而ab又恰好是s2的开头两个字符，也就是说我们可以从s2的第三位开始比较起来，也就是说我们下一个希望比较的s1的子字符串是aaaab<font color=Red>ababb</font>a，我们可以发现刚好符合条件；如果使用老的方法则是将s1的pointer右移一位，比较babab和s2，KMP算法可以直接跨越这一步。这就是KMP算法的核心思想。</p><p>KMP算法实现：</p><a href="/2020/05/30/LeetCode-28-Implement-strStr/" title="LeetCode 28. Implement strStr()">LeetCode 28. Implement strStr()</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="String经典题目汇总"><a href="#String经典题目汇总" class="headerlink" title="String经典题目汇总"></a>String经典题目汇总</h2><h3 id="回文系列"><a href="#回文系列" class="headerlink" title="回文系列"></a>回文系列</h3><ol><li><a href="https://leetcode.com/problems/valid-palindrome/">125. Valid Palindrome(无解析)</a></li><li><a href="/2020/05/30/LeetCode-5-Longest-Palindromic-Substring/" title="最长回文子字符串">最长回文子字符串</a></li><li><a href="/2020/05/30/LeetCode-516-Longest-Palindromic-Subsequence/" title="“LeetCode 516 最长回文子序列”">“LeetCode 516 最长回文子序列”</a></li><li><a href="/2020/05/30/LeetCode-647-Palindromic-Substrings/" title="“LeetCode 647 回文子字符串数”">“LeetCode 647 回文子字符串数”</a> </li></ol><h3 id="最长common前缀"><a href="#最长common前缀" class="headerlink" title="最长common前缀"></a>最长common前缀</h3><ol><li><a href="/2020/05/30/LeetCode-5-Longest-Palindromic-Substring/" title="LeetCode 14. Longest Common Prefix">LeetCode 14. Longest Common Prefix</a></li></ol><h3 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h3><ol><li><a href="https://leetcode.com/problems/reverse-string/">LeetCode 344. Reverse String(无解析)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 总结 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 338. Counting Bits</title>
      <link href="2020/05/28/LeetCode-338-Counting-Bits/"/>
      <url>2020/05/28/LeetCode-338-Counting-Bits/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/counting-bits/">LeetCode 338. Counting Bits</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个非负整数num，计算从0到num每个数字二进制表示中1的个数，并以数组形式返回。</p><pre><code>Input: 5Output: [0,1,1,2,1,2]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>首先最暴力的解法肯定是每次向右移动一位，计算当前数字除以2的余数是多少，然后加和。</p><h3 id="暴力解法（进阶版）"><a href="#暴力解法（进阶版）" class="headerlink" title="暴力解法（进阶版）"></a>暴力解法（进阶版）</h3><p>比如说对于32，二进制表示为“100000”，需要移动5次，计算6次，这很明显是不合理的嘛，因此就用到了一个十分巧妙的方法去掉末尾的0。</p><p>$$n = n &amp; (n - 1)$$</p><p>以32举例，31的二进制表示是“11111”，和32做&amp;操作后，n变为0，将从右至左第一个1给消除掉了，减少了很多不必要的运算。</p><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>这种方法比较巧妙，我们其实可以找规律。我们假设从1找到8的二进制写法：</p><pre><code>0 -&gt;    01 -&gt;    12 -&gt;   103 -&gt;   114 -&gt;  1005 -&gt;  1016 -&gt;  1107 -&gt;  1118 -&gt; 1000</code></pre><p>我们找一下规律，从4到7，不外乎就是把0、1、2、3四个数的二进制数前面加个1，多了一个1；我们可以想象，从8到15，也就是比从0到7每个数多了一个1，因此我们用一个lower变量表示比8小的每个数的1的个数，当到达下一个节点时，更新lower为1.</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><h3 id="Dynamic-Programming-1"><a href="#Dynamic-Programming-1" class="headerlink" title="Dynamic Programming"></a><strong>Dynamic Programming</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> pow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lower = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == pow) &#123;</span><br><span class="line">                pow = pow &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                res[i] = <span class="number">1</span>;</span><br><span class="line">                lower = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = res[lower] + <span class="number">1</span>;</span><br><span class="line">                lower++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="暴力解法进阶版"><a href="#暴力解法进阶版" class="headerlink" title="暴力解法进阶版:"></a><strong>暴力解法进阶版:</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            result[i] = fastCountBits(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fastCountBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; num != <span class="number">0</span>; i++) &#123;</span><br><span class="line">            num = num &amp; (num - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> bit manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 138. Copy List with Random Pointer</title>
      <link href="2020/05/28/LeetCode-138-Copy-List-with-Random-Pointer/"/>
      <url>2020/05/28/LeetCode-138-Copy-List-with-Random-Pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/">LeetCode 138. Copy List with Random Pointer</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的 深拷贝。</p><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</p><p>Examples：</p><img src="/images/leetcode138.png" width="150" height="100" /><pre><code>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="哈希表（要绕个弯）"><a href="#哈希表（要绕个弯）" class="headerlink" title="哈希表（要绕个弯）"></a>哈希表（要绕个弯）</h3><p>首先，这道题的难点在于那个random指针，我们根本无从知晓这个random究竟会指向哪个节点，究竟是已经被我们创建还是未被我们创建。而且每个节点的value值与自己的index顺序也不是对应的，所以不能用传统的数组寻址的方式，而是hashmap。</p><p>对于每个节点，我们用原始的node作为key，新建的node作为value，这样，我们只需要先从前向后遍历一次创建所有节点，再从前向后将所有的next和random指向对应节点即可。</p><h3 id="O-1-空间复杂度的方法"><a href="#O-1-空间复杂度的方法" class="headerlink" title="O(1)空间复杂度的方法"></a>O(1)空间复杂度的方法</h3><p>可以对原链表进行修改，解法见：<a href="https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1)-and-linear-time-complexity-O(N)">传送门</a></p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p><strong>HashMap</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Map&lt;Node, Node&gt; clone = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Node ptr = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create all nodes</span></span><br><span class="line">        <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            clone.put(ptr, <span class="keyword">new</span> Node(ptr.val));</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make the next and random pointer to the pright place</span></span><br><span class="line">        ptr = head;</span><br><span class="line">        <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node node = clone.get(ptr);</span><br><span class="line">            node.next = clone.get(ptr.next);</span><br><span class="line">            node.random = clone.get(ptr.random);</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone.get(head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> hash table </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 133. Clone Graph</title>
      <link href="2020/05/28/LeetCode-133-Clone-Graph/"/>
      <url>2020/05/28/LeetCode-133-Clone-Graph/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/">LeetCode 138. Copy List with Random Pointer</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出<strong>无向连通图</strong>中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例格式：</p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。</p><p>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。必须将 给定节点的拷贝 作为对克隆图的引用返回。</p><p>Examples：<br><img src="/images/leetcode133.png" alt="Example" title="Example"></p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题和<a href="/2020/05/28/LeetCode-138-Copy-List-with-Random-Pointer/" title="LeetCode 138. Copy List with Random Pointer">LeetCode 138. Copy List with Random Pointer</a>是基本一致的，稍微有所变形，而且涉及到DFS和BFS。</p><p>目前的困境是一样的，我们每次在创建节点后，对neighbor进行遍历时，无法直接找到对应的节点，依然用hashMap来存储是比较直接的方式。</p><h3 id="哈希表-DFS"><a href="#哈希表-DFS" class="headerlink" title="哈希表+DFS"></a>哈希表+DFS</h3><h3 id="哈希表-BFS"><a href="#哈希表-BFS" class="headerlink" title="哈希表+BFS"></a>哈希表+BFS</h3><h3 id="双队列-DFS"><a href="#双队列-DFS" class="headerlink" title="双队列+DFS"></a>双队列+DFS</h3><h3 id="O-1-空间复杂度的方法"><a href="#O-1-空间复杂度的方法" class="headerlink" title="O(1)空间复杂度的方法"></a>O(1)空间复杂度的方法</h3><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><h3 id="HashMap-DFS"><a href="#HashMap-DFS" class="headerlink" title="HashMap + DFS"></a><strong>HashMap + DFS</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = new ArrayList&lt;Node&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = new ArrayList&lt;Node&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, ArrayList&lt;Node&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Node, Node&gt; clone = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clone.containsKey(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span> clone.get(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">        clone.put(node, newNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : node.neighbors) &#123;</span><br><span class="line">            newNode.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-BFS"><a href="#HashMap-BFS" class="headerlink" title="HashMap + BFS"></a><strong>HashMap + BFS</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Node, Node&gt; clone = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        clone.put(node, newNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node temp = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (Node neighbor : temp.neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!clone.containsKey(neighbor)) &#123;</span><br><span class="line">                    clone.put(neighbor, <span class="keyword">new</span> Node (neighbor.val));</span><br><span class="line">                    queue.offer(neighbor));</span><br><span class="line">                &#125;</span><br><span class="line">                clone.get(temp).neighbors.add(clone.get(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双Queue"><a href="#双Queue" class="headerlink" title="双Queue"></a><strong>双Queue</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">// 这种双queue的做法一开始不行，原因在于，每次BFS遍历到一个老节点时，遍历其neighbors，对于我们copy的那个节点，我们没办法从newQueue里面获取到，所以不能用简单的isVisited的boolean数组来替代，而是用Node数组来访问。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node[] allNodes = <span class="keyword">new</span> Node[<span class="number">101</span>];</span><br><span class="line">        Arrays.fill(allNodes, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Queue&lt;Node&gt; oldQueue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        Queue&lt;Node&gt; newQueue = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        oldQueue.offer(node);</span><br><span class="line">        Node ret = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">        newQueue.offer(ret);</span><br><span class="line">        allNodes[<span class="number">1</span>] = ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!oldQueue.isEmpty()) &#123;</span><br><span class="line">            Node oldOne = oldQueue.poll();</span><br><span class="line">            Node newOne = newQueue.poll();</span><br><span class="line">            <span class="keyword">for</span> (Node neighbor : oldOne.neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allNodes[neighbor.val] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Create new node.</span></span><br><span class="line">                    Node newNode = <span class="keyword">new</span> Node(neighbor.val);</span><br><span class="line">                    allNodes[neighbor.val] = newNode;</span><br><span class="line">                    oldQueue.offer(neighbor);</span><br><span class="line">                    newQueue.offer(newNode);</span><br><span class="line">                &#125;</span><br><span class="line">                newOne.neighbors.add(allNodes[neighbor.val]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
            <tag> bfs </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1042. Flower Planting With No Adjacent</title>
      <link href="2020/05/28/LeetCode-1042-Flower-Planting-With-No-Adjacent/"/>
      <url>2020/05/28/LeetCode-1042-Flower-Planting-With-No-Adjacent/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/flower-planting-with-no-adjacent/">LeetCode 1042. Flower Planting With No Adjacent</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出N个花园(1…N)，给出花园中的路径paths，每个花园最多有三条连通路径。一共可以种四种花(1, 2, 3, 4)，每条路径两段的花的种类不能一致，给出一种符合条件的解。</p><pre><code>Input: N = 3, paths = [[1,2],[2,3],[3,1]]Output: [1,2,3]</code></pre><p>条件限制：</p><pre><code>1 &lt;= N &lt;= 100000 &lt;= paths.size &lt;= 20000No garden has 4 or more paths coming into or leaving it.It is guaranteed an answer exists.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题很多人点了不喜欢，一开始我也没做出来，看了解析之后才发现是自己想复杂了。</p><p>和二分图不同，这里像是四分图，且保证一定有解，这里不是非黑即白的选择，例如和1连通的有2，3，和4，我们假设四种颜色为红黄蓝白，1为红色，2、3、4可选的颜色种类太多了，如果都为黄色，那么遍历到[2, 3]这条路径的时候，我们又发现不行，不能都为黄色，又需要调整，容易陷入怪圈。</p><p>我们细心点可以发现这里有一个条件是每个花园<strong>最多有三条路径</strong>相连，也就是说每个花园一定能够被赋予某种颜色，而不会有冲突，一定存在解，所以现在的问题就在于如何找这种解法。</p><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>稍微再想一想，我们完全没必要关心邻居究竟是怎么样的颜色分布，只要当前节点的颜色符合规定不就Ok了嘛，题中都保证一定有解了。</p><p>对于此题，我们需要先将整个图给遍历出来，然后，对于每个顶点，我们遍历其neighbors，找到其邻居的所有染色，然后随便选一种尚未出现的颜色对当前节点上色即可。</p><p>因此这是一种保证当前节点和之前节点最优解的方法，可以认为是贪心法。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这里同样要注意ArrayList数组的初始化方法，不能使用List[]作为数组，因为List是抽象接口，不能这么做，需要用ArrayList。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p><strong>Greedy</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] gardenNoAdj(<span class="keyword">int</span> N, <span class="keyword">int</span>[][] paths) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        Arrays.fill(res, <span class="number">0</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[N];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] path : paths) &#123;</span><br><span class="line">            graph[path[<span class="number">0</span>] - <span class="number">1</span>].add(path[<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            graph[path[<span class="number">1</span>] - <span class="number">1</span>].add(path[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[i]) &#123;</span><br><span class="line">                color[res[neighbor]] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (color[j] != <span class="number">1</span>) &#123;</span><br><span class="line">                    res[i] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> greedy </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 785. Is Graph Bipartite?</title>
      <link href="2020/05/28/LeetCode-785-Is-Graph-Bipartite/"/>
      <url>2020/05/28/LeetCode-785-Is-Graph-Bipartite/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/is-graph-bipartite/">LeetCode 785. Is Graph Bipartite?</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个图，判断这个图是否为二分图。</p><pre><code>Example 2:Input: [[1,2,3], [0,2], [0,1,3], [0,2]]Output: falseExplanation: The graph looks like this:0----1| \  ||  \ |3----2We cannot find a way to divide the set of nodes into two independent subsets.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>基础的染色二分图问题，但是要注意，对于整张图而言，它可能不是连通图，而是分为多个子图的，所以不能只遍历一种。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p><strong>DFS</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        <span class="comment">// -1是未染色，0是红色，1是黑色</span></span><br><span class="line">        Arrays.fill(color, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">                color[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!dfs(graph, i, color)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> index, <span class="keyword">int</span>[] color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[index].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[graph[index][i]] == -<span class="number">1</span>) &#123;</span><br><span class="line">                color[graph[index][i]] = color[index] ^ <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[graph[index][i]] != color[index] ^ <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BFS</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        Arrays.fill(color, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里for循环是因为这里也可能是非连通图，再判断是否遍历过，如果遍历过则跳过；</span></span><br><span class="line">            <span class="comment">// 没有则说明到了新的一个连通图</span></span><br><span class="line">            <span class="keyword">if</span> (color[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">                Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                color[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[node].length; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (color[graph[node][j]] == -<span class="number">1</span>) &#123;</span><br><span class="line">                            color[graph[node][j]] = color[node] ^ <span class="number">1</span>;</span><br><span class="line">                            queue.offer(graph[node][j]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[graph[node][j]] == color[node]) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 886. Possible Bipartition</title>
      <link href="2020/05/28/LeetCode-886-Possible-Bipartition/"/>
      <url>2020/05/28/LeetCode-886-Possible-Bipartition/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/possible-bipartition/">LeetCode 886. Possible Bipartition</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出n个人，编号从(1…n)，我们可以将他们分成任意大小的两组，但是他们之间会有讨厌某些人的关系，那么他们就不用管被分到同一个组里。</p><p>用公式化的形式来讲，就是如果dislikes[i] = [a, b]，那么a和b就不会被分到同一个组里。我们需要判断能否做到合适的分组，满足所有dislike条件。</p><pre><code>Input: N = 4, dislikes = [[1,2],[1,3],[2,4]]Output: trueExplanation: group1 [1,4], group2 [2,3]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>经典的二分图算法，和785是一样的，只不过本题需要先把整张dislike图给construct出来。染色，然后判断是否ok。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>首先将整张dislike图build出来，因为我们并不知道每个人究竟有多少个dislike的对象，所以可以用ArrayList的数组来存储。这里需要注意ArrayList数组的初始化问题！！！ArrayList数组应该这样初始化，注释中的做法不可用！！！</p><p>原因在于foreach不能用于元素赋值或初始化，而是将数组中元素copy一份给临时变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt;[] dislikeGraph = <span class="keyword">new</span> ArrayList[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for (List&lt;Integer&gt; list : dislikeGraph) &#123;</span></span><br><span class="line"><span class="comment">//     list = new ArrayList();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    dislikeGraph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p><strong>DFS</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意List数组的创建！！！</span></span><br><span class="line">        ArrayList&lt;Integer&gt;[] dislikeGraph = <span class="keyword">new</span> ArrayList[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dislikeGraph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dislike : dislikes) &#123;</span><br><span class="line">            dislikeGraph[dislike[<span class="number">0</span>]].add(dislike[<span class="number">1</span>]);</span><br><span class="line">            dislikeGraph[dislike[<span class="number">1</span>]].add(dislike[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DFS, -1是未访问，0是red，1是black</span></span><br><span class="line">        <span class="keyword">int</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(isVisited, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isVisited[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里给上的颜色，如果已经遍历过，有颜色，则说明该节点没问题，跳过即可</span></span><br><span class="line">            isVisited[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(dislikeGraph, isVisited, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] dislikeGraph, <span class="keyword">int</span>[] isVisited, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : dislikeGraph[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isVisited[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">                isVisited[i] = isVisited[index] ^ <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!dfs(dislikeGraph, isVisited, i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVisited[i] != (isVisited[index] ^ <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BFS：</strong><br>下次看到这里再留着练手吧</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图算法总结</title>
      <link href="2020/05/28/%E5%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>2020/05/28/%E5%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>顶点</li><li>顶点的度</li><li>边</li><li>相邻</li><li>环</li><li>完全图: 所有顶都相邻</li><li>二分图: 对于一个图G, V(G)=X∪Y, X∩Y=∅, X中, Y 中任两顶不相邻</li><li>路径</li><li>圈</li></ul><h2 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h2><p>两种，紧接矩阵和邻接表，如下。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><h1 id="图的相关问题"><a href="#图的相关问题" class="headerlink" title="图的相关问题"></a>图的相关问题</h1><p>其实对于很多非图的问题，也是可以把其看做图的，使用图遍历的方式其进行遍历。例如 <a href="https://leetcode.com/problems/copy-list-with-random-pointer/">LeetCode 138. Copy List with Random Pointer</a>，以图遍历的方式遍历链表；又或者是jump game III，将数组用图遍历的方式展现出来。</p><h2 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>用Queue来遍历吧，先写个样例，以邻接表为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟一下，假设给出所有的边，然后重新construct一个图，进行bfs，例如[2,3]就表示2和3之间存在一条边。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 注意！！！ 这里的BFS是考虑连通图的情况下，如果是非连通图，则在while循环外面再套一层for循环。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span>[][] edges, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将边构建成邻接表，用arrayList数组存储</span></span><br><span class="line">    ArrayList&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        graph[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">        graph[edge[<span class="number">1</span>]].add(edge[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS遍历</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    queue.add(<span class="number">1</span>);</span><br><span class="line">    isVisited[<span class="number">1</span>] = <span class="keyword">true</span>; <span class="comment">// 将初始设为已经遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> node = queue.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[node].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[graph[node].get(i)]) &#123;</span><br><span class="line">                doSomething();</span><br><span class="line">                isVisited[graph[node].get(i)] = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(graph[node.get[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>一般情况下是递归调用DFS较多。而且需要注意的是！！！</p><p><font color=Red>Attention:</font> DFS遍历时也要注意preorder还是postorder遍历（有向图的情况下要注意），前者是先遍历当前节点，再去遍历neighbor；后者是先遍历neighbor，再遍历自身。为什么无向图不需要考虑postorder的可能呢？因为无向图都是双向的，如果一个无向图存在环，那么postorder就会引起无限循环，所以对于无向图，都是preorder。</p><p>那么对于有向图的postorder遍历有什么区别呢？如果都是在遍历完neighbor以后才将其置为visited的话，那么一旦存在一个有向环，就会无限循环的，和postorder一个道理，跟无向图没有postorder遍历一个道理。因此，我们就需要设置三种状态，unvisited，visiting和visited，当遇到unvisited的时候，我们继续DFS；发现visiting节点，则说明存在环；发现visited节点，则返回，因为已经遍历过了。</p><p>下面遍历方式都是对于无向图，有向图的遍历参考：LeetCode 207，最经典的就是拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *这里用二维数组的邻接表来表示整个图，vertex即为顶点id，和数组的顺序一致，从0开始。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDFS</span><span class="params">(<span class="keyword">int</span>[][] graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        Arrays.fill(isVisited, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里有可能是非连通图，对于不同的节点都要尝试。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isVisited[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(graph, i, isVisited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> vertex, <span class="keyword">boolean</span> isVisited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[i].length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果邻居未被访问，则遍历邻居节点</span></span><br><span class="line">        <span class="keyword">if</span> (isVisited[graph[vertex][i]] == <span class="keyword">false</span>) &#123;</span><br><span class="line">            isVisited[graph[vertex][i]] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(graph, graph[vertex][i], isVisited);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVisited[graph[vertex][i]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历到一条路径的终点了，做点啥或者直接返回？</span></span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>二分图的问题本质上是相当于染色问题，有点像红黑树的感觉。如果能够顺利将整个图染成2种不同颜色，则是二分图，否则不是。实现可以用BFS或DFS均可，下面是三个例题链接。</p><ol><li><a href="/2020/05/28/LeetCode-785-Is-Graph-Bipartite/" title="LeetCode-785-Is-Graph-Bipartite">LeetCode-785-Is-Graph-Bipartite</a></li><li><a href="/2020/05/28/LeetCode-886-Possible-Bipartition/" title="LeetCode 886. Possible Bipartition">LeetCode 886. Possible Bipartition</a></li><li><a href="/2020/05/28/LeetCode-1042-Flower-Planting-With-No-Adjacent/" title="LeetCode-1042-Flower-Planting-With-No-Adjacent">LeetCode-1042-Flower-Planting-With-No-Adjacent</a></li></ol><h2 id="深拷贝图"><a href="#深拷贝图" class="headerlink" title="深拷贝图"></a>深拷贝图</h2><ol><li><a href="/2020/05/28/LeetCode-138-Copy-List-with-Random-Pointer/" title="LeetCode 138. Copy List with Random Pointer">LeetCode 138. Copy List with Random Pointer</a></li><li><a href="/2020/05/28/LeetCode-133-Clone-Graph/" title="LeetCode 133. Clone Graph">LeetCode 133. Clone Graph</a></li></ol><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h1 id="判断环"><a href="#判断环" class="headerlink" title="判断环"></a>判断环</h1><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><h1 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h1><h1 id="欧拉路径"><a href="#欧拉路径" class="headerlink" title="欧拉路径"></a>欧拉路径</h1><h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 总结 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 525. Contiguous Array</title>
      <link href="2020/05/27/LeetCode-525-Contiguous-Array/"/>
      <url>2020/05/27/LeetCode-525-Contiguous-Array/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/contiguous-array/">LeetCode 525. Contiguous Array</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个二进制数组，由0和1组成，找出最长的子数组，使得里面的0和1的数量相等。例如：</p><pre><code>Example 1:Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题的思路很特别，我们需要记录一下。在这里将1看做是1，0看做是-1，然后我们记录前缀和（prefix sum），将每次前缀和都记录下来，如果发现有重复的前缀和，那么上一次出现的前缀和的位置到当前位置中0和1的数量应该是相等的，且我们只需要记录第一次出现的前缀和即可。</p><h3 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSum = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">// 注意，这里要预先放一个sum为0的值，要不然后面计算和为0的时候会少算。</span></span><br><span class="line">        prefixSum.put(<span class="number">0</span> , -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!prefixSum.containsKey(sum)) &#123;</span><br><span class="line">                prefixSum.put(sum, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = Math.max(res, i - prefixSum.get(sum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 74. Search a 2D Matrix</title>
      <link href="2020/05/27/LeetCode-74-Search-a-2D-Matrix/"/>
      <url>2020/05/27/LeetCode-74-Search-a-2D-Matrix/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/search-a-2d-matrix/">LeetCode 74. Search a 2D Matrix</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>写出一个函数来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><pre><code>1. 每行中的整数从左到右按升序排列。2. 每行的第一个整数大于前一行的最后一个整数。Input:matrix = [[1,   3,  5,  7],[10, 11, 16, 20],[23, 30, 34, 50]]target = 3Output: true</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><p>这道题的矩阵其实是一个完全有序的矩阵，有两种做法：第一种是先找行数，在找列数；第二种做法是只做一次二分查找，l = 0，r = m * n - 1，然后通过算式来计算middle的横纵坐标来进行下一步计算。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p><strong>1.分别计算横纵坐标</strong>：需要注意的是第一次查找完以后，如果发现这个数比全局最小都小，也就是l = 0，则直接返回-1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两次二分，先确定行，再确定列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length, row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] &gt; target || matrix[m - <span class="number">1</span>][n - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确定行，这里是要找右边界，也就是小于等于target的最大的那个队首。</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        row = l;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确定列，这里是找出最准确的那个数，左右边界无所谓</span></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matrix[row][l] == target;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>一次计算二分搜索</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binary search</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">      pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">      <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索</title>
      <link href="2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
      <url>2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><p>这里有一篇总结二分搜索非常好的Blog，链接贴在这，一定要看！！</p><p><a href="https://www.cnblogs.com/grandyang/p/6854825.html">传送门</a></p><h2 id="一-二分搜索基本应用场景"><a href="#一-二分搜索基本应用场景" class="headerlink" title="一. 二分搜索基本应用场景"></a>一. 二分搜索基本应用场景</h2><p>当一道题目出现了“有序N维数组中查找某个东西或最接近的值”时，大概率用二分搜索；或者输入的数字特别大，达到2^31 - 1左右的这种，也很有可能使用二分搜索。</p><p>其核心思想就是每次找一半，然后舍弃另一半，其中最恶心的莫过于有重复数字的二分搜索，太难顶了。例如：<a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">LeetCode 81</a>的“Search in Rotated Sorted Array II”，到现在也不懂，真的难受，先记录着，等以后能搞懂了再回来看。</p><h2 id="二-二分搜索模板"><a href="#二-二分搜索模板" class="headerlink" title="二. 二分搜索模板"></a>二. 二分搜索模板</h2><h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><p>关于查找区间的问题，究竟是“左闭右开”还是“左右闭区间”，我在这里直接就用左右全闭区间的方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">g</span><span class="params">(m)</span> </span>== target :</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="function"><span class="keyword">if</span> <span class="title">g</span><span class="params">(m)</span> &gt; target :</span></span><br><span class="line"><span class="function">        r </span>= m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="function"><span class="keyword">if</span> <span class="title">g</span><span class="params">(m)</span> &lt; target :</span></span><br><span class="line"><span class="function">        l </span>= m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终返回的时候，l一定是r右面的那个数，这是由while的循环条件决定的，二者最后只能差1。最后看情况是需要l还是r。</p><h3 id="左边界-amp-右边界"><a href="#左边界-amp-右边界" class="headerlink" title="左边界 &amp; 右边界"></a>左边界 &amp; 右边界</h3><p>参考题目：下面例题 3.4 <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode 34. Find First and Last Position of Element in Sorted Array</a></p><p>关于左边界和右边界的问题只要简单说一下就懂了，举个例子，我们有一个数组nums：[1, 2, 6, 6, 10, 13, 17]，我们想要找出数字6所在的位置，那么我们返回2还是返回3呢？虽然值是不同，但是对于实际应用的时候有很大不同。</p><p>比如说对于查找的时候，可能需要查找大于某个数的最小值，或者小于某个数的最大值，前者就是要找右边界，后者就是要找左边界(这里不敢保证写的绝对对啊，只是个人理解，有可能是错的)。</p><p>对于左右边界的处理其实不同点就在于等于的情况下，是更新left还是right。</p><p>左边界 -&gt; 等于的时候更新右边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">g</span><span class="params">(m)</span> &gt;</span>= target :</span><br><span class="line">        r = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="function"><span class="keyword">if</span> <span class="title">g</span><span class="params">(m)</span> &lt; target :</span></span><br><span class="line"><span class="function">        l </span>= m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右边界 -&gt; 等于的时候更新左边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">g</span><span class="params">(m)</span> &gt; target :</span></span><br><span class="line"><span class="function">        r </span>= m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="function"><span class="keyword">if</span> <span class="title">g</span><span class="params">(m)</span> &lt;</span>= target :</span><br><span class="line">        l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回l？返回r？"><a href="#返回l？返回r？" class="headerlink" title="返回l？返回r？"></a>返回l？返回r？</h3><p>我们需要care的一点就是到底是返回l还是返回r呢？结论是：就题论题，九成以上返回l，但是不排除返回r的可能，例如上面的数组[1, 2, 6, 6, 10, 13, 17]，找出比6小的最大值，自己写一下代码，很容易发现返回的是r，而不是l，因此如果不确定的话，最好的办法是找个例子尝试一下。</p><h2 id="三-二分搜索简单题目"><a href="#三-二分搜索简单题目" class="headerlink" title="三. 二分搜索简单题目"></a>三. 二分搜索简单题目</h2><p>其实二分搜索，难的是真滴难，简单的也有很多坑，慢慢积累经验吧，有时候边界条件搞不懂就特别烦。</p><h3 id="3-1-LeetCode-69-Sqrt-x"><a href="#3-1-LeetCode-69-Sqrt-x" class="headerlink" title="3.1 LeetCode 69. Sqrt(x)"></a>3.1 <a href="https://leetcode.com/problems/sqrtx/">LeetCode 69. Sqrt(x)</a></h3><p><strong>注意：</strong>需要注意的点就是输入的值可能会特别大，二分后的值，如果直接平方的话有可能会越界，所以可以考虑使用除法或者用long来实现。这里用除法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, m = <span class="number">0</span>, r = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (m == x / m) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; x / m) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; x / m) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-LeetCode-367-Valid-Perfect-Square"><a href="#3-2-LeetCode-367-Valid-Perfect-Square" class="headerlink" title="3.2 LeetCode 367. Valid Perfect Square"></a>3.2 <a href="https://leetcode.com/problems/valid-perfect-square/">LeetCode 367. Valid Perfect Square</a></h3><p><strong>注意：</strong>需要注意的是这里不能用除法，和69题不一样，因为除法会损失精度，导致计算错误，所以这里用long类型来辅助计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>, end = num;</span><br><span class="line">        <span class="keyword">long</span> target = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            target = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target * target &gt; num) &#123;</span><br><span class="line">                end = (<span class="keyword">int</span>)target - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target * target &lt; num) &#123;</span><br><span class="line">                start = (<span class="keyword">int</span>)target + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-LeetCode-35-Search-Insert-Position"><a href="#3-3-LeetCode-35-Search-Insert-Position" class="headerlink" title="3.3 LeetCode 35. Search Insert Position"></a>3.3 <a href="https://leetcode.com/problems/search-insert-position/">LeetCode 35. Search Insert Position</a></h3><p><strong>注意：</strong>这道是最传统的二分搜索，基础中的基础。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, m = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-LeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#3-4-LeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="3.4 LeetCode 34. Find First and Last Position of Element in Sorted Array"></a>3.4 <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode 34. Find First and Last Position of Element in Sorted Array</a></h3><p><strong>注意：</strong>先找到一个pivot，再分别计算左右有多少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>, m = <span class="number">0</span>, pivot = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt;= target) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == nums.length || nums[l] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里l是第一个target的位置</span></span><br><span class="line">        res[<span class="number">0</span>] = l;</span><br><span class="line"></span><br><span class="line">        r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = l - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5-LeetCode-50-Pow-x-n"><a href="#3-5-LeetCode-50-Pow-x-n" class="headerlink" title="3.5 LeetCode 50. Pow(x, n)"></a>3.5 <a href="https://leetcode.com/problems/powx-n/">LeetCode 50. Pow(x, n)</a></h3><p><strong>注意：</strong>这道题要用二分法来减少运算，次数，而且负数除以2余数为-1，注意取反。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0d</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> ret = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> x * ret * ret;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ret * ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> ret = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">0</span> - n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret * ret / x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ret * ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1035. Uncrossed Lines</title>
      <link href="2020/05/26/LeetCode-1035-Uncrossed-Lines/"/>
      <url>2020/05/26/LeetCode-1035-Uncrossed-Lines/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/uncrossed-lines/">LeetCode 1035. Uncrossed Lines</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>我们在两条独立的平行线线上按给定的顺序写下 A 和 B 数组。</p><p>我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p><p>以这种方法绘制线条，返回我们可以绘制的最大连线数。</p><pre><code>Note:1 &lt;= A.length &lt;= 5001 &lt;= B.length &lt;= 5001 &lt;= A[i], B[i] &lt;= 2000</code></pre><p>Examples：</p><img src="/images/leetcode1035.png" width="150" height="100" /><pre><code>Input: A = [1,4,2], B = [1,2,4]Output: 2Explanation: We can draw 2 uncrossed lines as in the diagram.We cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>又是二维数组，又是计算最大值，大概率是用DP来做。</p><p>我们假设**dp[i][j]**表示从A[0]到A[i]和B[0]到B[j]的子数组的最大连线数。</p><p>那么我们分为两种情况，第一种是A[i]和B[j]有连线，那么dp[i][j]就等于dp[i - 1][j - 1] + 1；如果没有连线，则dp[i][j]和max(dp[i - 1][j], dp[i][j - 1])相等，递推式如下：</p><p>\begin{equation}<br>dp[i][j] = dp[i - 1][j - 1] \text{  if } A[i] = B[j]<br>\end{equation}</p><p>\begin{equation}<br>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) \text{  if } A[i] \neq B[j]<br>\end{equation}</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p><strong>Dynamic Programming bottom-up</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = A.length, n2 = B.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : dp) &#123;</span><br><span class="line">            Arrays.fill(row, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1218. Longest Arithmetic Subsequence of Given Difference</title>
      <link href="2020/05/26/LeetCode-1218-Longest-Arithmetic-Subsequence-of-Given-Difference/"/>
      <url>2020/05/26/LeetCode-1218-Longest-Arithmetic-Subsequence-of-Given-Difference/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 1218. Longest Arithmetic Subsequence of Given Difference</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个整形数组arr和一个整形数difference，找出arr所有子序列中以difference为间隔的最大长度。例如：</p><p>Examples：</p><pre><code>Example 1:Input: arr = [1,2,3,4], difference = 1Output: 4Explanation: The longest arithmetic subsequence is [1,2,3,4].Example 2:Input: arr = [1,3,5,7], difference = 1Output: 1Explanation: The longest arithmetic subsequence is any single element.Example 3:Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2Output: 4Explanation: The longest arithmetic subsequence is [7,5,3,1].</code></pre><p>Constraints:</p><pre><code>1 &lt;= arr.length &lt;= 10^5-10^4 &lt;= arr[i], difference &lt;= 10^4</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>首先我们看一下给出的输入大小，基本上确定了不能使用暴力搜索，最多支持O(nlogn)级别的复杂度。所以我们判断使用动态规划来节约时间。</p><p>我们来看一下题目，要求找子序列，且difference确定，base case我们设定为长度为1的single element，maxLength就是1。然后对于第n个数，我们需要找到从第1个数到第 $ n - 1 $ 个数存不存在num[n] - difference，如果不存在，则说明以当前数字为结尾的最长子序列长度为1，也就是本身；如果存在，则为dp[n - difference] + 1，视情况更新maxLength。</p><p>对于判断是否存在num[n] - difference，有一个最好用的数据结构就是hashmap，key为数字，value为最后一次出现的index，对于重复的数，后出现的那个一定是包含先出现的情况。</p><pre><code>dp[n] = dp[n - difference] + 1 (如果n - difference出现过)dp[n] = 1 (如果n - difference没出现过)</code></pre><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p><strong>Dynamic Programming bottom-up</strong>：数组最长为10^5，则dp数组长度为100001.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000</span>];</span><br><span class="line">        <span class="comment">// key是数值，value是last index</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; dict = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> targetIndex = dict.getOrDefault(arr[i] - difference, -<span class="number">1</span>);</span><br><span class="line">            dict.put(arr[i], i);</span><br><span class="line">            <span class="keyword">if</span> (targetIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[targetIndex] + <span class="number">1</span>;</span><br><span class="line">                longest = Math.max(longest, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一</title>
      <link href="2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80/"/>
      <url>2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="动态规划（一）"><a href="#动态规划（一）" class="headerlink" title="动态规划（一）"></a>动态规划（一）</h1><h2 id="一-动态规划基础"><a href="#一-动态规划基础" class="headerlink" title="一. 动态规划基础"></a>一. 动态规划基础</h2><p>此小节参考：<a href="https://labuladong.github.io/ebook/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6.html">动态规划解题套路</a></p><h3 id="1-1-什么是动态规划"><a href="#1-1-什么是动态规划" class="headerlink" title="1.1 什么是动态规划"></a>1.1 什么是动态规划</h3><p>我们首先需要知道我们为什么需要动态规划，动态规划的核心思想其实就是<strong>用空间换时间</strong>，而省时间的方式就是减少Brute Force或者递归中重复的子问题。</p><p>动态规划的基础是<strong>最优子结构</strong>，什么是最优子结构？其实就是从一个小规模问题推导出大规模问题的解。并且子问题之间不能相互影响，所以找出最优子结构，写出递推式是DP问题的最关键的部分，同时也是最难的部分。用花花酱的话来说，DP问题做多少都不嫌多。</p><p>最直接的例子就是斐波那契数列：</p><p>$$ f(n) = f(n - 1) + f(n - 2) $$</p><p>有可能要计算很多重复的子问题，如果使用一个数组记录已经计算过的f(n)，计算f(n + 1)时用到f(n)时可以直接返回，而不用再次递归。</p><h3 id="1-2-动态规划思路"><a href="#1-2-动态规划思路" class="headerlink" title="1.2 动态规划思路"></a>1.2 动态规划思路</h3><p>动态规划问题大多数都是求最值的，从比较小规模的最值，到当前规模的最值，一步步扩张。</p><h3 id="1-2-1-top-down"><a href="#1-2-1-top-down" class="headerlink" title="1.2.1 top-down"></a>1.2.1 top-down</h3><p><strong>递归 + memorization</strong></p><p>自顶向下：其实就是普通的递归加上memorization，上面提到的斐波那契数列的例子就是top-down，简单来说就是从需要计算的解，从后向前推导，记录每一步的值，直到base case结束，也就是递归终点。</p><h3 id="1-2-2-bottom-up"><a href="#1-2-2-bottom-up" class="headerlink" title="1.2.2 bottom-up"></a>1.2.2 bottom-up</h3><p><strong>Loop + memorization</strong></p><p>自底向上：从base case去递归求解下一个解，直到最终的目标解。以斐波那契额为例：</p><pre><code>dp[1] = 1dp[2] = 2i = 3while (i &lt;= n) &#123;    dp[i] = dp[i - 1] + dp[i - 2];    i++;&#125;return dp[n];</code></pre><h3 id="1-2-3-注意事项"><a href="#1-2-3-注意事项" class="headerlink" title="1.2.3 注意事项"></a>1.2.3 注意事项</h3><pre><code>动态规划还需要注意的很重要的一点是边界，往往边界是递归返回的base case，或者用于padding。</code></pre><h3 id="1-3-动态规划分类"><a href="#1-3-动态规划分类" class="headerlink" title="1.3 动态规划分类"></a>1.3 动态规划分类</h3><p>这里分类是向花花酱学习的分类方式，用数据规模，时间复杂度和空间复杂度进行分类。这里是花花酱整理的<a href="https://docs.google.com/spreadsheets/d/1yRCOJ8KysRVkq0O9IlDriT01tC6lzPapmFO4PCmDJQA/edit#gid=1674276502">不同类型DP问题分类链接</a>。</p><p>本次讨论的所有动态规划问题都是属于入门级难度，大部分是：“I: O(n), S = O(n), T = O(n)”，其中I表示的是输入量级，S表示空间复杂度，T表示时间复杂度。</p><p>注意，这里S的O(n)可能是O(2n),O(3n)，T也是如此，对于2n和3n的情况后面还会讨论，需要多做题熟悉。</p><h2 id="二-动态规划题目总结（2020-05-25）"><a href="#二-动态规划题目总结（2020-05-25）" class="headerlink" title="二. 动态规划题目总结（2020.05.25）"></a>二. 动态规划题目总结（2020.05.25）</h2><p>本次的题目大都比较简单，比较简单的题目直接放链接和递推式，然后直接给出Java Code，需要额外写文章的这里给出链接。</p><h3 id="2-1-LeetCode-53-Maximum-Subarray"><a href="#2-1-LeetCode-53-Maximum-Subarray" class="headerlink" title="2.1 LeetCode 53. Maximum Subarray"></a>2.1 <a href="https://leetcode.com/problems/maximum-subarray/">LeetCode 53. Maximum Subarray</a></h3><p><strong>递推式</strong>：假设F(n)为从第1到n个数中包含当前数字的子序列的最大值。</p><p>$$ F(n) = max(F(n - 1) + num[n], num[n]) $$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> resultMax = nums[<span class="number">0</span>], currentMax = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            currentMax = Math.max(currentMax + nums[i], nums[i]);</span><br><span class="line">            resultMax = Math.max(resultMax, currentMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-LeetCode-70-Climbing-Stairs"><a href="#2-2-LeetCode-70-Climbing-Stairs" class="headerlink" title="2.2 LeetCode 70. Climbing Stairs"></a>2.2 <a href="https://leetcode.com/problems/climbing-stairs/">LeetCode 70. Climbing Stairs</a></h3><p><strong>递推式</strong>：假设F(n)为从第1到n级台阶的走法最大值。</p><p>$$ F(n) = F(n - 1) + F(n - 2) (F(1) = 1, F(2) = 2)$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>, cur = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = pre + cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-LeetCode-121-Best-Time-to-Buy-and-Sell-Stock"><a href="#2-3-LeetCode-121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="2.3 LeetCode 121. Best Time to Buy and Sell Stock"></a>2.3 <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">LeetCode 121. Best Time to Buy and Sell Stock</a></h3><p><strong>递推式</strong>：假设F(n)为从第1到n天，买卖股票赚钱最多赚多少钱；tempMin(1, n)为从1到n的最最低价。</p><p>$$ F(n) = Math.max(F(n - 1), prices[n] - tempMin(1, n))$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = prices[<span class="number">1</span>] - prices[<span class="number">0</span>] &gt; <span class="number">0</span> ? prices[<span class="number">1</span>] - prices[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempMin = prices[<span class="number">1</span>] &gt; prices[<span class="number">0</span>] ? prices[<span class="number">0</span>] : prices[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            result = prices[i] - tempMin &gt; result ? prices[i] - tempMin : result;</span><br><span class="line">            tempMin = prices[i] &lt; tempMin ? prices[i] : tempMin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-LeetCode-198-House-Robber"><a href="#2-4-LeetCode-198-House-Robber" class="headerlink" title="2.4 LeetCode 198. House Robber"></a>2.4 <a href="https://leetcode.com/problems/house-robber/">LeetCode 198. House Robber</a></h3><p><strong>递推式</strong>：假设F(n)为从第1家到第n家最多能获得的财富数目，nums[n]为第n家的财富。</p><p>$$ F(n) = Math.max(F(n - 1), F(n - 2) + nums[n]) (F(1) = nums[1], F(2) = Math.max(nums[1], nums[2])) $$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>], cur = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cur;</span><br><span class="line">            cur = Math.max(pre + nums[i], cur);</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-LeetCode-303-Range-Sum-Query-Immutable"><a href="#2-5-LeetCode-303-Range-Sum-Query-Immutable" class="headerlink" title="2.5 LeetCode 303. Range Sum Query - Immutable"></a>2.5 <a href="https://leetcode.com/problems/range-sum-query-immutable/">LeetCode 303. Range Sum Query - Immutable</a></h3><p>这道题我不觉得算是一道DP题目，最多算caching，硬要说的话也的确有dp减少重复子问题的思想在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">            sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                sums[i] = nums[i] + sums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span> &lt; <span class="number">0</span> ? sums[j] : sums[j] - sums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="2-6-LeetCode-746-Min-Cost-Climbing-Stairs"><a href="#2-6-LeetCode-746-Min-Cost-Climbing-Stairs" class="headerlink" title="2.6 LeetCode 746. Min Cost Climbing Stairs"></a>2.6 <a href="https://leetcode.com/problems/min-cost-climbing-stairs/">LeetCode 746. Min Cost Climbing Stairs</a></h3><p><font color=Red>注意：</font>这道题里，登上最终台阶的意思不是数组的最后一级，而是数组的最后一级再向后数一级，也就是说要越过它，到达n+1起始位置我们可以理解为从0级台阶开始，cost为0。</p><p><strong>递推式</strong>：假设F(n)为从第1级到跨越n级所需要的最小cost(从n-1跳就不需要加上cost[n]， 从n-2跳就需要)。</p><p>$$ F(n) = Math.min(F(n - 1), F(n - 2) + cost[n - 1]) (F(1) = nums[0], F(2) = Math.min(nums[0], nums[1]))$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length];</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        Arrays.fill(dp, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i] ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[n - <span class="number">1</span>], dp[n - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-LeetCode-1137-N-th-Tribonacci-Number"><a href="#2-7-LeetCode-1137-N-th-Tribonacci-Number" class="headerlink" title="2.7 LeetCode 1137. N-th Tribonacci Number"></a>2.7 <a href="https://leetcode.com/problems/n-th-tribonacci-number/">LeetCode 1137. N-th Tribonacci Number</a></h3><p><strong>递推式</strong>：已经很明显地告知递推式了，且0 &lt;= n &lt;= 37无需多言。</p><p>$$ F(n) = F(n - 1) + F(n - 2) + F(n - 3) (n &gt;= 3, F(1) = 0, F(1) = 1, F(2) = 1)$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">38</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        res[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span> || res[n] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[n] = tribonacci(n - <span class="number">1</span>) + tribonacci(n - <span class="number">2</span>) + tribonacci(n - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1008. Construct Binary Search Tree from Preorder Traversal</title>
      <link href="2020/05/24/LeetCode-1008-Construct-Binary-Search-Tree-from-Preorder-Traversal/"/>
      <url>2020/05/24/LeetCode-1008-Construct-Binary-Search-Tree-from-Preorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal">LeetCode 1008. Construct Binary Search Tree from Preorder Traversal</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵BST树的前序遍历的顺序，恢复这棵树。例如：</p><pre><code>Input: [8,5,1,7,10,12]Output: [8,5,10,1,7,null,12]</code></pre><p><img src="/images/leetcode235.png" alt="BST树" title="Example 1"></p><pre><code>Constraints:1 &lt;= preorder.length &lt;= 1001 &lt;= preorder[i] &lt;= 10^8The values of preorder are distinct.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="中序遍历-前序遍历"><a href="#中序遍历-前序遍历" class="headerlink" title="中序遍历+前序遍历"></a>中序遍历+前序遍历</h3><p>这道题和<a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal//">LeetCode 105</a>很像，只不过105中给出的是一棵二叉树的前序和中序遍历，对于BST树来说，其中序遍历就是其所有元素从小到大的排列。</p><p>第一种做法更加简洁一些。中序遍历的顺序是”中-&gt;左子树-&gt;右子树”，也就是说从第二个元素开始，到左子树结束，其中间的数都比“中”要小，所以并不需要通过中序遍历找左右子树。</p><p>第二种做法就是重排列一下数组，然后以前序遍历和中序遍历的顺序重新construct整棵树。这种做法麻烦的地方在于需要注意很多index，一不小心就会出很大的错。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>简洁版，不找中序遍历序列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = end;</span><br><span class="line">        <span class="keyword">while</span> (preorder[temp] &gt; preorder[start]) &#123;</span><br><span class="line">            temp--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[start]);</span><br><span class="line">        node.left = buildTree(preorder, start + <span class="number">1</span>, temp);</span><br><span class="line">        node.right = buildTree(preorder, temp + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>麻烦版本（代码见<a href="/2020/05/18/LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/" title="LeetCode 105">LeetCode 105</a> ）</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1458. Max Dot Product of Two Subsequences</title>
      <link href="2020/05/24/LeetCode-1458-Max-Dot-Product-of-Two-Subsequences/"/>
      <url>2020/05/24/LeetCode-1458-Max-Dot-Product-of-Two-Subsequences/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode-cn.com/problems/max-dot-product-of-two-subsequences/">LeetCode 1458. Max Dot Product of Two Subsequences</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个数组 nums1 和 nums2 。</p><p>请返回 nums1 和 nums2 中两个长度相同的 非空 子序列的最大点积。</p><p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，[2,3,5] 是 [1,2,3,4,5] 的一个子序列而 [1,5,3] 不是。例如：</p><pre><code>Example 1：Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]Output: 18Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.Their dot product is (2*3 + (-2)*(-6)) = 18.Example 2：Input: nums1 = [-1,-1], nums2 = [1,1]Output: -1Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.Their dot product is -1.Constraints:1 &lt;= nums1.length, nums2.length &lt;= 500-1000 &lt;= nums1[i], nums2[i] &lt;= 1000</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>这道题和 <a href="https://leetcode.com/problems/edit-distance/">LeetCode 72. Edit Distance</a>很类似，今天等下去做一下试试。还有GeekForGeeks的这个<a href="https://www.geeksforgeeks.org/find-maximum-dot-product-two-arrays-insertion-0s/">Find Maximum dot product of two arrays with insertion of 0’s</a>基本一致。</p><p>首先根据数据规模，判断复杂度最多只能是O(mn)，不会更多，因此使用DP（做多了应该就一眼看出来了）。</p><p>我们设 dp[i][j] 为使用nums1[0 ~ i]和nums2[0 ~ j]的非空子序列的最大点积，那么有如下四种情况。</p><pre><code>1. nums1的第i个元素被纳入了最终解中，而nums2的第j个元素没有被纳入最终解中，dp[i][j] = dp[i][j - 1]；2. nums1的第i个元素没有被纳入了最终解中，而nums2的第j个元素被纳入最终解中，dp[i][j] = dp[i - 1][j]；3. nums1的第i个元素和nums2的第j个元素都被纳入到最终解的计算中，dp[i][j] = max(dp[i - 1][j - 1], 0) + nums[i] * nums[j]。4. nums1的第i个元素和nums2的第j个元素都没有被纳入到最终解的计算中，dp[i][j] = dp[i - 1][j - 1]；</code></pre><p>但是我们其实会发现，第四种情况根本就是不需要考虑的情况，因为dp[i - 1][j]和dp[i][j - 1]一定是大于等于dp[i - 1][j - 1]的，所以第四种情况我们pass掉，就变成了从三种情况中取最大值。</p><p>那么base case是什么样的呢？我们有两种方式进行选择，进行padding或者不进行padding。不进行padding的话可能会多出一些判断条件。padding的意思就是定义一些额外的情况，从而不需要判断边界。</p><p><font color=Red>Attention:</font></p><p>这里有几个需要注意的点：</p><ol><li>首先，这里数字有正有负，所以有可能出现前面dp的值都为负数的情况，所以在上面的第三种情况中，如果我们需要nums[i] * nums[j]，则需要判断前面是否小于0，如果小于0，则抛弃前面的dp值。</li></ol><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>Dynamic Programming (with padding)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.length, n2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : dp) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MIN_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.max(Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), Math.max(<span class="number">0</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + nums1[i - <span class="number">1</span>] * nums2[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>Dynamic Programming (without padding)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.length, n2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1][n2];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; j++) &#123;</span><br><span class="line">                dp[i][j] = nums1[i] * nums2[j];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], <span class="number">0</span>) + dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1 - <span class="number">1</span>][n2 - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1457. Pseudo-Palindromic Paths in a Binary Tree</title>
      <link href="2020/05/24/LeetCode-1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree/"/>
      <url>2020/05/24/LeetCode-1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/">LeetCode 1457. Pseudo-Palindromic Paths in a Binary Tree</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p><p>返回从根到叶子节点的所有路径中“伪回文”路径的数目。例如：</p><p><img src="/images/leetcode1457.png" alt="伪回文路径数" title="Example 1"></p><pre><code>Input: root = [2,3,1,3,1,null,1]Output: 2 Explanation: 上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h3><p>需要计算每条从root到根节点路径中每种数字的奇偶性，然后到达根节点时判断个数为奇数的数字是否最多只有一个。如果是，则res++；否则直接返回。</p><h3 id="奇偶性-bit-manipulation"><a href="#奇偶性-bit-manipulation" class="headerlink" title="奇偶性 + bit manipulation"></a>奇偶性 + bit manipulation</h3><p>其实我们并不需要知道每种数字的具体个数，只要知道奇偶性即可。因此我们用一个10位bit来记录，如果为奇数，则bit位为1，偶数则bit位为0。最终判断bit位为1的个数。</p><h2 id="3-解法（LeetCode-105-amp-106）"><a href="#3-解法（LeetCode-105-amp-106）" class="headerlink" title="3. 解法（LeetCode 105 &amp; 106）"></a>3. 解法（LeetCode 105 &amp; 106）</h2><ol><li>奇偶性</li></ol><p>使用Arrays.copyOfRange(int[] data, int start, int end)函数，写起来简洁，但是有点慢，而且耗空间大，因为要截取数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(path, <span class="number">0</span>);</span><br><span class="line">        dfs(root, path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path[root.val]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> countOdd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (path[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    countOdd++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (countOdd &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root.left, path);</span><br><span class="line">        dfs(root.right, path);</span><br><span class="line"></span><br><span class="line">        path[root.val]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>奇偶性 + bit manipulation，注意二进制里1个数的计算。另外，java不支持默认参数，所以需要另写一个辅助函数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPseudo(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPseudo</span> <span class="params">(TreeNode root, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s ^= (<span class="number">1</span> &lt;&lt; root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意这里是怎么计算某数字二进制里1的个数的！</span></span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>, x = s;</span><br><span class="line">            <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                x &amp;= (x - <span class="number">1</span>); <span class="comment">//每次去除最低位的1，直至全部为0</span></span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += c &lt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += getPseudo(root.left, s);</span><br><span class="line">        ans += getPseudo(root.right, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1456. Maximum Number of Vowels in a Substring of Given Length</title>
      <link href="2020/05/24/LeetCode-1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/"/>
      <url>2020/05/24/LeetCode-1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">LeetCode 1456. Maximum Number of Vowels in a Substring of Given Length</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个字符串s和一个正整数k，返回以k长度的所有子字符串包含元音字母的最大值。例如：</p><pre><code>Input: s = &quot;abciiidef&quot;, k = 3Output: 3Explanation: The substring &quot;iii&quot; contains 3 vowel letters.Constraints:1 &lt;= s.length &lt;= 10^5s consists of lowercase English letters.1 &lt;= k &lt;= s.length</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><p>这道题一眼就能看出来是sliding window，初始化以后每次移动一位，记录历史最大值。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>Sliding Window</li></ol><p>使用Arrays.copyOfRange(int[] data, int start, int end)函数，写起来简洁，但是有点慢，而且耗空间大，因为要截取数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempVowels = <span class="number">0</span>, maxVowels = <span class="number">0</span>, startIndex = <span class="number">0</span>, endIndex = k;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isVowel(s.charAt(i))) &#123;</span><br><span class="line">                tempVowels++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxVowels = tempVowels;</span><br><span class="line">        <span class="keyword">while</span> (endIndex &lt; length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isVowel(s.charAt(endIndex))) &#123;</span><br><span class="line">                tempVowels++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isVowel(s.charAt(startIndex))) &#123;</span><br><span class="line">                tempVowels--;</span><br><span class="line">            &#125;</span><br><span class="line">            endIndex++;</span><br><span class="line">            startIndex++;</span><br><span class="line">            maxVowels = Math.max(maxVowels, tempVowels);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxVowels;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 986. Interval List Intersections</title>
      <link href="2020/05/24/LeetCode-986-Interval-List-Intersections/"/>
      <url>2020/05/24/LeetCode-986-Interval-List-Intersections/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/interval-list-intersections/">LeetCode 986. Interval List Intersections</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个闭区间的列表，每个闭区间列表都是以数对的形式顺序排列，且闭区间之间不相连。例如：</p><pre><code>Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.1. 0 &lt;= A.length &lt; 10002. 0 &lt;= B.length &lt; 10003. 0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>首先我们看到两个列表的区间很大。。。算了，直接看出来双指针能解决就不假装分析了。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>双指针</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; intersections = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> sizeA = A.length, sizeB = B.length, indexA = <span class="number">0</span>, indexB = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (indexA &lt; sizeA &amp;&amp; indexB &lt; sizeB) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = Math.max(A[indexA][<span class="number">0</span>], B[indexB][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> hi = Math.min(A[indexA][<span class="number">1</span>], B[indexB][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">                intersections.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;lo, hi&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hi == A[indexA][<span class="number">1</span>]) &#123;</span><br><span class="line">                indexA++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexB++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[intersections.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intersections.size(); i++) &#123;</span><br><span class="line">            result[i] = intersections.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 377. Combination Sum IV</title>
      <link href="2020/05/24/LeetCode-377-Combination-Sum-IV/"/>
      <url>2020/05/24/LeetCode-377-Combination-Sum-IV/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/combination-sum-iv/">LeetCode 377. Combination Sum IV</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个无重复的正整数数组nums，一个目标数target，找出和为target的所有可能的组合，每个数字可以取多个。例如：</p><pre><code>Input: candidates = [2,3,6,7], target = 7,A solution set is:[[7],[2,2,3]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>那么我们应该使用什么算法呢？还是回溯么？貌似是可行的，只要将循环时的startIndex不设置为i，始终设置为0即可。代码放在下面（实际上会TLE）。</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>这道题是combination sum系列的第四题，又是不重复的数字，每个数字可以多次，和combination sum I很像，但是1中要求不能有重复的组合([1, 2, 3]和[3, 2, 1]算一种)，而4中即使是相同的数字，不同的排列组合也算不同。例如，我们希望用[1, 2, 3]组合得到7，对于[1, 1]和[2]来说，其实目标都是找出组合为5的所有可能的排列组合的可能性，重复计算，数字越大，重复计算越多，所以DP才是相对较好的解。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>回溯。会TLE，原因在于这相当于是一个排列组合问题，由[1, 2, 3]组成30的可能性已经有53798080种，而这其中的每一种都是由好多层递归来实现的，重叠子问题计算得太多。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line"></span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                backtracking(candidates, target, sum, <span class="number">0</span>);</span><br><span class="line">                sum -= candidates[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>DP。顺利通过。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里无需像之前那样进行排序，因为这次不需要对不同的顺序有要求，不同顺序也被当成不同个解。</span></span><br><span class="line">        <span class="comment">// Arrays.sort(candidates);</span></span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findSum(candidates, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSum</span><span class="params">(<span class="keyword">int</span> candicates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[target] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[target];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : candidates) &#123;</span><br><span class="line">            dp[target] += find(candidates, target - num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[target]++;<span class="comment">// 注意，由于初始值是-1.所以这里要加1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 216. Combination Sum II</title>
      <link href="2020/05/24/LeetCode-216-Combination-Sum-III/"/>
      <url>2020/05/24/LeetCode-216-Combination-Sum-III/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/combination-sum-iii/">LeetCode 216. Combination Sum II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个目标数n，在1到9中找k个数，使得k个数之和为n（每个数字至多选择一次）。例如：</p><pre><code>Input: k = 3, n = 9Output: [[1,2,6], [1,3,5], [2,3,4]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>这道题是combination sum系列的第三题，又是不重复的数字，且每个数字至多只能选一次，而且要求一定是k个。</p><p>限制条件变多，但依然是用回溯法做，每次判断下一层的时候记得k-1，且最终add结果时判断k是否为k-1是否为0。数字为1-9，这次不需要传数组进去了，直接用数字就好。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>回溯，记得如果更改了k的话也要将k复原，回溯法一定注意复原！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; nums = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        backtracking(n, <span class="number">0</span>, <span class="number">1</span>, nums, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> start, LinkedList&lt;Integer&gt; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            nums.add(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                backtracking(target, sum, i + <span class="number">1</span>, nums, k - <span class="number">1</span>);</span><br><span class="line">                nums.removeLast();</span><br><span class="line">                sum -= i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == target &amp;&amp; k - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList(nums));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back tracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 40. Combination Sum II</title>
      <link href="2020/05/24/LeetCode-40-Combination-Sum-II/"/>
      <url>2020/05/24/LeetCode-40-Combination-Sum-II/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/combination-sum-ii/">LeetCode 40. Combination Sum II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个正整数数组A（可能存在重复），给出一个target，找出和为target的所有不重复的可能组合（每个数字最多只能使用一次）。例如：</p><pre><code>Input: candidates = [10,1,2,7,6,1,5], target = 8,A solution set is:[[1, 7],[1, 2, 5],[2, 6],[1, 1, 6]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题是combination sum系列的第二题，区别在于这次不是无限适应数字了，而是每个数字都最多使用一次。其实算法类似，这道题还是不能用DP，因为每个数字只能用一次，子问题相互干涉，使用不是DP问题（下周做DP的背包问题吧，要不然太烦了，感觉跟这个combination sum好像啊）。</p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>此题我们仍然考虑用回溯法，其实可以用combination sum I的代码，只需要在递归调用backtracking的时候将startIndex从i变为i+1而已，最后还需要将整个结果集去重（因为存在存在重复数字，假设说我们有三个1，有一种解法需要两个1和其他数字，如果不去重，这一种解法就会膨胀成三个）。</p><p>当然，还有一种更巧妙的去重方法，如果临时想的话不一定想得到，直接记忆吧，放在解法2里。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>回溯，使用hashset去重法，巨慢</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; hashset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        hashset = <span class="keyword">new</span> HashSet();</span><br><span class="line">        LinkedList&lt;Integer&gt; nums = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>, nums);</span><br><span class="line"></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList(hashset);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> startIndex, LinkedList&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            nums.add(candidates[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                backtracking(candidates, target, sum, i + <span class="number">1</span>, nums);</span><br><span class="line">                nums.removeLast();</span><br><span class="line">                sum -= candidates[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                hashset.add(<span class="keyword">new</span> ArrayList(nums));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>回溯，循环判断去重，优雅。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        LinkedList&lt;Integer&gt; nums = <span class="keyword">new</span> LinkedList();</span><br><span class="line">         res = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>, nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> startIndex, LinkedList&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 优雅的去重方式，记住，以后可能用得到！</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i - <span class="number">1</span>] == candidates[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            nums.add(candidates[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                backtracking(candidates, target, sum, i + <span class="number">1</span>, nums);</span><br><span class="line">                nums.removeLast();</span><br><span class="line">                sum -= candidates[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList(nums));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back tracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 39. Combination Sum</title>
      <link href="2020/05/24/LeetCode-39-Combination-Sum/"/>
      <url>2020/05/24/LeetCode-39-Combination-Sum/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/combination-sum/">LeetCode 39. Combination Sum</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个无重复的正整数数组A，给出一个target，找出和为target的所有不重复的可能组合（每个数字使用次数不限）。例如：</p><pre><code>Input: candidates = [2,3,5], target = 8,A solution set is:[[2,2,2,2],[2,3,3],[3,5]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这道题是combination sum系列的第一题，看似有点像背包问题，实际上又不是。这道题问的是所有组合，某些DP问题也是求所有的组合之类的，但是本题要求不能有相同元素组成的组合，且找不到所谓的最优子问题结构，因此所以并不是DP问题（等复习到背包问题再回过来看）。</p><h3 id="Brute-Force（行不通）"><a href="#Brute-Force（行不通）" class="headerlink" title="Brute Force（行不通）"></a>Brute Force（行不通）</h3><p>首先，最容易想到的就是能不能用暴力破解法呢？答案肯定是不行的，由于每个数字取的次数不限，所以直接暴力破解不可取，需要优化。</p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>那么为什么会想到回溯呢？没有为什么，因为回溯能做出来这种需要遍历所有可能的问题。就这么简单。</p><p>对于一个数组A和某个target值，我们希望找出target所有的组合可能，假设F(int[] A, int start, int target)为从数组A中以start为起点找出target的所有可能组合，思路如下。</p><ol><li>对A从小到大进行排序，取A[0]作为第一个数，那么我们当前的目标是F(A, 0, target - A[0])；将其结果和A[0]放在一起作为第一种解。</li><li>然后取A[1]作为第一个数，然后我们目标是F(A, 1, target - A[1])。不从0开始是因为如果取了0，就会和第一步中的某种solution重复，故不取。</li><li>终止条件为target == 0，最终结果添加一条；target &lt; 0，回溯上去继续搞。</li></ol><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>暴力解法（Pass）</li><li>回溯</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        LinkedList&lt;Integer&gt; nums = <span class="keyword">new</span> LinkedList(); <span class="comment">//删除last回溯的时候方便</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line"></span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>, nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> startIndex, LinkedList&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            nums.add(candidates[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                backtracking(candidates, target, sum, i, nums);</span><br><span class="line">                sum -= candidates[i];</span><br><span class="line">                nums.removeLast();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList(nums));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back tracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 968. Binary Tree Cameras</title>
      <link href="2020/05/22/LeetCode-968-Binary-Tree-Cameras/"/>
      <url>2020/05/22/LeetCode-968-Binary-Tree-Cameras/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/binary-tree-cameras/">LeetCode 968. Binary Tree Cameras</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵二叉树，我们向节点中加入camera，每个节点可以监控其父节点和左右孩子，求最少需要多少个camera才能监控整棵树（节点不大于1000个，每个节点的value都是0）。例如：</p><p><img src="/images/leetcode968.png" alt="最少camera数" title="Example 1"><br>    Input: [0,0,null,0,null,0,null,null,0]<br>    Output: 2<br>    Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>Greedy：</strong></p><p>这道题完全没思路，直接看了solution，DP解法没看懂，直接看的Greedy，逻辑思路如下。</p><p>对于任何一个节点，它都有两种状态，有camera和没camera，其中没camera又分为两种，一种是它已经被covered了，另一种是还没有。所以一共是有三种状态。我们假设某节点和其左右孩子都需要被cover，那么我们首选肯定是在父节点放入camera，这样它才能辐射范围更广，而不是需要两个孩子放camera，camera更多。所以我们的核心策略就是尽可能把camera设置到上层，而不是叶子节点。</p><p>首先我们的定义一个节点的三种状态：</p><ol><li>有camera – 2</li><li>无camera但是被cover了 – 1</li><li>无camera并且需要父亲节点carry – 0</li></ol><p>对于null节点，我们不需要考虑，所以其状态为1。</p><p>所以逻辑如下：</p><ol><li>如果当前节点的左右孩子有一个为2（有camera），则当前节点为1；</li><li>如果当前节点的左右孩子有一个为0（无camera，需要父亲带飞），则当前节点为2；</li><li>如果当前节点的左右孩子都为1（都不用父亲carry），则当前节点期待父节点carry，当前节点为0；</li><li>如果根节点为0（没被孩子带飞），则result+1。</li></ol><p>时间复杂度为O(n)，空间复杂度O(h)。h为树的高度。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>Greedy</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getCameraState(root) == <span class="number">0</span> ? res + <span class="number">1</span>: res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCameraState</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftState = getCameraState(node.left);</span><br><span class="line">        <span class="keyword">int</span> rightState = getCameraState(node.right);</span><br><span class="line">        <span class="keyword">if</span> (leftState == <span class="number">1</span> &amp;&amp; rightState == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当前节点不放camera，期待被父亲carry</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftState == <span class="number">0</span> || rightState == <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 当前节点的孩子节点存在0状态，所以需要放一个camera</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前节点的孩子至少有一个2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 451. Sort Characters By Frequency</title>
      <link href="2020/05/22/LeetCode-451-Sort-Characters-By-Frequency/"/>
      <url>2020/05/22/LeetCode-451-Sort-Characters-By-Frequency/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/sort-characters-by-frequency/">LeetCode 451. Sort Characters By Frequency</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个字符串，将其字母按照字母出现频率进行降序排列。例如：</p><pre><code>Input:&quot;Aabb&quot;Output:&quot;bbAa&quot;Explanation:&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>HashTable：</strong></p><p>一考虑到频率的问题，首先就应该想到hashmap来进行计算。然后比较麻烦的是对hashmap的value进行排序，这个需要重写一个comparator，用来排序Map.Entry，写的比较少，多练练。然后按照顺序输出就可以了。</p><p>时间复杂度为O(nlogn)，这个是排序的时间复杂度；空间复杂度最大为O(n).</p><p><strong>Bucket Sort：</strong></p><p>第二种做法是用bucket sort，将字符放入hashmap后，计算出最大频率freq，然后简历一个长度为freq+1的list，对于不同频率的字符放入其中。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>HashTable</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; dict = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            dict.put(c, dict.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点在这里！！！Comparator的写法，以及如何对hashmap转为list后排序</span></span><br><span class="line">        List&lt;Map.Entry&lt;Character, Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList(dict.entrySet());</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Character, Integer&gt;&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Character, Integer&gt; o1, Map.Entry&lt;Character, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : list) &#123;</span><br><span class="line">            <span class="keyword">int</span> copy = entry.getValue();</span><br><span class="line">            <span class="keyword">char</span> c = entry.getKey();</span><br><span class="line">            <span class="keyword">while</span> (copy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                copy--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Bucket Sort</li></ol><p>这里要注意三个地方：见注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; dict = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> maxFrequency = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            dict.put(c, dict.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            maxFrequency = Math.max(maxFrequency, dict.get(c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = dict.size();</span><br><span class="line">        <span class="comment">// 注意1：这里定义数组时不用初始化，抽象定义</span></span><br><span class="line">        List&lt;Character&gt;[] bucket = <span class="keyword">new</span> List[maxFrequency + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : dict.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 注意2：这路记得初始化bucket数组</span></span><br><span class="line">            <span class="keyword">if</span> (bucket[entry.getValue()] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bucket[entry.getValue()] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            &#125;</span><br><span class="line">            bucket[entry.getValue()].add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = maxFrequency; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 注意3：bucket数组可能未被初始化，这里需要判断是否为空</span></span><br><span class="line">            <span class="keyword">for</span> (Character character : bucket[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    sb.append(character.charValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash table </tag>
            
            <tag> string </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 814. Binary Tree Pruning</title>
      <link href="2020/05/22/LeetCode-814-Binary-Tree-Pruning/"/>
      <url>2020/05/22/LeetCode-814-Binary-Tree-Pruning/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/binary-tree-pruning/">LeetCode 814. Binary Tree Pruning</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一颗二叉树，其每个节点都由0或1组成，删除其所有的节点都为0的子树，返回新的树的root节点。例如：</p><pre><code>Input: [1,0,1,0,0,0,1]Output: [1,null,1,null,1]</code></pre><p><img src="/images/leetcode814-1.png" alt="Example" title="Example"></p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>递归：</strong></p><p>和以前的一些求子树和的题目很像，例如<a href="/2020/05/22/LeetCode-508-Most-Frequent-Subtree-Sum/" title="LeetCode 508. Most Frequent Subtree Sum">LeetCode 508. Most Frequent Subtree Sum</a>，我们也可以求子树和，如果和为0，则说明将当前节点置为null即可。与返回布尔值的效果一致。仍然使用后序遍历。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>如果节点为null，直接返回0.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootSum = subtreeSum(root);</span><br><span class="line">        <span class="keyword">if</span> (rootSum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subtreeSum</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftSum = subtreeSum(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightSum = subtreeSum(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftSum == <span class="number">0</span>) &#123;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightSum == <span class="number">0</span>) &#123;</span><br><span class="line">            root.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val + leftSum + rightSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 508. Most Frequent Subtree Sum</title>
      <link href="2020/05/22/LeetCode-508-Most-Frequent-Subtree-Sum/"/>
      <url>2020/05/22/LeetCode-508-Most-Frequent-Subtree-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/most-frequent-subtree-sum/">LeetCode 508. Most Frequent Subtree Sum</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一颗二叉树，找出其所有子树并求子树和，找出频率最高的子树和（如果有频率一致的，返回多个）。例如：</p><pre><code>Examples 1Input:   5  /  \ 2   -3return [2, -3, 4], since all the values happen only once, return all of them in any order.Examples 2Input:   5  /  \ 2   -5return [2], since 2 happens twice, however -5 only occur once.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>后序遍历 + HashMap:</strong></p><p>很明显的后序遍历，对于每一个节点，都计算它的左子树和和右子树和，和自己本身的val相加，就是自己的子树和，统计完成后，找出最高频率，然后再次遍历HashMap，找出符合条件的sum和，最后再将储存结果的list转为array。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; res = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findFrequentTreeSum(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getSum(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxFrequency = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : res.entrySet()) &#123;</span><br><span class="line">            maxFrequency = Math.max(maxFrequency, entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : res.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxFrequency == entry.getValue()) &#123;</span><br><span class="line">                list.add(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ret[i] = list.get(i).intValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(root.left) + getSum(root.right) + root.val;</span><br><span class="line">        res.put(sum, (res.containsKey(sum) ? res.get(sum) : <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 450. Delete Node in a BST</title>
      <link href="2020/05/22/LeetCode-450-Delete-Node-in-a-BST/"/>
      <url>2020/05/22/LeetCode-450-Delete-Node-in-a-BST/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/delete-node-in-a-bst/">LeetCode 450. Delete Node in a BST</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵BST树，删除其中一个值为key的节点，返回新的树的根节点。例如：</p><pre><code>root = [5,3,6,2,4,null,7]key = 3    5   / \  3   6 / \   \2   4   7Given key to delete is 3. So we find the node with value 3 and delete it.One valid answer is [5,4,6,2,null,null,7], shown in the following BST.    5   / \  4   6 /     \2       7Another valid answer is [5,2,6,null,4,null,7].    5   / \  2   6   \   \    4   7</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>中序遍历</strong></p><p>对于一棵BST树，其最重要的性质就是其有序性。删除一个节点后，整棵树仍然保持有序。在这里我们需要明确一个节点的<strong>前驱结点（Predecessor）</strong>和<strong>后继节点（Successor）</strong>。某节点的前驱结点就是中序遍历的情况下在该节点之前的一个节点，后继节点就是该节点之后的一个节点。</p><p>删除一个节点时，需要将它的前驱结点或后继节点填补到它原本的位置上。那么逻辑就很清晰了，有几种不同的节点情况，我们分情况讨论。</p><ol><li>删除的节点为叶子节点：直接删除，毫无压力。</li><li>删除的节点存在右子树：找到右子树的最小节点（后继节点），将该节点替换到删除节点的位置。</li><li>删除的节点为非叶子节点，且不存在右子树：找到左子树的最大节点（前驱节点），将该节点替换到删除节点的位置</li></ol><p>或者我们可以遵循另一种思路：</p><ol><li>删除的节点存在右子树：找到右子树的最小节点，替换为当前节点。</li><li>删除的节点不存在右子树，直接将左孩子替换为当前节点。</li></ol><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>解法1：递归</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  One step right and then always left</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) root = root.left;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  One step left and then always right</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) root = root.right;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the right subtree</span></span><br><span class="line">    <span class="keyword">if</span> (key &gt; root.val) root.right = deleteNode(root.right, key);</span><br><span class="line">    <span class="comment">// delete from the left subtree</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root.val) root.left = deleteNode(root.left, key);</span><br><span class="line">    <span class="comment">// delete the current node</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// the node is a leaf</span></span><br><span class="line">      <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) root = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// the node is not a leaf and has a right child</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root.val = successor(root);</span><br><span class="line">        root.right = deleteNode(root.right, root.val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// the node is not a leaf, has no right child, and has a left child </span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        root.val = predecessor(root);</span><br><span class="line">        root.left = deleteNode(root.left, root.val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>解法2：记录前驱结点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里我分为两种情况讨论吧，看blog都是三种情况，不知道可行与否</span></span><br><span class="line">        <span class="comment">// 1. 存在右子树：将右子树中最小值替换掉当前值</span></span><br><span class="line">        <span class="comment">// 2. 不存在右子树：将左子树替换掉</span></span><br><span class="line"></span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>, node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; node.val != key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.val &lt; key) &#123;</span><br><span class="line">                pre = node;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; key) &#123;</span><br><span class="line">                pre = node;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是根节点</span></span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右子树为空</span></span><br><span class="line">            <span class="keyword">if</span> (pre.val &lt; node.val) &#123;</span><br><span class="line">                pre.right = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.left = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 右子树不为空</span></span><br><span class="line">            TreeNode rightRoot = node.right, rightPre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (rightRoot.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                rightPre = rightRoot;</span><br><span class="line">                rightRoot = rightRoot.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node.val = rightRoot.val;</span><br><span class="line">            <span class="keyword">if</span> (rightPre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                rightPre.left = rightRoot.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.right = rightRoot.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1277. Count Square Submatrices with All Ones</title>
      <link href="2020/05/21/LeetCode-1277-Count-Square-Submatrices-with-All-Ones/"/>
      <url>2020/05/21/LeetCode-1277-Count-Square-Submatrices-with-All-Ones/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/count-square-submatrices-with-all-ones/">LeetCode 1277. Count Square Submatrices with All Ones</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个m x n的矩阵，问有多少个正方形子矩阵是都由1组成的。例如：</p><pre><code>Input: matrix =[[0,1,1,1],[1,1,1,1],[0,1,1,1]]Output: 15Explanation: There are 10 squares of side 1.There are 4 squares of side 2.There is  1 square of side 3.Total number of squares = 10 + 4 + 1 = 15. </code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>Brute Force：</strong></p><p>暴力解法，这种方式就是遍历所有的可能的正方形的长度，范围从1到min(m, n)，然后再遍历所有的可能的位置，如果符合条件，则count+1，最后返回count。这种方式显然速度很慢，时间复杂度为O(mn * min(m, n))。</p><p><strong>Dynamic Programming：</strong></p><p>这道题的DP思路我也是没有想到的，我们假设F(i, j)为以(i, j)为右下角的正方形的个数，则有如下推导：</p><p>$$F(i, j) = min(F(i - 1, j), F(i - 1, j - 1), F(i, j - 1)) + 1$$</p><p>记住吧就，想象一下很简单就能得出该公式是正确的，但是没遇过很难想到。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>DP大法好</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] &gt; <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                res += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 666. Path Sum IV</title>
      <link href="2020/05/21/LeetCode-666-Path-Sum-IV/"/>
      <url>2020/05/21/LeetCode-666-Path-Sum-IV/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/path-sum-iv/">LeetCode 666. Path Sum IV</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>如果一棵树的高度不超过5，则这棵树可以被表示为一列三位数字的数组(数组从小到大排列)，对于每位数字都有其表示的含义：</p><ol><li>百位D表示该节点的深， 1 &lt;= D &lt;= 4</li><li>十位P表示这个数字在该层的位置，1 &lt;= P &lt;= 8</li><li>个位V表示该节点的值，0 &lt;= V &lt;= 9</li></ol><p>求所有的从root到leaf的路径和。例如：</p><pre><code>Input: [113, 215, 221]Output: 12Explanation: The tree that the list represents is:    3   / \  5   1The path sum is (3 + 5) + (3 + 1) = 12.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>此题的算法并不难，之前也有算过类似的题目，难点在于如何将一棵树完整地复原。一种做法是自己定义TreeNode，然后完整复原整棵树；另一种是使用HashMap来巧妙存储树，用HashMap的时候，前两位为key，个位为value，D和P加在一起能够唯一确定一个节点，且其子节点和右节点的key也能过通过数学公式算出来；第三种就是使用数组来储存，因为高度最高也就是4，建立一个二维数组来存储。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>自己定义TreeNode来存储，然后遍历</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node left, right;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node(<span class="keyword">int</span> v) &#123;val = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(nums[<span class="number">0</span>] % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个构建方法中，判断左右子树那块没太搞懂，直接抄了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == nums[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> depth = num / <span class="number">100</span>, pos = num / <span class="number">10</span> % <span class="number">10</span>, val = num % <span class="number">10</span>;</span><br><span class="line">            pos--;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = depth - <span class="number">2</span>; d &gt;= <span class="number">0</span>; --d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">1</span>&lt;&lt;d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) cur.left = <span class="keyword">new</span> Node(val);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) cur.right = <span class="keyword">new</span> Node(val);</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">                pos %= <span class="number">1</span>&lt;&lt;d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> currSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currSum += root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            res += currSum;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root.left, currSum);</span><br><span class="line">        dfs(root.right, currSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>使用HashMap来遍历整棵树（直接抄了solution）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; values;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        values = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)</span><br><span class="line">            values.put(num / <span class="number">10</span>, num % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        dfs(nums[<span class="number">0</span>] / <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!values.containsKey(node)) <span class="keyword">return</span>;</span><br><span class="line">        sum += values.get(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> depth = node / <span class="number">10</span>, pos = node % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> left = (depth + <span class="number">1</span>) * <span class="number">10</span> + <span class="number">2</span> * pos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!values.containsKey(left) &amp;&amp; !values.containsKey(right)) &#123;</span><br><span class="line">            ans += sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(left, sum);</span><br><span class="line">            dfs(right, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>我的原始做法，使用数组来存储</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] tree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            tree[i] = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i)];</span><br><span class="line">            Arrays.fill(tree[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = x / <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">int</span> p = (x % <span class="number">100</span>) / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> v = x % <span class="number">10</span>;</span><br><span class="line">            tree[d - <span class="number">1</span>][p - <span class="number">1</span>] = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(tree, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] tree, <span class="keyword">int</span> d, <span class="keyword">int</span> p, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= <span class="number">4</span> || p &gt;= (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, d) || tree[d][p] == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += tree[d][p];</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">3</span> || (tree[d + <span class="number">1</span>][<span class="number">2</span> * p] == -<span class="number">1</span> &amp;&amp; tree[d + <span class="number">1</span>][<span class="number">2</span> * p + <span class="number">1</span>] == -<span class="number">1</span>)) &#123;</span><br><span class="line">            res += sum;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(tree, d + <span class="number">1</span>, <span class="number">2</span> * p, sum);</span><br><span class="line">        dfs(tree, d + <span class="number">1</span>, <span class="number">2</span> * p + <span class="number">1</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> path sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 437. Path Sum III</title>
      <link href="2020/05/21/LeetCode-437-Path-Sum-III/"/>
      <url>2020/05/21/LeetCode-437-Path-Sum-III/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/path-sum-iii/">LeetCode 437. Path Sum III</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵二叉树和一个sum值，根节点为root，找出所有路path为sum的路径的数量，这里的path不一定要从根节点到叶子节点，但是一定要从父亲节点到孩子节点，不能回溯。例如：</p><pre><code>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8      10     /  \    5   -3   / \    \  3   2   11 / \   \3  -2   1Return 3. The paths that sum to 8 are:1.  5 -&gt; 32.  5 -&gt; 2 -&gt; 13. -3 -&gt; 11</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>此题难度为easy是我没想到的，其实感觉逻辑上还是有点难理解的，而且存在一种巧妙的HashMap的做法，作为解法2。</p><p>第一种解法。对于这个和之前最大的不同就是需要考虑不是从根节点出发的path了，对于某节点p来说我们需要计算的是包含p节点的以p为start出发的path；然后再加上从p的左右孩子出发的path，左子树和右子树分别计算。勉强算是前序遍历？完全取决于return的加法顺序。</p><p>第二种解法。逆向思维，第一种解法中考虑了从某节点p<strong>出发</strong>的path和为sum的路径；在这个基础上，我们是否可以换个思路，考虑了以某节点p<strong>结尾</strong>的path和为sum的路径。因此，对于任意一个节点p，我们需要计算的是以p为结尾的路径和为sum的path数，然后将其加和。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>使用LinkedList保存当前路径，遍历后从currPath中删除当前节点，一定要删除！而且要注意，add到result里的时候，记得new一个对象，否则currPath会变。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findPathSum(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过以root节点为start节点的path，和为sum的路径个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (root.val == sum ? <span class="number">1</span> : <span class="number">0</span>) + findPathSum(root.left, sum - root.val) + findPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用HashMap来记录到某节点p之前的，从root节点到其中任意一个节点的路径之和，方法很巧妙，需要硬记。记得最后要删除当前这个currSum的记录。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; preSumMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        preSumMap.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        findPathSum(root, <span class="number">0</span>, sum, preSumMap);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> currSum, <span class="keyword">int</span> target, Map&lt;Integer, Integer&gt; preSumMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currSum += root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preSumMap.containsKey(currSum - target)) &#123;</span><br><span class="line">            count += preSumMap.get(currSum - target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preSumMap.put(currSum, preSumMap.containsKey(currSum) ?(preSumMap.get(currSum) + <span class="number">1</span>) : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        findPathSum(root.left, currSum, target, preSumMap);</span><br><span class="line">        findPathSum(root.right, currSum, target, preSumMap);</span><br><span class="line"></span><br><span class="line">        preSumMap.put(currSum, preSumMap.get(currSum) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> path sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 129. Sum Root to Leaf Numbers</title>
      <link href="2020/05/20/LeetCode-129-Sum-Root-to-Leaf-Numbers/"/>
      <url>2020/05/20/LeetCode-129-Sum-Root-to-Leaf-Numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">LeetCode 129. Sum Root to Leaf Numbers</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵只含有value值为0-9的二叉树，根节点为root，每一条从root到leaf节点的路径都代表一个数字，求这些所有数字之和。例如：</p><pre><code>Input: [4,9,0,5,1]    4   / \  9   0 / \5   1Output: 1026Explanation:The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.The root-to-leaf path 4-&gt;0 represents the number 40.Therefore, sum = 495 + 491 + 40 = 1026.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>很简单的DFS的思路，前序遍历的思路，到达根节点时做一次判断。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> currSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>  (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currSum = currSum * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            res += currSum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root.left, currSum);</span><br><span class="line">        dfs(root.right, currSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 113. Path Sum II</title>
      <link href="2020/05/20/LeetCode-113-Path-Sum-II/"/>
      <url>2020/05/20/LeetCode-113-Path-Sum-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/path-sum-ii/">LeetCode 113. Path Sum II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵二叉树和一个sum值，根节点为root，找出所有从根节点到叶子节点的和为sum的路径。例如：</p><pre><code>Given the below binary tree and sum = 22,      5     / \    4   8   /   / \  11  13  4 /  \      \7    2      1Return:[[5,4,11,2],[5,8,4,5]]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>此题难度为medium，思路和Path Sum 1差不多，也是DFS遍历所有路径，这里有两种做法，一种是保留根节点到当前节点的路径，遍历完成后从list中删除该节点，需要写一个辅助函数；另一种做法是返回左孩子和右孩子到根节点和为sum-root.val的路径，然后拼接。</p><p>第一次做的时候用的是解法2，存在较多的拼接操作，运行速度较慢，放在下面的解法2.</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>使用LinkedList保存当前路径，遍历后从currPath中删除当前节点，一定要删除！而且要注意，add到result里的时候，记得new一个对象，否则currPath会变。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; currPath = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        pathSum(root, sum, currPath, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;Integer&gt; currPath, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currPath.add(<span class="keyword">new</span> TreeNode(root.val));</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList(currPath));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pathSum(root.left, sum - root.val, currPath, result);</span><br><span class="line">            pathSum(root.right, sum - root.val, currPath, result);</span><br><span class="line">        &#125;</span><br><span class="line">        currPath.remove(currPath.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>不适用辅助函数，将左右节点返回的符合条件的list拼接起来</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val != sum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) &#123;</span><br><span class="line">            List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            path.add(root.val);</span><br><span class="line">            result.add(path);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; leftList = pathSum(root.left, sum - root.val);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; rightList = pathSum(root.right, sum - root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftList.size() == <span class="number">0</span> &amp;&amp; rightList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; list : leftList) &#123;</span><br><span class="line">                List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                path.add(root.val);</span><br><span class="line">                path.addAll(list);</span><br><span class="line">                result.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rightList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; list : rightList) &#123;</span><br><span class="line">                List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                path.add(root.val);</span><br><span class="line">                path.addAll(list);</span><br><span class="line">                result.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> path sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 112. Path Sum</title>
      <link href="2020/05/20/LeetCode-112-Path-Sum/"/>
      <url>2020/05/20/LeetCode-112-Path-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/path-sum/">LeetCode 112. Path Sum</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵二叉树和一个sum值，根节点为root，求从root节点到叶子节点是否存在一条路径其节点之和为sum。例如：</p><pre><code>Given the below binary tree and sum = 22,      5     / \    4   8   /   / \  11  13  4 /  \      \7    2      1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>很简单的DFS的思路，中序遍历的思路，记录从根节点到当前节点的和，到达根节点时做一次判断。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> path sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1306. Jump Game III</title>
      <link href="2020/05/20/LeetCode-1306-Jump-Game-III/"/>
      <url>2020/05/20/LeetCode-1306-Jump-Game-III/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/jump-game-iii/">LeetCode 1306. Jump Game III</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个整形非负数组，初始在index为start的位置。当处于i位置时，可以跳跃到i - arr[i]或者i + arr[i]的位置。判断是否能够到达一个值为0的位置。例如：</p><pre><code>Example 1:Input: arr = [4,2,3,0,3,1,2], start = 5Output: trueExplanation: All possible ways to reach at index 3 with value 0 are: index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 Example 2:Input: arr = [3,0,2,1,2], start = 2Output: falseExplanation: There is no way to reach at index 1 with value 0.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="BFS或DFS"><a href="#BFS或DFS" class="headerlink" title="BFS或DFS"></a>BFS或DFS</h3><p>虽然这道题叫jump game，但是和之前的jump game完全不同。理由在于jump game1和2都是可以看做是动态规划问题，然后进一步简化使用Greedy。但是这道题并不是一个求极值的问题，所以不要被迷惑，这道题不能用DP，而是其他方法。</p><p>那么其实就两种情况，一种是可以顺利到达节点为0，另一种不能。如果能够到达，则最终的case则是当前节点值为0；如果不能到达，则表示全局陷入了一个循环怪圈，屡次循环却无法到达，也就是说我们某种跳跃策略一旦发现了循环的迹象，立刻终止。</p><p>与其说是图，更像是一棵树，每个节点的两个子节点为i+arr[i]和i - arr[i]，因此BFS和DFS其实都是行得通的。这里两种算法都写出来。</p><p><font color=Red>Tips: </font><br>这里运用了一个小技巧，因为arr[i]未遍历时一定大于0（除去最终的0节点），我们遍历完某节点后将其置为-arr[i]，下次再遍历到的时候，如果发现其为负值，则立刻返回false。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>DFS</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strat &lt; <span class="number">0</span> || start &gt; arr.length - <span class="number">1</span> || arr[start] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[start] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[start] = -arr[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> canReach(arr, start + arr[start]) || canReach(arr, start - arr[start]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>BFS</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.add(start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (arr[index] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] &gt; <span class="number">0</span> &amp;&amp; index - arr[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(index - arr[index]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] &gt; <span class="number">0</span> &amp;&amp; index + arr[index] &lt; arr.length) &#123;</span><br><span class="line">                queue.add(index + arr[index]);</span><br><span class="line">            &#125;</span><br><span class="line">            arr[index] = -arr[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
            <tag> bfs </tag>
            
            <tag> jump game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 45. Jump Game II</title>
      <link href="2020/05/20/LeetCode-45-Jump-Game-II/"/>
      <url>2020/05/20/LeetCode-45-Jump-Game-II/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/jump-game-ii/">LeetCode 45. Jump Game II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个整形非负数组，初始在index为0的位置，每个位置上的数代表其所能跳跃的最大长度（不是只能跳跃该长度），保证一定能够跳到末尾节点，求从0节点跳到末尾节点的最少跳跃次数。例如：</p><pre><code>Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2.    Jump 1 step from index 0 to 1, then 3 steps to the last index.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>首先，暴力求解法直接pass，我们需要遍历所有的步长，我们假设F(x)为从index为x的节点到末尾节点的最短jump数。暴力求解法伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F(x):</span><br><span class="line">    <span class="keyword">if</span> x &gt;= n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    maxStep = nums[x];</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">1</span> to maxStep:</span><br><span class="line">        memo[x] = min(memo[x], F(x + i) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> memo[x]</span><br></pre></td></tr></table></figure><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>这里我们也可以用DP来减少重复计算，对于每个节点到末尾节点最少跳跃次数设为函数F(x)，用memo数组来进行记录并更新。下面是top-down和bottom-up的两种算法。</p><p><strong>DP1 top-down：</strong></p><p>记录一个memo数组，长度为n，每个元素初始化为n（因为数组长度为n，最多跳跃次数也不过是n-1），计算F(0),对于每个0节点能到达的步长，进行比较，记录，找出最小的那个+1即为0节的最少跳跃数。</p><p><strong>DP2 bottom-up:</strong><br>记录一个memo数组，bottom-up算法就是要从base case开始进行计算，一直到目标target，本题中，base case是memo[n-1]=1，所以我们要从n-2开始往回遍历，判断n-2节点能否到达n-1节点，如果能，则memo[n-2]=1，不能则为0，一直遍历到memo[0]，返回memo[0]。</p><p>两种DP算法时间复杂度均为O(n^2)，空间复杂度为O(n)。</p><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><p>本题是要找最少的跳跃步数，也就是说我们希望每一步都尽可能要跳得远，步子迈得大。举个例子：<br>[2,3,1,1,4]，我们在0节点时，最大步长为2，因此最元能到达1和2两个节点，其最大步长分别为3和1，如果我们想走得远，我们当然希望能够第一次走到1节点，它的最大步长为3，可以到达4节点。</p><p>因此我们可以看出，对于初始节点0，它能够到达的最远为farthest为end，然后我们从0到end遍历找出其中x节点能跳到最远距离新的farthest，本次跳跃就跳到x节点，jump++，新的end为farthest，以此类推。直到最后，返回jump值。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>暴力解法（Pass，上面有伪代码）</li><li>DP top-down</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(memo, n);</span><br><span class="line">        <span class="keyword">return</span> minimumJump(nums, <span class="number">0</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minimumJump</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span>[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[x] &lt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxStep = nums[x];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxStep; i++) &#123;</span><br><span class="line">            memo[x] = Math.min(memo[x], minimumJump(nums, x + i, memo) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>DP bottom-up</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(memo, n);</span><br><span class="line">        memo[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxStep = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= maxStep; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + j &gt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                memo[i] = Math.min(memo[i], memo[i + j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Greedy</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currEnd = <span class="number">0</span>, farthest = <span class="number">0</span>, jump = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            farthest = Math.max(farthest, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == currEnd) &#123;</span><br><span class="line">                currEnd = farthest;</span><br><span class="line">                jump++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jump;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> greedy </tag>
            
            <tag> array </tag>
            
            <tag> jump game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 55. Jump Game</title>
      <link href="2020/05/20/LeetCode-55-Jump-Game/"/>
      <url>2020/05/20/LeetCode-55-Jump-Game/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/jump-game/">LeetCode 55. Jump Game</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个整形非负数组，初始在index为0的位置，每个位置上的数代表其所能跳跃的最大长度（不是只能跳跃该长度），问是否能够跳到达数组末尾位置。例如：</p><pre><code>Example 1:Input: nums = [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:Input: nums = [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>首先，我们能想到的最傻的办法就是暴力求解。设函数F(x)为从x节点能否到达尾结点，我们假设从0开始，0节点的最大jump值为5，然后我们将步长step从1到5进行遍历，如果能够达到末尾节点，则为0，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">F(x) :</span><br><span class="line">    <span class="keyword">if</span> x &gt;= n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    step = nums[x]</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">1</span> to step:</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">F</span><span class="params">(x + i)</span>:</span></span><br><span class="line"><span class="function">            return <span class="keyword">true</span></span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>最坏情况，时间复杂度为O(2^n)，空间复杂度O(n)。</p><p>对于暴力破解法显然是不优雅的，每次只遍历一步，而且存在大量的重复计算，比如对于这种情况：<br>Index | 0 | 1 | 2 | 3 | 4 | 5 | 6<br>— | — | — | — | — | — | — | —<br>nums | 5 | 4 |  3 | 2 | 1 | 0 | 0<br>从index为0开始时，首次步长为1，跳转到index为1，再到index为2，以此类推，最终返回的时候我们知道步长为1时，无法到达末尾位置；然后我们调整步长为2，此时，我们直接到index为2的节点，判断位置为2的节点能否到达末尾，但是实际上，在我们计算步长为1的时候，index为2位置能否到达末尾节点我们已经知晓了，是false的，其实没必要计算，这个就是我们需要DP来优化的子问题。</p><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p><strong>DP1 top-down：</strong></p><p>记录一个memo数组，长度为n，表示index处能否到达末尾位置，memo[n-1]为1，其余初始为0。然后开始递归调用，top-down的算法都是要递归的。</p><p><strong>DP2 bottom-up:</strong><br>记录一个memo数组，bottom-up算法就是要从base case开始进行计算，一直到目标target，本题中，base case是memo[n-1]=1，所以我们要从n-2开始往回遍历，判断n-2节点能否到达n-1节点，如果能，则memo[n-2]=1，不能则为0，一直遍历到memo[0]，返回memo[0]。</p><p>两种DP算法时间复杂度均为O(n^2)，空间复杂度为O(n)。</p><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><p>本题的最优解为贪心法，那么什么情况下应该使用贪心法呢？其实贪心法算是动态规划的一种特殊形式，贪心法是要找出当前的最优解，而当前的最优解却不一定是全局最优解，这个在后面的题目中再慢慢体会。</p><p>所以我们记录一个farthest表示从0到当前节点，所能到达的最大index。<br>$$farthest=max(i+nums[i],farthest) (0&lt;=i&lt;n-1)$$</p><p>这里我们需要注意一种情况，正如之前的例子，如果不能到达末尾节点，中间一定有某个为0的节点，且该节点的所有前置节点最远只能到达该节点。所以每次遍历时，需要判断farthest和i的关系，如果 farthest&lt;=i 则代表i节点为0且无法到达后面的节点了。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>暴力解法（直接抄leetcode上的solution了）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> furthestJump = Math.min(position + nums[position], nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nextPosition = position + <span class="number">1</span>; nextPosition &lt;= furthestJump; nextPosition++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>DP top-down</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line">    GOOD, BAD, UNKNOWN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Index[] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[position] != Index.UNKNOWN) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[position] == Index.GOOD ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> furthestJump = Math.min(position + nums[position], nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nextPosition = position + <span class="number">1</span>; nextPosition &lt;= furthestJump; nextPosition++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class="line">                memo[position] = Index.GOOD;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo[position] = Index.BAD;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> Index[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memo.length; i++) &#123;</span><br><span class="line">            memo[i] = Index.UNKNOWN;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[memo.length - <span class="number">1</span>] = Index.GOOD;</span><br><span class="line">        <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>DP bottom-up</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line">    GOOD, BAD, UNKNOWN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Index[] memo = <span class="keyword">new</span> Index[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memo.length; i++) &#123;</span><br><span class="line">            memo[i] = Index.UNKNOWN;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[memo.length - <span class="number">1</span>] = Index.GOOD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> furthestJump = Math.min(i + nums[i], nums.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= furthestJump; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (memo[j] == Index.GOOD) &#123;</span><br><span class="line">                    memo[i] = Index.GOOD;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>] == Index.GOOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Greedy</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> farthest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            farthest = Math.max(farthest, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (farthest &gt;= nums.length-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (farthest &lt;= i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> farthest &gt;= nums.length-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> greedy </tag>
            
            <tag> array </tag>
            
            <tag> jump game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用数据结构总结</title>
      <link href="2020/05/19/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
      <url>2020/05/19/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h1><h2 id="1-1-增删改查"><a href="#1-1-增删改查" class="headerlink" title="1.1 增删改查"></a>1.1 增删改查</h2><table><thead><tr><th>方法</th><th>ArrayList</th></tr></thead><tbody><tr><td>初始化</td><td>List&lt;X&gt; arrayList = new ArrayList();<br>List&lt;X&gt; arrayList = new ArrayList(initialSize);<br> List&lt;X&gt; arrayList = new ArrayList(Collection)<br> 备注：Collection包括List、ArrayList、Vector、LinkedList、Set、HashSet、TreeSet;</td></tr><tr><td>增</td><td>**add(E e)**：该方法是将指定的元素添加到列表的尾部。当容量不足时，会调用 grow 方法增长容量。<br> **add(int index, E element)**：在 index 位置插入 element,注意这个不是覆盖，会把后面的元素都向后靠一个位置。<br> **addAll(Collection&lt;? extends E&gt; c) 和 addAll(int index, Collection&lt;? extends E&gt; c)**：将特定 Collection 中的元素添加到 Arraylist 末尾。</td></tr><tr><td>删</td><td><strong>boolean remove(int index)</strong>: 该方法首先调用rangeCheck(index)来校验 index 变量是否超出数组范围，超出则抛出异常。删除第index个元素，整体左移，返回oldValue。<br> <strong>boolean remove(Object o)</strong>: 删除list中首次出现的元素o（可以为null），返回boolean值，成功为true，失败为false。<br> <strong>clear()</strong>: 从列表中移除所有元素。 <br> <strong>removeAll(Collection&lt;? extends E&gt; c)</strong>: 从列表中移除指定 collection 中包含的所有元素。</td></tr><tr><td>改</td><td>**set(int index, E element)**：该方法首先调用rangeCheck(index)来校验 index 变量是否超出数组范围，超出则抛出异常。而后，取出原 index 位置的值，并且将新的 element 放入 Index 位置，返回 oldValue。</td></tr><tr><td>查</td><td><strong>get(int index)</strong>:查找第index个元素并返回。<br> <strong>indexOf(Object o)</strong>:返回列表中首次出现指定元素的索引,如果列表不包含此元素,则返回 -1。<br> <strong>lastIndexOf(Object o)</strong>:返回列表中最后一次出现指定元素的索引,如果列表不包含此元素,则返回 -1。<br> <strong>List subList(int fromIndex, int toIndex)</strong>: 返回列表中指定的fromIndex(包括)和toIndex(不包括)之间的部分。<br> <strong>toArray()</strong>: 返回以正确顺序包含列表中的所有元素的数组。</td></tr></tbody></table><h2 id="1-2-遍历"><a href="#1-2-遍历" class="headerlink" title="1.2 遍历"></a>1.2 遍历</h2><p>3种遍历方式：</p><h3 id="1-2-1-for循环下标遍历"><a href="#1-2-1-for循环下标遍历" class="headerlink" title="1.2.1 for循环下标遍历"></a>1.2.1 for循环下标遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-for循环直接遍历"><a href="#1-2-2-for循环直接遍历" class="headerlink" title="1.2.2 for循环直接遍历"></a>1.2.2 for循环直接遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String tmp : list)&#123;</span><br><span class="line">    System.out.println(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-iterator遍历"><a href="#1-2-3-iterator遍历" class="headerlink" title="1.2.3 iterator遍历"></a>1.2.3 iterator遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator it2 = list.iterator();it2.hasNext();)&#123;</span><br><span class="line">    System.out.println(it2.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-排序"><a href="#1-3-排序" class="headerlink" title="1.3 排序"></a>1.3 排序</h2><p>这里只使用Collections.sort()方法，默认是升序，如需要降序，则需要重写Comparator。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortArrayListAscendingDescending</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList arrayList;</span><br><span class="line">    <span class="comment">// 升序排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">sortAscending</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collections.sort(<span class="keyword">this</span>.arrayList);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 降序排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">sortDescending</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collections.sort(<span class="keyword">this</span>.arrayList, Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何重写comparator，使用comparator排序呢？这里需要重写compare方法，比较o1和o2两个对象，返回int值，默认的升序排序规则是：如果o1 &gt; o2返回1，o1 &lt; o2返回-1，o1 == o2返回0。下面代码是降序排序器的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mycomparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 &lt; o2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o1 &gt; o2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(-<span class="number">1</span>);</span><br><span class="line">        Comparator comp = <span class="keyword">new</span> Mycomparator();</span><br><span class="line">        Collections.sort(list, comp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-HashMap-amp-HashTable"><a href="#2-HashMap-amp-HashTable" class="headerlink" title="2. HashMap &amp; HashTable"></a>2. HashMap &amp; HashTable</h1><h1 id="3-HashSet"><a href="#3-HashSet" class="headerlink" title="3. HashSet"></a>3. HashSet</h1><h2 id="3-0-实现原理"><a href="#3-0-实现原理" class="headerlink" title="3.0 实现原理"></a>3.0 实现原理</h2><p>HashSet的底层实现是由HashMap来实现的，对于其所添加的对象，可能用到以下几种方法。</p><ol><li>equals()方法<br>用来实现Set中元素的不重复性，如果不覆盖（override）equals()方法，默认使用父类Object的equals方法，则只是比较对象的引用是否相同。</li><li>hashCode()<br>hashCode()方法时为了实现HashSet和LinkedHashSet而实现的。只有知道对象的hash值，才能根据这个hash值确定 存放在散列表的槽的index。同样，如果不覆盖（override）hashCode()方法，默认使用父类Object的hashCode()方法。</li><li>toString()方法<br>toString()方法在打印对象时会调用。如果不覆盖（override）toString()方法，默认使用父类Object的。</li><li>compareTo()方法<br>用户类要实现Comparable接口。这个方法主要用于将对象存放在TreeSet()时保证顺序的。由于是接口，所以用户类必须要实现这个方法。 </li></ol><p><strong>继承关系：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|--HashSet 底层是由HashMap实现的，通过对象的hashCode方法与equals方法来保证插入元素的唯一性，无序(存储顺序和取出顺序不一致)，。</span><br><span class="line"><span class="code">    |--LinkedHashSet 底层数据结构由哈希表和链表组成。哈希表保证元素的唯一性，链表保证元素有序。(存储和取出是一致)</span></span><br></pre></td></tr></table></figure><p><strong>实现原理:</strong></p><p>往Haset添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中的存储位置。见下面2种情况：</p><ol><li>如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。</li><li>如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行添加。</li></ol><h2 id="3-1-增删改查"><a href="#3-1-增删改查" class="headerlink" title="3.1 增删改查"></a>3.1 增删改查</h2><table><thead><tr><th>方法</th><th>HashSet</th></tr></thead><tbody><tr><td>初始化</td><td><strong>HashSet()</strong> 构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。<br> <strong>HashSet(Collection&lt;? extends E&gt; c)</strong> 构造一个包含指定 collection 中的元素的新 set。<br> <strong>HashSet(int initialCapacity)</strong> 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。<br> <strong>HashSet(int initialCapacity, float loadFactor)</strong> 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子。 <br>备注：Collection包括List、ArrayList、Vector、LinkedList、Set、HashSet、TreeSet;</td></tr><tr><td>增</td><td><strong>boolean add(Object o)：</strong> 该方法用于向集合里添加一个元素。<br><strong>boolean addAll(Collection c)：</strong> 该方法把集合c里的所有元素添加到指定集合里。</td></tr><tr><td>删</td><td><strong>void clear()：</strong> 清除集合里的所有元素，将集合长度变为0。<br> <strong>boolean remove(Object o)：</strong> 删除集合中的指定元素o，当集合中包含了一个或多个元素o时，这些元素将被删除，该方法将返回true。<br> <strong>boolean removeAll(Collection c)：</strong> 将集合中删除集合c里包含的所有元素（相当于用调用该方法的集合减集合c），如果删除了一个或一个以上的元素，则该方法返回true。<br> <strong>boolean retainAll(Collection c)：</strong> 将集合中删除集合c里不包含的元素（相当于把调用该方法的集合变成该集合的集合c的交集），如果该操作改变了调用该方法的集合，则该方法返回true。</td></tr><tr><td>改</td><td><strong>Object[] toArray()：</strong> 该方法把集合转换成一个数组，所有的集合元素变成对应的数组元素。</td></tr><tr><td>查</td><td><strong>boolean contains(Object o)：</strong> 返回集合里是否包含指定元素。<br> <strong>boolean containsAll(Collection c)：</strong> 返回集合里是否包含集合c里的所有元素。</td></tr></tbody></table><h2 id="3-2-遍历"><a href="#3-2-遍历" class="headerlink" title="3.2 遍历"></a>3.2 遍历</h2><ol><li>Iterator迭代方式遍历</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();  </span><br><span class="line">set.add(<span class="string">&quot;aaa&quot;</span>);  </span><br><span class="line">set.add(<span class="string">&quot;bbb&quot;</span>);  </span><br><span class="line">set.add(<span class="string">&quot;ccc&quot;</span>);    </span><br><span class="line">Iterator iterator = set.iterator();  </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>for循环方式遍历</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();  </span><br><span class="line">set.add(<span class="string">&quot;aaa&quot;</span>);  </span><br><span class="line">set.add(<span class="string">&quot;bbb&quot;</span>);  </span><br><span class="line">set.add(<span class="string">&quot;ccc&quot;</span>);  </span><br><span class="line"><span class="keyword">for</span> (String s:set) &#123;  </span><br><span class="line">System.out.println(s);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-排序"><a href="#3-3-排序" class="headerlink" title="3.3 排序"></a>3.3 排序</h2><h1 id="4-Queue"><a href="#4-Queue" class="headerlink" title="4. Queue"></a>4. Queue</h1><h1 id="5-Stack"><a href="#5-Stack" class="headerlink" title="5. Stack"></a>5. Stack</h1><h1 id="6-Heap"><a href="#6-Heap" class="headerlink" title="6. Heap"></a>6. Heap</h1><h1 id="7-TreeMap"><a href="#7-TreeMap" class="headerlink" title="7. TreeMap"></a>7. TreeMap</h1>]]></content>
      
      
      <categories>
          
          <category> 知识点总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
            <tag> list </tag>
            
            <tag> map </tag>
            
            <tag> queue </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题日志</title>
      <link href="2020/05/19/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/"/>
      <url>2020/05/19/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="刷题日志"><a href="#刷题日志" class="headerlink" title="刷题日志"></a>刷题日志</h1><h2 id="一-刷题数目汇总"><a href="#一-刷题数目汇总" class="headerlink" title="一. 刷题数目汇总"></a>一. 刷题数目汇总</h2><table><thead><tr><th>专项</th><th>总计</th></tr></thead><tbody><tr><td>数组</td><td>25</td></tr><tr><td>动态规划</td><td>9</td></tr><tr><td>贪心法</td><td>6</td></tr><tr><td>字符串</td><td>6</td></tr><tr><td>数学运算</td><td>8</td></tr><tr><td>树</td><td>50</td></tr><tr><td>链表</td><td>3</td></tr><tr><td>哈希表</td><td>11</td></tr><tr><td>图</td><td>2</td></tr><tr><td>二分法</td><td>4</td></tr><tr><td>搜索（回溯、BFS、DFS）</td><td>4</td></tr><tr><td>双指针</td><td>11</td></tr><tr><td>排序</td><td>2</td></tr><tr><td>堆</td><td>4</td></tr><tr><td>栈</td><td>9</td></tr><tr><td>分治法</td><td>2</td></tr><tr><td>Union-Find</td><td>1</td></tr><tr><td>滑动窗口</td><td>2</td></tr><tr><td>其他</td><td></td></tr><tr><td>总计（有重叠）</td><td>182</td></tr></tbody></table><h2 id="二-面试前必看经典题目汇总"><a href="#二-面试前必看经典题目汇总" class="headerlink" title="二. 面试前必看经典题目汇总"></a>二. 面试前必看经典题目汇总</h2><h3 id="DP类"><a href="#DP类" class="headerlink" title="DP类"></a>DP类</h3><ol start="0"><li><p>基础类题目<br></p></li><li><p>字符串变换、正则匹配、字符串匹配</p></li><li><p>Target Sum、背包问题（二者还是有点区别的，target sum里面可以有负值）<br></p><a href="/2020/06/07/LeetCode-322-Coin-Change/" title="LeetCode 322. Coin Change">LeetCode 322. Coin Change</a><br><a href="/2020/06/08/LeetCode-416-Partition-Equal-Subset-Sum/" title="LeetCode 416. Partition Equal Subset Sum">LeetCode 416. Partition Equal Subset Sum</a></li><li><p>Unique Path</p></li><li><p>二维转一维<br></p><a href="/2020/06/19/LeetCode-1105-Filling-Bookcase-Shelves/" title="LeetCode 1105. Filling Bookcase Shelves">LeetCode 1105. Filling Bookcase Shelves</a></li></ol><h3 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h3><ol><li>区间相关<br></li><li>删除重复数字<br></li></ol><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><ol start="0"><li>基本模板及基本题目<br><a href="/2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="二分搜索基础">二分搜索基础</a></li><li>Upper Bound(右边界)</li><li>Lower Bound(左边界)</li></ol><h3 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h3><ol><li>链表合并<br><a href="/2020/06/03/LeetCode-21-Merge-Two-Sorted-Lists/" title="LeetCode 21. Merge Two Sorted Lists">LeetCode 21. Merge Two Sorted Lists</a><br><a href="/2020/06/03/LeetCode-23-Merge-k-Sorted-Lists/" title="LeetCode 23. Merge k Sorted Lists">LeetCode 23. Merge k Sorted Lists</a> <br></li><li>链表找环<br><a href="/2020/06/03/LeetCode-141-Linked-List-Cycle/" title="LeetCode 141. Linked List Cycle">LeetCode 141. Linked List Cycle</a> <br> <a href="/2020/06/03/LeetCode-142-Linked-List-Cycle-II/" title="LeetCode 142. Linked List Cycle II">LeetCode 142. Linked List Cycle II</a></li><li>翻转链表<br><a href="/2020/06/03/LeetCode-206-Reverse-Linked-List/" title="LeetCode 206. Reverse Linked List">LeetCode 206. Reverse Linked List</a> <br><a href="/2020/06/03/LeetCode-92-Reverse-Linked-List-II/" title="LeetCode 92. Reverse Linked List II">LeetCode 92. Reverse Linked List II</a> <br><a href="/2020/06/03/LeetCode-24-Swap-Nodes-in-Pairs/" title="LeetCode 24. Swap Nodes in Pairs">LeetCode 24. Swap Nodes in Pairs</a></li><li>链表加和<br><a href="/2020/06/03/LeetCode-2-Add-Two-Numbers/" title="“LeetCode 2. Add Two Numbers”">“LeetCode 2. Add Two Numbers”</a><br><a href="/2020/06/03/LeetCode-445-Add-Two-Numbers-II/" title="“LeetCode 445. Add Two Numbers II”">“LeetCode 445. Add Two Numbers II”</a></li><li>删除重复节点<br></li></ol><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><ol><li>组合（Combination Sum）<br><a href="/2020/05/24/LeetCode-39-Combination-Sum/" title="LeetCode 39. Combination Sum">LeetCode 39. Combination Sum</a><br> <a href="/2020/05/24/LeetCode-40-Combination-Sum-II/" title="LeetCode 40. Combination Sum II">LeetCode 40. Combination Sum II</a><br> <a href="/2020/05/24/LeetCode-216-Combination-Sum-III/" title="LeetCode 216. Combination Sum III">LeetCode 216. Combination Sum III</a><br><a href="/2020/05/24/LeetCode-377-Combination-Sum-IV/" title="LeetCode 377. Combination Sum IV">LeetCode 377. Combination Sum IV</a></li><li>子集合<br><a href="/2020/06/04/LeetCode-78-Subsets/" title="LeetCode 78. Subsets">LeetCode 78. Subsets</a><br><a href="/2020/06/04/LeetCode-90-Subsets-II/" title="LeetCode 90. Subsets II">LeetCode 90. Subsets II</a></li><li>全排列<br><a href="/2020/06/05/LeetCode-46-Permutations/" title="LeetCode 46. Permutations">LeetCode 46. Permutations</a><br><a href="/2020/06/05/LeetCode-47-Permutations-II/" title="LeetCode 47. Permutations II">LeetCode 47. Permutations II</a><br><a href="/2020/06/04/LeetCode-31-Next-Permutation/" title="LeetCode 31. Next Permutation">LeetCode 31. Next Permutation</a><br><a href="/2020/06/18/LeetCode-556-Next-Greater-Element-III/" title="LeetCode 556. Next Greater Element III">LeetCode 556. Next Greater Element III</a></li><li>数独<br><a href="/2020/06/19/LeetCode-37-Sudoku-Solver/" title="LeetCode 37. Sudoku Solver">LeetCode 37. Sudoku Solver</a></li></ol><h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><h3 id="图（Graph）"><a href="#图（Graph）" class="headerlink" title="图（Graph）"></a>图（Graph）</h3><ol><li>二分图<br><a href="/2020/05/28/LeetCode-785-Is-Graph-Bipartite/" title="LeetCode-785-Is-Graph-Bipartite">LeetCode-785-Is-Graph-Bipartite</a> <br><a href="/2020/05/28/LeetCode-886-Possible-Bipartition/" title="LeetCode 886. Possible Bipartition">LeetCode 886. Possible Bipartition</a> <br><a href="/2020/05/28/LeetCode-1042-Flower-Planting-With-No-Adjacent/" title="LeetCode 1042. Flower Planting With No Adjacent">LeetCode 1042. Flower Planting With No Adjacent</a></li><li>拷贝图<br><a href="/2020/05/28/LeetCode-138-Copy-List-with-Random-Pointer/" title="LeetCode 138. Copy List with Random Pointer">LeetCode 138. Copy List with Random Pointer</a> <br> <a href="/2020/05/28/LeetCode-133-Clone-Graph/" title="LeetCode 133. Clone Graph">LeetCode 133. Clone Graph</a></li><li>拓扑排序<br><a href="/2020/05/31/LeetCode-207-Course-Schedule/" title="“LeetCode 207. Course Schedule”">“LeetCode 207. Course Schedule”</a> <br><a href="/2020/05/31/LeetCode-210-Course-Schedule-II/" title="LeetCode 210. Course Schedule II">LeetCode 210. Course Schedule II</a></li><li>grid + 连通分量</li><li>DFS + 连通分量</li></ol><h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h3><ol><li>Unique二叉搜索树<br><a href="/2020/05/17/LeetCode-95-Unique-Binary-Search-Trees-II/" title="LeetCode 95">LeetCode 95</a> <br> <a href="/2020/05/17/LeetCode-96-Unique-Binary-Search-Trees/" title="LeetCode 96">LeetCode 96</a> <br></li><li>二叉树遍历<br><a href="/2020/05/17/LeetCode-94-Binary-Tree-Inorder-Traversal/" title="LeetCode 94">LeetCode 94</a> <br> <a href="/2020/05/17/LeetCode-144-Binary-Tree-Preorder-Traversal/" title="LeetCode 144">LeetCode 144</a> <br> <a href="/2020/05/17/LeetCode-145-Binary-Tree-Postorder-Traversal/" title="LeetCode 145">LeetCode 145</a> <br> <a href="/2020/05/18/LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/" title="LeetCode 105">LeetCode 105</a> </li><li>最低公共祖先<br> <a href="/2020/05/18/LeetCode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/" title="LeetCode 235">LeetCode 235</a> <br> <a href="/2020/05/18/LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/" title="LeetCode 236">LeetCode 236</a> <br></li></ol><h3 id="Union-Find类"><a href="#Union-Find类" class="headerlink" title="Union-Find类"></a>Union-Find类</h3><ol><li><a href="/2020/06/07/LeetCode-399-Evaluate-Division/" title="LeetCode 399. Evaluate Division（待完成）">LeetCode 399. Evaluate Division（待完成）</a> </li></ol><h2 id="三-刷题详细记录"><a href="#三-刷题详细记录" class="headerlink" title="三.刷题详细记录"></a>三.刷题详细记录</h2><table><thead><tr><th>日期</th><th>题目</th></tr></thead><tbody><tr><td>更早</td><td><a href="/2020/05/17/LeetCode-94-Binary-Tree-Inorder-Traversal/" title="LeetCode 94">LeetCode 94</a> <br> <a href="/2020/05/17/LeetCode-95-Unique-Binary-Search-Trees-II/" title="LeetCode 95">LeetCode 95</a> <br> <a href="/2020/05/17/LeetCode-96-Unique-Binary-Search-Trees/" title="LeetCode 96">LeetCode 96</a> <br> <a href="/2020/05/18/LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/" title="LeetCode 105">LeetCode 105</a> <br> <a href="/2020/05/17/LeetCode-144-Binary-Tree-Preorder-Traversal/" title="LeetCode 144">LeetCode 144</a> <br> <a href="/2020/05/17/LeetCode-145-Binary-Tree-Postorder-Traversal/" title="LeetCode 145">LeetCode 145</a> <br> <a href="/2020/05/17/LeetCode-173-Binary-Search-Tree-Iterator/" title="LeetCode 173">LeetCode 173</a> <br> <a href="/2020/05/18/LeetCode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/" title="LeetCode 235">LeetCode 235</a> <br> <a href="/2020/05/18/LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/" title="LeetCode 236">LeetCode 236</a> <br> <a href="/2020/05/18/LeetCode-270-Closest-Binary-Search-Tree-Value/" title="LeetCode 270">LeetCode 270</a> <br> <a href="/2020/05/18/LeetCode-272-Closest-Binary-Search-Tree-Value-II/" title="LeetCode 272">LeetCode 272</a> <br> <a href="/2020/05/17/LeetCode-297-Serialize-and-Deserialize-Binary-Tree/" title="LeetCode 297">LeetCode 297</a> <br> <a href="/2020/05/17/LeetCode-328-Odd-Even-Linked-List/" title="LeetCode 328">LeetCode 328</a> <br> <a href="/2020/05/17/LeetCode-402%EF%BC%9ARemove-K-Digits/" title="LeetCode 402">LeetCode 402</a> <br> <a href="/2020/05/17/LeetCode-438-Find-All-Anagrams-in-a-String/" title="LeetCode 438">LeetCode 438</a> <br> <a href="/2020/05/17/LeetCode-532-K-diff-Pairs-in-an-Array/" title="LeetCode 532">LeetCode 532</a> <br> <a href="/2020/05/18/LeetCode-567-Permutation-in-String/" title="LeetCode 567">LeetCode 567</a> <br> <a href="/2020/05/17/LeetCode-637-Average-of-Levels-in-Binary-Tree/" title="LeetCode 637">LeetCode 637</a> <br> <a href="/2020/05/17/LeetCode-918-Maximum-Sum-Circular-Subarray/" title="LeetCode 918">LeetCode 918</a></td></tr><tr><td>2020.05.19 <br> (DP) <br>(4)</td><td><a href="/2020/05/20/LeetCode-55-Jump-Game/" title="LeetCode 55. Jump Game">LeetCode 55. Jump Game</a><br> <a href="/2020/05/20/LeetCode-45-Jump-Game-II/" title="LeetCode 45. Jump Game II">LeetCode 45. Jump Game II</a><br> <a href="/2020/05/20/LeetCode-1306-Jump-Game-III/" title="LeetCode 1306. Jump Game III">LeetCode 1306. Jump Game III</a><br> <a href="https://leetcode.com/problems/online-stock-span/">LeetCode 901. Online Stock Span(无解析)</a></td></tr><tr><td>2020.05.20 <br> (Tree) <br> (6)</td><td><a href="/2020/05/20/LeetCode-112-Path-Sum/" title="LeetCode 112. Path Sum">LeetCode 112. Path Sum</a><br> <a href="/2020/05/20/LeetCode-113-Path-Sum-II/" title="LeetCode 113. Path Sum II">LeetCode 113. Path Sum II</a><br> <a href="/2020/05/21/LeetCode-437-Path-Sum-III/" title="LeetCode 437. Path Sum III">LeetCode 437. Path Sum III</a><br> <a href="/2020/05/21/LeetCode-666-Path-Sum-IV/" title="LeetCode 666. Path Sum IV">LeetCode 666. Path Sum IV</a><br><a href="/2020/05/20/LeetCode-129-Sum-Root-to-Leaf-Numbers/" title="LeetCode 129. Sum Root to Leaf Numbers">LeetCode 129. Sum Root to Leaf Numbers</a><br><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">LeetCode 230. Kth Smallest Element in a BST(无解析)</a></td></tr><tr><td>2020.05.21</td><td><a href="/2020/05/21/LeetCode-1277-Count-Square-Submatrices-with-All-Ones/" title="LeetCode 1277. Count Square Submatrices with All Ones">LeetCode 1277. Count Square Submatrices with All Ones</a></td></tr><tr><td>2020.05.22 <br>(Tree) <br> (6)</td><td><a href="/2020/05/22/LeetCode-450-Delete-Node-in-a-BST/" title="LeetCode 450. Delete Node in a BST">LeetCode 450. Delete Node in a BST</a><br> <a href="/2020/05/22/LeetCode-508-Most-Frequent-Subtree-Sum/" title="LeetCode 508. Most Frequent Subtree Sum">LeetCode 508. Most Frequent Subtree Sum</a><br> <a href="/2020/05/22/LeetCode-814-Binary-Tree-Pruning/" title="LeetCode 814. Binary Tree Pruning">LeetCode 814. Binary Tree Pruning</a><br><a href="/2020/05/22/LeetCode-968-Binary-Tree-Cameras/" title="LeetCode 968. Binary Tree Cameras">LeetCode 968. Binary Tree Cameras</a><br> <a href="/2020/05/22/LeetCode-451-Sort-Characters-By-Frequency/" title="LeetCode 451. Sort Characters By Frequency">LeetCode 451. Sort Characters By Frequency</a><br><a href="https://leetcode.com/problems/same-tree/">LeetCode 100. Same Tree(无解析)</a></td></tr><tr><td>2020.05.23 <br>(Search) <br> (5)</td><td><a href="/2020/05/24/LeetCode-39-Combination-Sum/" title="LeetCode 39. Combination Sum">LeetCode 39. Combination Sum</a><br> <a href="/2020/05/24/LeetCode-40-Combination-Sum-II/" title="LeetCode 40. Combination Sum II">LeetCode 40. Combination Sum II</a><br> <a href="/2020/05/24/LeetCode-216-Combination-Sum-III/" title="LeetCode 216. Combination Sum II">LeetCode 216. Combination Sum II</a><br><a href="/2020/05/24/LeetCode-377-Combination-Sum-IV/" title="LeetCode 377. Combination Sum IV">LeetCode 377. Combination Sum IV</a><br> <a href="/2020/05/24/LeetCode-986-Interval-List-Intersections/" title="LeetCode 986. Interval List Intersections">LeetCode 986. Interval List Intersections</a></td></tr><tr><td>2020.05.24 <br>(Weekly Contest) <br>(5)</td><td><a href="https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/">LeetCode 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence(无解析)</a><br> <a href="/2020/05/24/LeetCode-1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/" title="LeetCode 1456. Maximum Number of Vowels in a Substring of Given Length">LeetCode 1456. Maximum Number of Vowels in a Substring of Given Length</a><br> <a href="/2020/05/24/LeetCode-1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree/" title="LeetCode 1457. Pseudo-Palindromic Paths in a Binary Tree">LeetCode 1457. Pseudo-Palindromic Paths in a Binary Tree</a><br><a href="/2020/05/24/LeetCode-1458-Max-Dot-Product-of-Two-Subsequences/" title="LeetCode 1458. Max Dot Product of Two Subsequences">LeetCode 1458. Max Dot Product of Two Subsequences</a><br> <a href="/2020/05/24/LeetCode-1008-Construct-Binary-Search-Tree-from-Preorder-Traversal/" title="LeetCode 1008. Construct Binary Search Tree from Preorder Traversal">LeetCode 1008. Construct Binary Search Tree from Preorder Traversal</a></td></tr><tr><td>2020.05.25 <br>(DP) <br>(9)</td><td><a href="/2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80/" title="动态规划一">动态规划一</a><br><a href="/2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80/" title="LeetCode 53. Maximum Subarray">LeetCode 53. Maximum Subarray</a><br> <a href="/2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80/" title="LeetCode 70. Climbing Stairs">LeetCode 70. Climbing Stairs</a><br><a href="/2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80/" title="LeetCode 121. Best Time to Buy and Sell Stock">LeetCode 121. Best Time to Buy and Sell Stock</a><br><a href="/2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80/" title="LeetCode 198. House Robber">LeetCode 198. House Robber</a><br><a href="/2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80/" title="LeetCode 303. Range Sum Query - Immutable">LeetCode 303. Range Sum Query - Immutable</a><br><a href="/2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80/" title="LeetCode 746. Min Cost Climbing Stairs">LeetCode 746. Min Cost Climbing Stairs</a><br><a href="/2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80/" title="LeetCode 1137. N-th Tribonacci Number">LeetCode 1137. N-th Tribonacci Number</a><br> <a href="/2020/05/26/LeetCode-1035-Uncrossed-Lines/" title="LeetCode 1035. Uncrossed Lines">LeetCode 1035. Uncrossed Lines</a><br> <a href="/2020/05/26/LeetCode-1218-Longest-Arithmetic-Subsequence-of-Given-Difference/" title="LeetCode 1218. Longest Arithmetic Subsequence of Given Difference">LeetCode 1218. Longest Arithmetic Subsequence of Given Difference</a></td></tr><tr><td>2020.05.26 <br>(二分搜索) <br>(6)</td><td><a href="/2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="二分搜索">二分搜索</a><br><a href="/2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="LeetCode 69. Sqrt(x)">LeetCode 69. Sqrt(x)</a><br> <a href="/2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="LeetCode 367. Valid Perfect Square">LeetCode 367. Valid Perfect Square</a><br><a href="/2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="LeetCode 35. Search Insert Position">LeetCode 35. Search Insert Position</a><br><a href="/2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="LeetCode 34. Find First and Last Position of Element in Sorted Array">LeetCode 34. Find First and Last Position of Element in Sorted Array</a><br><a href="/2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="LeetCode 50. Pow(x, n)">LeetCode 50. Pow(x, n)</a><br> <a href="/2020/05/27/LeetCode-525-Contiguous-Array/" title="LeetCode 525. Contiguous Array（每日一题）">LeetCode 525. Contiguous Array（每日一题）</a></td></tr><tr><td>2020.05.27 <br>(被33题和81题折磨，一天了也没搞懂)</td><td>下次做二分查找时的题目：33、81、153、154、162、852、1011) <br></td></tr><tr><td>2020.05.28 <br>(Graph) <br>(6)</td><td><a href="/2020/05/28/%E5%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" title="图算法总结（二分图&#x2F;BFS&#x2F;DFS&#x2F;深拷贝图）">图算法总结（二分图&#x2F;BFS&#x2F;DFS&#x2F;深拷贝图）</a><br>1. <a href="/2020/05/28/LeetCode-785-Is-Graph-Bipartite/" title="LeetCode-785-Is-Graph-Bipartite">LeetCode-785-Is-Graph-Bipartite</a> <br>2. <a href="/2020/05/28/LeetCode-886-Possible-Bipartition/" title="LeetCode 886. Possible Bipartition">LeetCode 886. Possible Bipartition</a> <br>3. <a href="/2020/05/28/LeetCode-1042-Flower-Planting-With-No-Adjacent/" title="LeetCode 1042. Flower Planting With No Adjacent">LeetCode 1042. Flower Planting With No Adjacent</a><br> 4. <a href="/2020/05/28/LeetCode-138-Copy-List-with-Random-Pointer/" title="LeetCode 138. Copy List with Random Pointer">LeetCode 138. Copy List with Random Pointer</a> <br> 5. <a href="/2020/05/28/LeetCode-133-Clone-Graph/" title="LeetCode 133. Clone Graph">LeetCode 133. Clone Graph</a> <br>6. <a href="/2020/05/28/LeetCode-338-Counting-Bits/" title="LeetCode 338. Counting Bits">LeetCode 338. Counting Bits</a></td></tr><tr><td>2020.05.29 <br>(String) <br>(8)</td><td><a href="/2020/05/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93/" title="字符串总结">字符串总结</a><br>1. <a href="/2020/05/30/LeetCode-516-Longest-Palindromic-Subsequence/" title="“LeetCode 516 最长回文子序列”">“LeetCode 516 最长回文子序列”</a><br>2. <a href="/2020/05/30/LeetCode-647-Palindromic-Substrings/" title="“LeetCode 647 回文子字符串数”">“LeetCode 647 回文子字符串数”</a> <br>3. <a href="/2020/05/30/LeetCode-5-Longest-Palindromic-Substring/" title="最长回文子字符串">最长回文子字符串</a><br> 4. <a href="https://leetcode.com/problems/reverse-words-in-a-string/">LeetCode 151. Reverse Words in a String(无解析)</a> <br> 5. <a href="https://leetcode.com/problems/valid-palindrome/">LeetCode 125. Valid Palindrome(无解析)</a> <br>6. <a href="https://leetcode.com/problems/reverse-string/">LeetCode 344. Reverse String(无解析)</a> 7. <a href="/2020/05/30/LeetCode-14-Longest-Common-Prefix/" title="LeetCode 14. Longest Common Prefix">LeetCode 14. Longest Common Prefix</a><br> 8. <a href="/2020/05/30/LeetCode-28-Implement-strStr/" title="LeetCode 28. Implement strStr()">LeetCode 28. Implement strStr()</a></td></tr><tr><td>2020.05.30 <br> 2020.05.31 <br> 2020.06.01 <br> 2020.06.02 <br>(DP &amp; 杂项) <br>(总计:156)</td><td>1. <a href="/2020/06/02/LeetCode-72-Edit-Distance/" title="“LeetCode 72. Edit Distance”">“LeetCode 72. Edit Distance”</a><br>2. <a href="/2020/05/31/LeetCode-207-Course-Schedule/" title="“LeetCode 207. Course Schedule”">“LeetCode 207. Course Schedule”</a> <br>3. <a href="/2020/05/31/LeetCode-210-Course-Schedule-II/" title="LeetCode 210. Course Schedule II">LeetCode 210. Course Schedule II</a><br> 4. <a href="/2020/06/02/LeetCode-62-Unique-Paths/" title="LeetCode 62. Unique Paths">LeetCode 62. Unique Paths</a> <br> 5. <a href="/2020/06/02/LeetCode-63-Unique-Paths-II/" title="LeetCode 63. Unique Paths II">LeetCode 63. Unique Paths II</a> <br> 6. <a href="/2020/06/02/LeetCode-64-Minimum-Path-Sum/" title="LeetCode 64. Minimum Path Sum">LeetCode 64. Minimum Path Sum</a> <br> 7. <a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">LeetCode 237. Delete Node in a Linked List(无解析)</a> <br>8. <a href="/2020/06/02/LeetCode-226-Invert-Binary-Tree/" title="LeetCode 226. Invert Binary Tree">LeetCode 226. Invert Binary Tree</a><br></td></tr><tr><td>2020.06.03 <br>(List) <br>(总计:166)</td><td>1. <a href="/2020/06/03/LeetCode-2-Add-Two-Numbers/" title="“LeetCode 2. Add Two Numbers”">“LeetCode 2. Add Two Numbers”</a><br>2. <a href="/2020/06/03/LeetCode-445-Add-Two-Numbers-II/" title="“LeetCode 445. Add Two Numbers II”">“LeetCode 445. Add Two Numbers II”</a> <br>3. <a href="/2020/06/03/LeetCode-21-Merge-Two-Sorted-Lists/" title="LeetCode 21. Merge Two Sorted Lists">LeetCode 21. Merge Two Sorted Lists</a><br> 4. <a href="/2020/06/03/LeetCode-23-Merge-k-Sorted-Lists/" title="LeetCode 23. Merge k Sorted Lists">LeetCode 23. Merge k Sorted Lists</a> <br> 5. <a href="/2020/06/03/LeetCode-141-Linked-List-Cycle/" title="LeetCode 141. Linked List Cycle">LeetCode 141. Linked List Cycle</a> <br>6. <a href="/2020/06/03/LeetCode-142-Linked-List-Cycle-II/" title="LeetCode 142. Linked List Cycle II">LeetCode 142. Linked List Cycle II</a> <br> 7. <a href="/2020/06/03/LeetCode-206-Reverse-Linked-List/" title="LeetCode 206. Reverse Linked List">LeetCode 206. Reverse Linked List</a> <br> 8. <a href="/2020/06/03/LeetCode-92-Reverse-Linked-List-II/" title="LeetCode 92. Reverse Linked List II">LeetCode 92. Reverse Linked List II</a> <br>9. <a href="/2020/06/03/LeetCode-24-Swap-Nodes-in-Pairs/" title="LeetCode 24. Swap Nodes in Pairs">LeetCode 24. Swap Nodes in Pairs</a><br>10. <a href="/2020/06/03/LeetCode-1029-Two-City-Scheduling/" title="LeetCode 1029. Two City Scheduling">LeetCode 1029. Two City Scheduling</a><br></td></tr><tr><td>2020.06.04 <br>(回溯法) <br>(总计:170)</td><td><a href="/2020/06/04/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%B0%8F%E7%BB%93/" title="回溯法总结">回溯法总结</a><br>1. <a href="/2020/06/04/LeetCode-78-Subsets/" title="LeetCode 78. Subsets">LeetCode 78. Subsets</a><br>2. <a href="/2020/06/04/LeetCode-90-Subsets-II/" title="LeetCode 90. Subsets II">LeetCode 90. Subsets II</a><br>3. <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">LeetCode 17. Letter Combinations of a Phone Number(无解析)</a></td></tr><tr><td>2020.06.05 <br> 2020.06.06<br>(回溯法) <br>(总计：182)</td><td><a href="/2020/06/04/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%B0%8F%E7%BB%93/" title="回溯法总结">回溯法总结</a><br>1. <a href="/2020/06/05/LeetCode-46-Permutations/" title="LeetCode 46. Permutations">LeetCode 46. Permutations</a><br>2. <a href="/2020/06/05/LeetCode-47-Permutations-II/" title="LeetCode 47. Permutations II">LeetCode 47. Permutations II</a><br>3. <a href="/2020/06/04/LeetCode-31-Next-Permutation/" title="LeetCode 31. Next Permutation">LeetCode 31. Next Permutation</a><br>4. <a href="https://leetcode.com/problems/merge-sorted-array/">LeetCode 88. Merge Sorted Array(无解析)</a></td></tr><tr><td>2020.06.07<br>（周赛 &amp; Union-Find）<br>(总计：189)</td><td><a href="/2020/06/07/Union-Find%E6%80%BB%E7%BB%93/" title="Union-Find总结">Union-Find总结</a><br>1. <a href="/2020/06/07/LeetCode-518-Coin-Change-2/" title="LeetCode 518. Coin Change 2（待完成）">LeetCode 518. Coin Change 2（待完成）</a><br>2. <a href="/2020/06/07/LeetCode-1473-Paint-House-III/" title="LeetCode 1473. Paint House III（待完成）">LeetCode 1473. Paint House III（待完成）</a><br>3. <a href="/2020/06/07/LeetCode-1471-The-k-Strongest-Values-in-an-Array/" title="LeetCode 1471. The k Strongest Values in an Array（待完成）">LeetCode 1471. The k Strongest Values in an Array（待完成）</a><br>4. <a href="/2020/06/07/LeetCode-399-Evaluate-Division/" title="LeetCode 399. Evaluate Division（待完成）">LeetCode 399. Evaluate Division（待完成）</a><br>5. <a href="https://leetcode.com/problems/keys-and-rooms/">LeetCode 841. Keys and Rooms(无解析)</a><br>6. <a href="https://leetcode.com/problems/friend-circles/">LeetCode 547. Friend Circles(无解析)</a> <br>7. <a href="https://leetcode.com/problems/max-area-of-island/">LeetCode 695. Max Area of Island(无解析)</a><br>8. <a href="https://leetcode.com/problems/number-of-islands/">LeetCode 200. Number of Islands(无解析)</a> <br>9. <a href="https://leetcode.com/problems/find-eventual-safe-states/">LeetCode 802. Find Eventual Safe States(无解析)</a><br> 10. <a href="/2020/06/07/LeetCode-213-House-Robber-II/" title="LeetCode 213. House Robber II（待完成）">LeetCode 213. House Robber II（待完成）</a><br></td></tr><tr><td>2020.06.08<br>（DP）<br>(总计：193)</td><td>1. <a href="/2020/06/08/LeetCode-416-Partition-Equal-Subset-Sum/" title="LeetCode 416. Partition Equal Subset Sum（待完成）">LeetCode 416. Partition Equal Subset Sum（待完成）</a><br>2. <a href="/2020/06/09/LeetCode-300-Longest-Increasing-Subsequence/" title="LeetCode 300. Longest Increasing Subsequence（待完成）">LeetCode 300. Longest Increasing Subsequence（待完成）</a><br>3. <a href="/2020/06/09/LeetCode-887-Super-Egg-Drop/" title="LeetCode 887. Super Egg Drop（待完成）">LeetCode 887. Super Egg Drop（待完成）</a><br></td></tr><tr><td>2020.06.09 <br> (二分查找) <br> (总计：200)</td><td><a href="/2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="二分搜索">二分搜索</a><br>1. <a href="/2020/06/09/LeetCode-378-Kth-Smallest-Element-in-a-Sorted-Matrix/" title="LeetCode 378. Kth Smallest Element in a Sorted Matrix">LeetCode 378. Kth Smallest Element in a Sorted Matrix</a><br>2. <a href="/2020/06/09/LeetCode-875-Koko-Eating-Bananas/" title="LeetCode 875. Koko Eating Bananas">LeetCode 875. Koko Eating Bananas</a><br>3. <a href="/2020/06/09/LeetCode-719-Find-K-th-Smallest-Pair-Distance/" title="LeetCode 719. Find K-th Smallest Pair Distance（待完成）">LeetCode 719. Find K-th Smallest Pair Distance（待完成）</a><br> 4. <a href="/2020/06/09/LeetCode-240-Search-a-2D-Matrix-II/" title="LeetCode 240. Search a 2D Matrix II">LeetCode 240. Search a 2D Matrix II</a><br> 5. <a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/">LeetCode 1011. Capacity To Ship Packages Within D Days(无解析)</a><br> 6. <a href="https://leetcode.com/problems/binary-search/">LeetCode 704. Binary Search(无解析)</a></td></tr><tr><td>2020.06.10 <br> (DP) <br> (总计：205)</td><td><a href="/2020/05/27/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="二分搜索">二分搜索</a><br>1. <a href="/2020/06/11/LeetCode-279-Perfect-Squares/" title="LeetCode 279. Perfect Squares（待补全算法种类）">LeetCode 279. Perfect Squares（待补全算法种类）</a><br>2. <a href="/2020/06/09/LeetCode-875-Koko-Eating-Bananas/" title="LeetCode 875. Koko Eating Bananas">LeetCode 875. Koko Eating Bananas</a><br>3. <a href="/2020/06/09/LeetCode-719-Find-K-th-Smallest-Pair-Distance/" title="LeetCode 719. Find K-th Smallest Pair Distance（待完成）">LeetCode 719. Find K-th Smallest Pair Distance（待完成）</a><br> 4. <a href="/2020/06/09/LeetCode-240-Search-a-2D-Matrix-II/" title="LeetCode 240. Search a 2D Matrix II">LeetCode 240. Search a 2D Matrix II</a><br> 5. <a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/">LeetCode 1011. Capacity To Ship Packages Within D Days(无解析)</a><br> 6. <a href="https://leetcode.com/problems/binary-search/">LeetCode 704. Binary Search(无解析)</a></td></tr><tr><td>2020.06.11 -2020-06.17</td><td>摸鱼</td></tr><tr><td>2020.06.18 <br> (Graph &amp; 顺序刷题) <br> (总计：230)</td><td><a href="/2020/06/18/2020-06-18/" title="2020.06.18无解析题目汇总">2020.06.18无解析题目汇总</a><br>1. <a href="/2020/06/18/LeetCode-130-Surrounded-Regions/" title="LeetCode 130. Surrounded Regions">LeetCode 130. Surrounded Regions</a><br>2. <a href="/2020/06/18/LeetCode-496-Next-Greater-Element-I/" title="LeetCode 496. Next Greater Element I">LeetCode 496. Next Greater Element I</a><br>3. <a href="/2020/06/18/LeetCode-503-Next-Greater-Element-II/" title="LeetCode 503. Next Greater Element II">LeetCode 503. Next Greater Element II</a><br> 4. <a href="/2020/06/18/LeetCode-556-Next-Greater-Element-III/" title="LeetCode 556. Next Greater Element III">LeetCode 556. Next Greater Element III</a><br> 5. <a href="/2020/06/18/LeetCode-32-Longest-Valid-Parentheses/" title="LeetCode 32. Longest Valid Parentheses">LeetCode 32. Longest Valid Parentheses</a><br> 6. <a href="/2020/06/19/LeetCode-37-Sudoku-Solver/" title="LeetCode 37. Sudoku Solver">LeetCode 37. Sudoku Solver</a><br> 7. <a href="/2020/06/18/2020-06-18/" title="LeetCode 37. Sudoku Solver（无解析）">LeetCode 37. Sudoku Solver（无解析）</a><br> 8. <a href="/2020/06/18/2020-06-18/" title="LeetCode 274. H-Index（无解析）">LeetCode 274. H-Index（无解析）</a><br> 9. <a href="/2020/06/18/2020-06-18/" title="LeetCode 275. H-Index II（无解析）">LeetCode 275. H-Index II（无解析）</a><br> 10. <a href="/2020/06/18/2020-06-18/" title="LeetCode 36. Valid Sudoku（无解析）">LeetCode 36. Valid Sudoku（无解析）</a></td></tr><tr><td>2020.06.19 <br> (DP &amp; 顺序刷题) <br>（总计 234）</td><td><a href="/2020/06/19/2020-06-19/" title="2020.06.19无解析题目汇总">2020.06.19无解析题目汇总</a><br>1. <a href="/2020/06/19/LeetCode-1105-Filling-Bookcase-Shelves/" title="LeetCode 1105. Filling Bookcase Shelves">LeetCode 1105. Filling Bookcase Shelves</a><br>2. <a href="/2020/06/19/LeetCode-41-First-Missing-Positive/" title="LeetCode 41. First Missing Positive">LeetCode 41. First Missing Positive</a><br>3. <a href="/2020/06/19/2020-06-19/" title="LeetCode 268. Missing Number（无解析）">LeetCode 268. Missing Number（无解析）</a><br>4. <a href="/2020/06/19/2020-06-19/" title="LeetCode 1048. Longest String Chain（无解析）">LeetCode 1048. Longest String Chain（无解析）</a><br></td></tr><tr><td>2020.06.22 <br> (顺序刷题41-50) <br>（总计 234）</td><td>1. <a href="/2020/06/02/LeetCode-10-Regular-Expression-Matching/" title="LeetCode 10. Regular Expression Matching">LeetCode 10. Regular Expression Matching</a><br> 2. <a href="/2020/06/23/LeetCode-42-Trapping-Rain-Water/" title="LeetCode 42. Trapping Rain Water">LeetCode 42. Trapping Rain Water</a><br>  3. <a href="/2020/06/22/2020-06-22/" title="LeetCode 43. Multiply Strings">LeetCode 43. Multiply Strings</a><br>  4. <a href="/2020/06/22/2020-06-22/" title="LeetCode 48. Rotate Image">LeetCode 48. Rotate Image</a><br>  5. <a href="/2020/06/25/LeetCode-49-Group-Anagrams/" title="LeetCode 49. Group Anagrams">LeetCode 49. Group Anagrams</a></td></tr><tr><td>2020.06.26 <br> (顺序刷题51-70) <br>（总计 255）</td><td>1. <a href="/2020/06/26/2020-06-26/" title="2020.06.26无解析题目汇总">2020.06.26无解析题目汇总</a><br> 2. <a href="/2020/06/26/LeetCode-51-N-Queens/" title="LeetCode 51. N-Queens">LeetCode 51. N-Queens</a><br>3. <a href="/2020/06/26/2020-06-26/" title="LeetCode 52. N-Queens-II">LeetCode 52. N-Queens-II</a><br>  4. <a href="/2020/06/26/LeetCode-54-Spiral-Matrix/" title="LeetCode 54. Spiral Matrix">LeetCode 54. Spiral Matrix</a><br>  4. <a href="/2020/06/22/2020-06-22/" title="LeetCode 48. Rotate Image">LeetCode 48. Rotate Image</a><br>  5. <a href="/2020/06/25/LeetCode-49-Group-Anagrams/" title="LeetCode 49. Group Anagrams">LeetCode 49. Group Anagrams</a></td></tr><tr><td>2020.07.03 <br> (近期未完成Blog题目汇总)</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进度记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="2020/05/18/LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
      <url>2020/05/18/LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236. Lowest Common Ancestor of a Binary Tree</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵二叉树树，给出其两个节点p和q，找出p和q的高度最低公共ancestor节点，本身也是自己的祖先节点。例如：</p><p><img src="/images/leetcode236.png" alt="二叉树" title="Example 1"></p><pre><code>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="recursion-或-stack-hash-table"><a href="#recursion-或-stack-hash-table" class="headerlink" title="recursion 或 stack + hash table"></a>recursion 或 stack + hash table</h3><p>和二叉搜索树的问题不同，二叉树并没有其良好的有序性，不能取巧剪枝很多，所以要完全抛弃掉之前的思路。</p><p>那么如何进行查找呢？这里有两种思路。一种是递归，另一种是stack + hashmap。</p><p>第一种思路。对于某节点node，我们定义left，mid和right三个int变量，left变量表示在node的左节点上是否存在p或q节点(0不存在，1存在)，mid表示node节点本身是否存在p或q节点，right表示node的右子树上是否存在p或q节点。对于我们要找的目标节点target，left+mid+right一定是等于2的，而对于其他节点来说，left+mid+right最多为1，遍历整棵树，可得到目标节点。</p><p>第二种思路。我们先存储p的所有祖先节点，然后q节点不断向上找父节点，直到找到某个节点也在p的祖先节点列表中。我们用map来存储&lt;node, father&gt;键值对，进行遍历，直至map中的key包含了p和q。然后，将p一级级向上查找父节点，直至为null，存储到一个set中；随后对q进行同样操作，直至q包含在set中，此时，q记为所求。</p><p>注意，这里一层层遍历时，只能选择前序遍历或者BFS，不能选择中序遍历或者后续遍历，因为有”map.containsKey(p) &amp;&amp; map.containsKey(q)”作为终止条件，后面两种遍历方式有可能导致ancestors的关系记录不完全！！！！有反例。</p><p><font color=Red>Corner Cases:</font><br>注意lowestAncestor是p或q本身的情况。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>递归</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode lowestAncestor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        findPQ(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> lowestAncestor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findPQ</span><span class="params">(TreeNode node, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lowestAncestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 剪枝，更快一点点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = findPQ(node.left, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = findPQ(node.right, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = ((node == p) || (node == q)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>  (left + mid + right == <span class="number">2</span>) &#123;</span><br><span class="line">            lowestAncestor = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left + mid + right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>记录父节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode lowestAncestor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        Map&lt;TreeNode, TreeNode&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Set&lt;TreeNode&gt; ancestorP = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">        map.put(root, <span class="keyword">null</span>);</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">                map.put(node.right, node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">                map.put(node.left, node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(p) &amp;&amp; map.containsKey(q)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ancestorP.add(p);</span><br><span class="line">            p = map.get(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ancestorP.contains(q))&#123;</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            q = map.get(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> hash table </tag>
            
            <tag> stack </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 235. Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="2020/05/18/LeetCode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"/>
      <url>2020/05/18/LeetCode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">LeetCode 235. Lowest Common Ancestor of a Binary Search Tree</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵BST树，给出其两个节点p和q，找出p和q的高度最低公共ancestor节点，本身也是自己的祖先节点。例如：</p><p><img src="/images/leetcode235.png" alt="平衡二叉树" title="Example 1"></p><pre><code>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="BST树的特性"><a href="#BST树的特性" class="headerlink" title="BST树的特性"></a>BST树的特性</h3><p>这道题和<a href="/2020/05/18/LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/" title="LeetCode 236">LeetCode 236</a>看起来很像，但是做法其实完全不同，本题为easy，用到BST树的特性秒解。</p><p>对于任意一个节点，其左子树的所有值必定小于其右子树的值。我们假设p.val &lt; q.val。因此，对于某节点n，如果n.val &lt; p.val &lt; q.val，则p和q一定都在其右子树，左子树可以全部剪枝；p.val &lt; q.val &lt; n.val，则p和q一定都在其左子树，右子树可以全部剪枝；如果p和q分别在其左子树和右子树上，则它就是那个高度最低的公共祖先节点。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>利用BST数的节点特性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode lowestAncestor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ((p.val - root.val) * (q.val - root.val) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt; root.val) &#123;</span><br><span class="line">                <span class="comment">// p和q都在左子树</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 270. Closest Binary Search Tree Value</title>
      <link href="2020/05/18/LeetCode-270-Closest-Binary-Search-Tree-Value/"/>
      <url>2020/05/18/LeetCode-270-Closest-Binary-Search-Tree-Value/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/closest-binary-search-tree-value/">LeetCode 270. Closest Binary Search Tree Value</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一颗二叉树，给出一个目标double类型的target，找出与其最近的节点值。例如：</p><pre><code>Input: root = [4,2,5,1,3], target = 3.714286, and k = 2    4   / \  2   5 / \1   3Output: 4</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>这道题和<a href="/2020/05/18/LeetCode-272-Closest-Binary-Search-Tree-Value-II/" title="LeetCode 272">LeetCode 272</a>看起来很像，只不过272是要求k个最接近的数。</p><p>这道题只用找一个最接近的数，很简单，直接中序遍历，愿意加一个判断本次和上一次差值不同剪枝条件也可以，我没加。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>中序遍历，用abs函数记录绝对值，closestValue记录最接近的值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> abs = Double.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> closestValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> diff = target - (<span class="keyword">double</span>)root.val;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(diff) &lt; abs) &#123;</span><br><span class="line">                closestValue = root.val;</span><br><span class="line">                abs = Math.abs(diff);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> root.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> closestValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 272. Closest Binary Search Tree Value II</title>
      <link href="2020/05/18/LeetCode-272-Closest-Binary-Search-Tree-Value-II/"/>
      <url>2020/05/18/LeetCode-272-Closest-Binary-Search-Tree-Value-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/">LeetCode 272. Closest Binary Search Tree Value II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一颗二叉树，给出一个目标double类型的target，找出k个与其最近的节点值。例如：</p><pre><code>Input: root = [4,2,5,1,3], target = 3.714286, and k = 2    4   / \  2   5 / \1   3Output: [4,3]</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="中序遍历-Stack-Queue"><a href="#中序遍历-Stack-Queue" class="headerlink" title="中序遍历 + Stack + Queue"></a>中序遍历 + Stack + Queue</h3><p>这道题和<a href="/2020/05/18/LeetCode-270-Closest-Binary-Search-Tree-Value/" title="LeetCode 270">LeetCode 270</a>看起来很像，只不过270是只要求一个最接近的数。</p><p>其实算法就是在一个有序数组里找出最接近target的k个数。在这个数组中和target的关系有两种，一种是大于，一种是小于等于。对于小于等于target的数，我们将其按顺序压入stack中；对于大于target的数，我们将其按顺序放入queue中。然后我们比较栈顶和队首的值，哪个更接近target，就取出哪个，直至k个。</p><p><font color=Red>Corner Cases:</font><br>注意栈和队列为空的情况！</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>LeetCode 105 preorder + inorder<br>使用Arrays.copyOfRange(int[] data, int start, int end)函数，写起来简洁，但是有点慢，而且耗空间大，因为要截取数组。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">closestKValues</span><span class="params">(TreeNode root, <span class="keyword">double</span> target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; larger = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; smaller = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (root.val &lt;= target) &#123;</span><br><span class="line">                    smaller.push(root.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    larger.add(root.val);</span><br><span class="line">                &#125;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (smaller.isEmpty()) &#123;</span><br><span class="line">                result.add(larger.poll());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (larger.peek() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.add(smaller.pop());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> x1 = smaller.peek();</span><br><span class="line">            <span class="keyword">int</span> x2 = larger.peek();</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(x1 - target) &lt; Math.abs(x2 - target)) &#123;</span><br><span class="line">                result.add(x1);</span><br><span class="line">                smaller.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.add(x2);</span><br><span class="line">                larger.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="2020/05/18/LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
      <url>2020/05/18/LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵树的前序遍历和中序遍历的顺序，恢复这棵树。例如：</p><pre><code>For example, givenpreorder = [3,9,20,15,7]inorder = [9,3,15,20,7]Return the following binary tree:     3    / \   9  20    /  \   15   7</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>这道题和<a href="https://leetcode.com/problems/construct-binary-tree-from-postorder-and-inorder-traversal//">LeetCode 106</a>很像，只不过106是给出中序遍历和后序遍历，要求恢复整棵树。</p><p>先拿这道题来说，先序遍历的顺序是“中-&gt;左-&gt;右”，也就是说第一个元素是整棵树的根节点，后面是它的左子树和右子树的节点，但是我们不知道哪些是左子树，哪些是右子树。因此我们需要借助中序遍历，中序遍历的顺序是“左-&gt;中-&gt;右”，找到根节点后，中序遍历数组中，根节点左侧的节点就是其左子树的所有节点，右侧就是其右子树的所有节点；至此，我们知道了左子树的节点个数l和右子树节点个数r，前序遍历中第1到l个元素就是根节点左子树的前序遍历的顺序，右子树同理，随后递归构建其左右子树。</p><h2 id="3-解法（LeetCode-105-amp-106）"><a href="#3-解法（LeetCode-105-amp-106）" class="headerlink" title="3. 解法（LeetCode 105 &amp; 106）"></a>3. 解法（LeetCode 105 &amp; 106）</h2><ol><li>LeetCode 105 preorder + inorder</li></ol><p>使用Arrays.copyOfRange(int[] data, int start, int end)函数，写起来简洁，但是有点慢，而且耗空间大，因为要截取数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = preorder.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootVal) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, rootIndex + <span class="number">1</span>), Arrays.copyOfRange(inorder, <span class="number">0</span>, rootIndex));</span><br><span class="line">        root.right = buildTree(Arrays.copyOfRange(preorder, rootIndex + <span class="number">1</span>, length), Arrays.copyOfRange(inorder, rootIndex + <span class="number">1</span>, length));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>LeetCode 106 postorder + inorder</li></ol><p>第二种方式可以重新构建一个函数，直接传入原始的两个数组，以及其对应的start和end，以及一个用于查找目标value的map，且代码也更加复杂，涉及到的变量很多，但是速度相对更快一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">c<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; inMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        inMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode root = buildTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, inMap);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, Map&lt;Integer, Integer&gt; inMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">    <span class="keyword">int</span> inRoot = inMap.get(root.val);</span><br><span class="line">    <span class="keyword">int</span> numsLeft = inRoot - inStart;</span><br><span class="line">    </span><br><span class="line">    root.left = buildTree(preorder, preStart + <span class="number">1</span>, preStart + numsLeft, inorder, inStart, inRoot - <span class="number">1</span>, inMap);</span><br><span class="line">    root.right = buildTree(preorder, preStart + numsLeft + <span class="number">1</span>, preEnd, inorder, inRoot + <span class="number">1</span>, inEnd, inMap);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 567. Permutation in String</title>
      <link href="2020/05/18/LeetCode-567-Permutation-in-String/"/>
      <url>2020/05/18/LeetCode-567-Permutation-in-String/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/permutation-in-string/">LeetCode 567. Permutation in String</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个字符串s1和s2，判断s2中是否含有s1所有字母的一组排列。例如：</p><pre><code>Input: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;Output: TrueExplanation: s2 contains one permutation of s1 (&quot;ba&quot;).</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="sliding-window"><a href="#sliding-window" class="headerlink" title="sliding window"></a>sliding window</h3><p>这道题和<a href="/2020/05/17/LeetCode-438-Find-All-Anagrams-in-a-String/" title="LeetCode-438">LeetCode-438</a>基本一致，算法也一模一样，只是返回的内容不同，这道题还性对简单点，同样是使用两个数组来记录字母个数，每次滑动窗口时判断是否和目标字母一致。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>双数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dict = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] window = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s1.charAt(i);</span><br><span class="line">            dict[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; end &lt; s1.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2.charAt(end);</span><br><span class="line">            window[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict[i] != window[i]) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">1</span>; end &lt; s2.length(); start++, end++) &#123;</span><br><span class="line">            window[s2.charAt(start - <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            window[s2.charAt(end) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dict[i] != window[i]) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 438. Find All Anagrams in a String</title>
      <link href="2020/05/17/LeetCode-438-Find-All-Anagrams-in-a-String/"/>
      <url>2020/05/17/LeetCode-438-Find-All-Anagrams-in-a-String/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">LeetCode 438. Find All Anagrams in a String</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出两个字符串s和p，p非空，找出s中所有p的同字母异序词的索引。例如：</p><pre><code>Input:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;Output:[0, 6]Explanation:The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="sliding-window"><a href="#sliding-window" class="headerlink" title="sliding window"></a>sliding window</h3><p>首先我们能想到的肯定是暴力破解，找出所有的长度和p相等的子串，然后判断是否和p的组成字符一致。可以AC，但是耗时过长，620ms，不太可取，因此尝试别的思路。</p><p>如何优化呢？其实我们每次去移动这个子串的时候，其实只移动了一位，剩余的完全没动，但是暴力搜索子串会做很多无意义的计算，因此耗时会变长，所以更加友好的方法应该去计算变化值。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>暴力破解法，很多重复计算</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (p.length() &gt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s_length = s.length(), p_length = p.length();</span><br><span class="line">        <span class="keyword">char</span>[] s_array = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] src;</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p_length; i++) &#123;</span><br><span class="line">            dest[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_length - p_length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            src = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p_length; j++) &#123;</span><br><span class="line">                src[s_array[i + j] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; <span class="number">26</span> &amp;&amp; flag) &#123;</span><br><span class="line">                <span class="keyword">if</span> (src[index] != dest[index]) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>记录变化值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.length() &gt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> s_length = s.length(), p_length = p.length();</span><br><span class="line">        <span class="keyword">char</span>[] char_s = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] char_p = p.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] arr_s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>], arr_p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p_length; i++) &#123;</span><br><span class="line">            arr_s[char_s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            arr_p[char_p[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_s[i] != arr_p[i]) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            result.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = p_length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; s_length - <span class="number">1</span>) &#123;</span><br><span class="line">            arr_s[char_s[start] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            start++;</span><br><span class="line">            end++;</span><br><span class="line">            arr_s[char_s[end] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr_s[i] != arr_p[i]) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                result.add(start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 173. Binary Search Tree Iterator</title>
      <link href="2020/05/17/LeetCode-173-Binary-Search-Tree-Iterator/"/>
      <url>2020/05/17/LeetCode-173-Binary-Search-Tree-Iterator/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/binary-search-tree-iterator/">LeetCode 173. Binary Search Tree Iterator</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>实现一个二叉搜索树(BST树)的iterator类，其中包含next函数和hasNext函数。例如：</p><pre><code>Example:    7   /   \  3    15      /  \       9   20 BSTIterator iterator = new BSTIterator(root);iterator.next();    // return 3iterator.next();    // return 7iterator.hasNext(); // return trueiterator.next();    // return 9iterator.hasNext(); // return trueiterator.next();    // return 15iterator.hasNext(); // return trueiterator.next();    // return 20iterator.hasNext(); // return false</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这又是一道关于设计的题目，很明显，最直接的方法，就是使用List按照中序遍历的顺序存储所有的节点，然后记录当前的index。</p><p>根据讨论区大佬的解法，这里还可以用到stack来帮助我们动态地来计算next节点，而不是一次性遍历所有。</p><p>为什么想到要用栈呢？因为就像非递归形式的中序遍历一样的想法，需要用到栈来帮助回溯到父节点。</p><p>或许还可以用Morris遍历？</p><h2 id="3-解法："><a href="#3-解法：" class="headerlink" title="3. 解法："></a>3. 解法：</h2><ol><li>使用List，很笨，但很直接</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; values;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getValues</span><span class="params">(TreeNode root, List list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fe非递归形式中序遍历i</span></span><br><span class="line">        <span class="comment">// Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span></span><br><span class="line">        <span class="comment">// stack.push(root);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// while (！stack.isEmpty() || root == null) &#123;</span></span><br><span class="line">        <span class="comment">//     if (root == null) &#123;</span></span><br><span class="line">        <span class="comment">//         root = stack.pop();</span></span><br><span class="line">        <span class="comment">//         values.add(root.val);</span></span><br><span class="line">        <span class="comment">//         root = root.right;</span></span><br><span class="line">        <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//         stack.push(root);</span></span><br><span class="line">        <span class="comment">//         root = root.left;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getValues(root.left, list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getValues(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        values = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        getValues(root, values);</span><br><span class="line">        index = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = values.size();</span><br><span class="line">        <span class="keyword">if</span> (++index &lt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span> values.get(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index + <span class="number">1</span> &lt; values.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用Stack来帮助动态进行找next节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        pushNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        pushNodes(node.right);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> stack </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 328. Odd Even Linked List</title>
      <link href="2020/05/17/LeetCode-328-Odd-Even-Linked-List/"/>
      <url>2020/05/17/LeetCode-328-Odd-Even-Linked-List/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/odd-even-linked-list/">LeetCode 328. Odd Even Linked List</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个链表，将所有奇数个节点串起来，然后接上所有偶数位的节点。这里说的是节点的index而不是节点的value。例如：</p><pre><code>Example 1:Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>链表+双指针</strong></p><p>这道题不知道为什么划分到medium中，相当于将链表重新排序。这里要用到两个指针，一个指向当前odd的结尾，一个指向even的结尾，注意赋值顺序即可。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p>注意推导，过程，算法本身并不难</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode odd = head, even = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode odd_next_node = even.next;</span><br><span class="line">            ListNode even_next_node = odd_next_node.next;</span><br><span class="line">            ListNode even_start_node = odd.next;</span><br><span class="line"></span><br><span class="line">            odd.next = odd_next_node;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = even_next_node;</span><br><span class="line">            even = even.next;</span><br><span class="line">            odd.next = even_start_node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 637. Average of Levels in Binary Tree</title>
      <link href="2020/05/17/LeetCode-637-Average-of-Levels-in-Binary-Tree/"/>
      <url>2020/05/17/LeetCode-637-Average-of-Levels-in-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">LeetCode 637. Average of Levels in Binary Tree</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一棵树，每个节点都是signed int类型，计算出每一层的平均值（double类型），将其放入一个list中后返回。例如：</p><pre><code>Input:    3   / \  9  20    /  \   15   7Output: [3, 14.5, 11]Explanation:The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Queue-BFS"><a href="#Queue-BFS" class="headerlink" title="Queue + BFS"></a>Queue + BFS</h3><p>首先，我们要想好用什么方式对树进行遍历，BFS or DFS。这里涉及到层数，一层一层来计算，因此BFS相对更好一些。DFS则需要用Queue来对节点进行存储，问题是怎么样对不同层级来计算，这里在循环每一层之前，用一个size变量来记录当前Queue大小，这个大小就是这一层层级的节点数。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>注意使用变量记录当前界定个数，方便循环。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; result = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue1.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue1.size();</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode temp = queue1.poll();</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue1.offer(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue1.offer(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">                sum += temp.val;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.add(<span class="keyword">new</span> Double(sum / size));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 532. K-diff Pairs in an Array</title>
      <link href="2020/05/17/LeetCode-532-K-diff-Pairs-in-an-Array/"/>
      <url>2020/05/17/LeetCode-532-K-diff-Pairs-in-an-Array/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/k-diff-pairs-in-an-array/">LeetCode 532. K-diff Pairs in an Array</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个数组nums，一个整数k，找出数组内差绝对值为k的数组对的个数，（i,j）和（j, i）算同一个。例如：</p><pre><code>Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="2-1-HashSet"><a href="#2-1-HashSet" class="headerlink" title="2.1 HashSet"></a>2.1 HashSet</h3><p>首先，我们要想好用什么样的数据结构来存储。因为重复时，只计算一对，所以这种数据结构要有去重的效果，我们首先考虑Set，与此同时我们又发现，如果k=0的时候，我们又需要计算有重复的数有多少个，且2个重复的数和10个重复的数是一样的，在k=0时都只能算一对。所以单一的值存储不满足我们的需求，这时我们想到要用Map来存储，Key是值，Value是出现的次数。</p><p><strong>Corner Cases：</strong></p><ol><li>k&lt;0，nums为空数组或者null。</li><li>k=0，nums为(1, 1, 1, 2, 2)之类的有多组重复。</li></ol><h3 id="2-2-数组排序"><a href="#2-2-数组排序" class="headerlink" title="2.2 数组排序"></a>2.2 数组排序</h3><p>如果我们仅利用数组的话，逻辑相对复杂，但速度会快一些，逻辑如下。</p><ol><li>首先将数组从小到大排序；</li><li>定义lo和hi为两个pointer，初始值为0；n为数组长度</li><li>当hi &lt; n时，循环：如果lo &gt;= hi，hi = lo + 1，循环继续；如果nums[hi] - nums[lo] &lt; k，hi++；如果nums[hi] - nums[lo] &gt; k，lo++；如果nums[hi] - nums[lo] = k，count++，lo++，且循lo++，直至下一个不同的值。</li></ol><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>注意hashMap的遍历方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((nums == <span class="keyword">null</span>) || (nums.length == <span class="number">0</span>) || (k &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = hashMap.get(nums[i]);</span><br><span class="line">                hashMap.put(nums[i], ++value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hashMap.containsKey(entry.getKey() + k)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 402：Remove K Digits</title>
      <link href="2020/05/17/LeetCode-402%EF%BC%9ARemove-K-Digits/"/>
      <url>2020/05/17/LeetCode-402%EF%BC%9ARemove-K-Digits/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/remove-k-digits/">LeetCode 402：Remove K Digits</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个数字组成的字符串num，从中去除k位后使其得到的数字最小。注意，要将首位的0全部去掉，举例：</p><pre><code>Input: num = &quot;1432219&quot;, k = 3Output: &quot;1219&quot;Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.Input: num = &quot;10200&quot;, k = 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.  </code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>贪心法 + Stack：</strong></p><p>先看去除一位的情况，去除一位时，一位一位从前向后数，找到第一个<em>逆序数对</em>时，即第k + 1位小于第k位，此时，删除第k位。去除多位的情况重复以上操作，直至满足要求。</p><p><strong>Corner Case：</strong></p><ol><li>首先注意如果剩余数字的位数为空，则应该返回“0”，而不是空字符串。</li><li>在最后去除首位0的时候，注意数组不能越界，存在去除数字后为“0000…0”的情况。</li></ol><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p>这里参考了讨论区的大佬的做法，用数组替代了stack，使用了一个top变量俩控制栈顶，十分巧妙。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = num.length();</span><br><span class="line">        <span class="keyword">int</span> digits = length - k;</span><br><span class="line">        <span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = num.charAt(i);</span><br><span class="line">            <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; top &gt; <span class="number">0</span> &amp;&amp; stack[top - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                top--;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            stack[top++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// attention : corner case</span></span><br><span class="line">        <span class="keyword">int</span> startZeros = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(startZeros &lt; digits &amp;&amp; stack[startZeros] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            startZeros++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// attention : corner case</span></span><br><span class="line">        <span class="keyword">return</span> startZeros == digits ? <span class="string">&quot;0&quot;</span> : <span class="keyword">new</span> String(stack, startZeros, digits - startZeros);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> greedy </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 297. Serialize and Deserialize Binary Tree</title>
      <link href="2020/05/17/LeetCode-297-Serialize-and-Deserialize-Binary-Tree/"/>
      <url>2020/05/17/LeetCode-297-Serialize-and-Deserialize-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">LeetCode 297. Serialize and Deserialize Binary Tree</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>设计一组加密/解密二叉树的方式，加密的结果返回为字符串，解密的结果返回重建后二叉树的根节点。方法不一，尽可能发挥想象力。例如：</p><pre><code>Example: You may serialize the following tree:     1    / \   2   3      / \     4   5as &quot;[1,2,3,null,null,4,5]&quot;</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p>这是一道关于设计的题目。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String NULL_C = <span class="string">&quot;#&quot;</span>, SPLITER = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serial(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(NULL_C).append(SPLITER);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(root.val).append(SPLITER);</span><br><span class="line">            serial(root.left, sb);</span><br><span class="line">            serial(root.right, sb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        queue.addAll(Arrays.asList(data.split(SPLITER)));</span><br><span class="line">        <span class="keyword">return</span> deserial(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">deserial</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        String temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (temp.equals(NULL_C)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(temp));</span><br><span class="line">            node.left = deserial(queue);</span><br><span class="line">            node.right = deserial(queue);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 145. Binary Tree Postorder Traversal</title>
      <link href="2020/05/17/LeetCode-145-Binary-Tree-Postorder-Traversal/"/>
      <url>2020/05/17/LeetCode-145-Binary-Tree-Postorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">LeetCode 145. Binary Tree Postorder Traversal</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一颗二叉树，返回其后序遍历的顺序（List形式），且尽量使用非递归的形式。例如：</p><pre><code>Input: [1,null,2,3]1 \  2 /3Output: [3,2,1]  </code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>Stack：</strong></p><p>递归的形式很好写，普通的后序遍历，这里不再赘述。问题在于非递归（迭代）的形式怎么办。</p><p>后序遍历应该是三种遍历中最难的一种了，为什么呢？问题在于我们很难界定什么时候去访问节点，什么时候去压栈。我们访问的顺序应该是“左-&gt;右-&gt;中”，也就是说我们压栈的顺序是“中-&gt;右-&gt;左”。</p><p>以上面为例，如果当前节点node为2节点，我们如何判断接下来是将3节点push下去还是访问2节点然后跳出呢？<strong>这里用一个lastNode变量来判断上次访问是否是当前节点的孩子节点。</strong></p><p><strong>遍历过程：</strong></p><ol><li>将根节点压栈；</li><li>如果栈不为空，则循环：pop栈顶元素给node，如果当前节点为叶子节点<strong>或</strong>者当前节点是lastNode的父节点，则访问该节点的值；如果都不满足，则说明当前节点的孩子还没被压栈，按照“中-&gt;右-&gt;左”的顺序压栈。</li><li>栈为空，循环终了</li></ol><!-- **Condition Statement：**1. 注意，第一种解法中这里要先把root给压栈。2. 第一种解法中，要注意root为null的情况，所以while判断条件中加了node ！= null的条件，否则会出现NullPointerException。3. 第二种解法中，压栈的目的只是为了回溯找右节点，而不是弹出时访问。第一种解法更清晰，是弹出时访问。二者思路有很大不同。 --><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>遍历时，注意lastNode的赋值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode node = root, lastNode = root;</span><br><span class="line">        stack.push(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> ((node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) || node.left == lastNode || node.right == lastNode) &#123;</span><br><span class="line">                <span class="comment">// node为叶子节点或者访问返回到当前节点</span></span><br><span class="line">                list.add(node.val);</span><br><span class="line">                lastNode = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 栈还没压到叶子节点</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 144. Binary Tree Preorder Traversal</title>
      <link href="2020/05/17/LeetCode-144-Binary-Tree-Preorder-Traversal/"/>
      <url>2020/05/17/LeetCode-144-Binary-Tree-Preorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">LeetCode 144. Binary Tree Preorder Traversal</a></p><h2 id="1-题目简述："><a href="#1-题目简述：" class="headerlink" title="1. 题目简述："></a>1. 题目简述：</h2><p>给出一颗二叉树，返回其前序遍历的顺序（List形式），且尽量使用非递归的形式。例如：</p><pre><code>Input: [1,null,2,3]1 \  2 /3Output: [1,2,3]  </code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>Stack：</strong></p><p>递归的形式很好写，普通的前序遍历，这里不再赘述。问题在于非递归（迭代）的形式怎么办。</p><p>我们都知道递归其实就是计算完某节点后不断返回上一级的方法，如果用递归达到同样效果，一般都需要使用栈Stack！</p><p><strong>遍历过程：</strong></p><ol><li>如果节点不为空，访问某节点。</li><li>如果某节点存在右子树，压栈；如果存在左子树，压栈（这样弹出时是先左后右）。</li></ol><p><strong>Condition Statement：</strong></p><ol><li>注意，第一种解法中这里要先把root给压栈。</li><li>第一种解法中，要注意root为null的情况，所以while判断条件中加了node ！= null的条件，否则会出现NullPointerException。</li><li>第二种解法中，压栈的目的只是为了回溯找右节点，而不是弹出时访问。第一种解法更清晰，是弹出时访问。二者思路有很大不同。</li></ol><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p>这里提供两种遍历思路：</p><ol><li>遍历时先压右子树，再压左子树。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        stack.push(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>压栈的目的只是为了回溯找右节点，不是压左右子树，而是访问过的节点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (！stack.isEmpty() || node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop().right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 96. Unique Binary Search Trees</title>
      <link href="2020/05/17/LeetCode-96-Unique-Binary-Search-Trees/"/>
      <url>2020/05/17/LeetCode-96-Unique-Binary-Search-Trees/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/unique-binary-search-trees/">LeetCode 96. Unique Binary Search Trees</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给一个正整数n，节点为（1, 2, 3…n），计算出所有可能存在的BST树的个数。例如：</p><pre><code>Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST&#39;s: 1         3     3      2      1  \       /     /      / \      \   3     2     1      1   3      2  /     /       \                 \ 2     1         2                 3</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>动态规划</strong></p><p>我们假设函数G(n)为所有可能存在的BST树的个数；函数F(i,n)为以i为根节点，存在的所有BST的个数；我们已知G(0)=1，G(1)=1。</p><p>那么我们如何求G(n)呢？<strong>对于任意的i为根节点时</strong>，其中1&lt;= i &lt;= n，节点[1, i-1]必定都在i节点的左子树；节点[i+1, n]必定都在i节点的右子树，左右子树可以为空；此时F(i,n)=G(i-1)*G(n-i)，i取值从1到n，所以如果要计算G(n)，G(n)的根节点有n种可能，需要将这n种都加起来。</p><p>$$ G(n)=F(1,n)+F(2,n)+…+F(n,n)=G(0)\times G(n-1)+G(1)\times G(n-2)+…+G(n-1)\times G(0) $$</p><p>因此，计算G(n)需要计算出G(1)到G(n-1)。例如：计算G(3)</p><p>$$G(3)=F(1,3)+F(2,3)+F(3,3)=G(0)\times G(2)+G(1)\times G(1)+G(2)\times G(0)=2+1+2=5$$</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><p>注意推导，过程，算法本身并不难</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> core problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 95. Unique Binary Search Trees II</title>
      <link href="2020/05/17/LeetCode-95-Unique-Binary-Search-Trees-II/"/>
      <url>2020/05/17/LeetCode-95-Unique-Binary-Search-Trees-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/">LeetCode 95. Unique Binary Search Trees II</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给一个正整数n，节点为（1, 2, 3…n），返回所有可能的BST树的list。例如：</p><pre><code>Input: 3Output:[[1,null,3,2],[3,2,null,1],[3,1,null,null,2],[2,1,3],[1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&#39;s shown below:   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>动态规划</strong></p><p>思路和96题类似，只不过<a href="/leetcode-diary/96-unique-binary-search-trees">96题</a>是求个数，这里是求所有树。</p><p>我们需要构造一个函数，该函数的目的是返回送start到end的所有可能子树的根节点的list(闭区间)。</p><h2 id="3-解法："><a href="#3-解法：" class="headerlink" title="3. 解法："></a>3. 解法：</h2><p>注意推导，过程，算法本身并不难，在genTrees方法中，不需要判断start==end，因为start是可以和end相等的，表示此时到达根节点，下一次就该返回null了。注意，在start&gt;end时需要将null值放入list中，否则根节点的子节点无法指向null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> genTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">genTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; result = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (start == end) &#123;</span></span><br><span class="line">        <span class="comment">//     TreeNode node = new TreeNode(start);</span></span><br><span class="line">        <span class="comment">//     result.add(node);</span></span><br><span class="line">        <span class="comment">//     return result;</span></span><br><span class="line">        <span class="comment">// &#125; else</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            result.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftList = genTrees(start, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightList = genTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (TreeNode leftNode : leftList) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode rightNode : rightList) &#123;</span><br><span class="line">                    TreeNode node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    node.left = leftNode;</span><br><span class="line">                    node.right = rightNode;</span><br><span class="line">                    result.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 94. Binary Tree Inorder Traversal</title>
      <link href="2020/05/17/LeetCode-94-Binary-Tree-Inorder-Traversal/"/>
      <url>2020/05/17/LeetCode-94-Binary-Tree-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">LeetCode 94. Binary Tree Inorder Traversal</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一颗二叉树，返回其中序遍历的顺序（List形式），且尽量使用非递归的形式。例如：</p><pre><code>Input: [1,null,2,3]1 \  2 /3Output: [1,3,2]  </code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>Stack：</strong></p><p>递归的形式很好写，普通的中序遍历，这里不再赘述。问题在于非递归（迭代）的形式怎么办。</p><p>我们都知道递归其实就是计算完某节点后不断返回上一级的方法，如果用递归达到同样效果，一般都需要使用栈Stack！</p><p><strong>遍历过程：</strong></p><ol><li>如果某节点存在左子树，压栈，访问左子树（这里压栈的目的是一级一级可以回溯）。</li><li>如果节点没有左子树，说明该次访问已经到最底层，出栈，访问该节点，然后判断右子树是否为空，如果为空，继续pop，直至栈为空结束或者右子树不为空，将指针指向该节点的右子树。</li></ol><p><strong>Condition Statement：</strong></p><ol><li>当且仅当node为null且Stack为空时，循环结束（初次进入循环时，栈为空，但node不为空；当node为空时，一般都是要pop，除了最后）。</li></ol><h2 id="3-解法："><a href="#3-解法：" class="headerlink" title="3. 解法："></a>3. 解法：</h2><p>这里提供两种遍历思路：个人倾向于第二种，比较简洁。</p><ol><li>判断节点的左子树是否为空</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123; <span class="comment">// 下面的循环里保证了node在遍历未结束时不为null</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">while</span> (node.right == <span class="keyword">null</span> &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>判断节点是否为空</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> stack </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 918. Maximum Sum Circular Subarray</title>
      <link href="2020/05/17/LeetCode-918-Maximum-Sum-Circular-Subarray/"/>
      <url>2020/05/17/LeetCode-918-Maximum-Sum-Circular-Subarray/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/">LeetCode 918. Maximum Sum Circular Subarray</a></p><h2 id="1-题目简述"><a href="#1-题目简述" class="headerlink" title="1. 题目简述"></a>1. 题目简述</h2><p>给出一个<strong>环形</strong>数组A，找出其非空子序列的最大sum值。例如：</p><pre><code>Example 1:Input: [1,-2,3,-2]Output: 3Explanation: Subarray [3] has maximum sum 3Example 2:Input: [5,-3,5]Output: 10Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10Example 3:Input: [3,-1,2,-1]Output: 4Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4Example 4:Input: [3,-2,2,-3]Output: 3Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3Example 5:Input: [-2,-3,-1]Output: -1Explanation: Subarray [-1] has maximum sum -1</code></pre><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="Greedy-amp-Dynamic-Programming"><a href="#Greedy-amp-Dynamic-Programming" class="headerlink" title="Greedy &amp; Dynamic Programming"></a>Greedy &amp; Dynamic Programming</h3><p>首先，这道题和LeetCode 53 Maximum Subarray 有异曲同工之妙，我们先来回忆一下如何求一个数组的子序列的最大值。</p><p>假设某数组arr长度为n，对于中间某位置第i个元素，设函数F(i)为<strong>元素0到i的包含元素i的最大子序列之和</strong>，则F(i+1)有如下推导：</p><p>$$F(i+1)=max(F(i)+arr[i+1],F(i))（0&lt; i&lt; n)$$</p><p>每次循环都记录F(i)和全局maxValue值的比较，循环结束，maxValue即为所求。</p><p>当我们确定了如何求最大值时，也就意味着我们如何求<strong>最小子序列值</strong>，与上同理。</p><p>对于一个环形序列来说，最大子序列有两种可能，一种是和普通的数组一样，并没有从数组的队尾绕回队首；第二种可能性是最大子序列从队尾绕回了队首。</p><p>对于前者来说，计算方法和53题一致，对于后者来说就有点麻烦了，如果还是用常规思路比较复杂。我们反过来想，如果一个数组和为sum，其最小子序列之和为minSubValue，那么它的环形最大子序列之和就是sum-minSubValue。</p><h3 id="Corner-Case"><a href="#Corner-Case" class="headerlink" title=" Corner Case "></a><font color=Red> Corner Case </font></h3><p>Attention：这里有一个很可怕的corner case，如果数组全部为负数（Example 5），那么其全局最小子序列值为所有值之和，环形最大子序列之和就为0，这种情况应当直接返回连续最大子序列之和，其实也就是整个数组的最大值，也是负数（但凡有一个正数都不会这样）。</p><h2 id="3-解法"><a href="#3-解法" class="headerlink" title="3. 解法"></a>3. 解法</h2><ol><li>注意使用变量记录当前界定个数，方便循环。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> contiguousMaxValue = contiguousMax(A);</span><br><span class="line">        <span class="keyword">int</span> cicularMaxValue = cicularMax(A);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> contiguousMaxValue &lt; <span class="number">0</span> ? contiguousMaxValue : Math.max(contiguousMaxValue, cicularMaxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">contiguousMax</span> <span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = Integer.MIN_VALUE, currentMax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            currentMax += A[i];</span><br><span class="line">            maxValue = currentMax &gt; maxValue ? currentMax : maxValue;</span><br><span class="line">            currentMax = currentMax &lt; <span class="number">0</span> ? <span class="number">0</span> : currentMax;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">cicularMax</span> <span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minValue = Integer.MAX_VALUE, sum = <span class="number">0</span>, currentMin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            currentMin += A[i];</span><br><span class="line">            minValue = currentMin &lt; minValue ? currentMin : minValue;</span><br><span class="line">            currentMin = currentMin &gt; <span class="number">0</span> ? <span class="number">0</span> : currentMin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum - minValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> array </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
